var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"DCMotor_Control","ref":false,"files":[{"name":"DCMotor_Control.c","type":"source","group":"model","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: DCMotor_Control.c\r\n *\r\n * Code generated for Simulink model 'DCMotor_Control'.\r\n *\r\n * Model version                  : 2.21\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Jun 29 00:50:41 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"DCMotor_Control.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n/* Used by FromWorkspace Block: '<S2>/FromWs' */\r\n#ifndef rtInterpolate\r\n# define rtInterpolate(v1,v2,f1,f2)    (((v1)==(v2))?((double)(v1)): (((f1)*((double)(v1)))+((f2)*((double)(v2)))))\r\n#endif\r\n\r\n#ifndef rtRound\r\n# define rtRound(v)                    ( ((v) >= 0) ? floor((v) + 0.5) : ceil((v) - 0.5) )\r\n#endif\r\n\r\n/* Continuous states */\r\nX rtX;\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\n\r\n/* private model entry point functions */\r\nextern void DCMotor_Control_derivatives(void);\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 3;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  DCMotor_Control_derivatives();\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  DCMotor_Control_step();\r\n  DCMotor_Control_derivatives();\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  DCMotor_Control_step();\r\n  DCMotor_Control_derivatives();\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\n/* Model step function */\r\nvoid DCMotor_Control_step(void)\r\n{\r\n  /* local block i/o variables */\r\n  real_T rtb_FromWs;\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    /* set solver stop time */\r\n    if (!(rtM->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&rtM->solverInfo, ((rtM->Timing.clockTickH0 + 1) *\r\n        rtM->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&rtM->solverInfo, ((rtM->Timing.clockTick0 + 1) *\r\n        rtM->Timing.stepSize0 + rtM->Timing.clockTickH0 * rtM->Timing.stepSize0 *\r\n        4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(rtM)) {\r\n    rtM->Timing.t[0] = rtsiGetT(&rtM->solverInfo);\r\n  }\r\n\r\n  {\r\n    NeslSimulationData *simulationData;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    int32_T tmp_2;\r\n    int_T tmp_1[2];\r\n    boolean_T tmp;\r\n    boolean_T tmp_0;\r\n\r\n    /* SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n    if (rtDW.STATE_1_FirstOutput) {\r\n      simulationData = (NeslSimulationData *)rtDW.STATE_1_SimData;\r\n      rtDW.time = rtM->Timing.t[0];\r\n      simulationData->mData->mTime.mN = 1;\r\n      simulationData->mData->mTime.mX = &rtDW.time;\r\n      simulationData->mData->mContStates.mN = 3;\r\n      simulationData->mData->mContStates.mX =\r\n        &rtX.DCMotor_ControlDC_Motor_Simscap[0];\r\n      simulationData->mData->mDiscStates.mN = 0;\r\n      simulationData->mData->mDiscStates.mX = &rtDW.STATE_1_Discrete;\r\n      simulationData->mData->mModeVector.mN = 0;\r\n      simulationData->mData->mModeVector.mX = &rtDW.STATE_1_Modes;\r\n      tmp = false;\r\n      simulationData->mData->mFoundZcEvents = tmp;\r\n      tmp = rtmIsMajorTimeStep(rtM);\r\n      simulationData->mData->mIsMajorTimeStep = tmp;\r\n      tmp_0 = false;\r\n      simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n      simulationData->mData->mIsSolverCheckingCIC = false;\r\n      tmp_0 = rtsiIsSolverComputingJacobian(&rtM->solverInfo);\r\n      simulationData->mData->mIsComputingJacobian = tmp_0;\r\n      simulationData->mData->mIsEvaluatingF0 = false;\r\n      simulationData->mData->mIsSolverRequestingReset = false;\r\n      simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n      tmp_1[0] = 0;\r\n      rtDW.dv[0] = rtDW.INPUT_1_1_1[0];\r\n      rtDW.dv[1] = rtDW.INPUT_1_1_1[1];\r\n      rtDW.dv[2] = rtDW.INPUT_1_1_1[2];\r\n      rtDW.dv[3] = rtDW.INPUT_1_1_1[3];\r\n      tmp_1[1] = 4;\r\n      simulationData->mData->mInputValues.mN = 4;\r\n      simulationData->mData->mInputValues.mX = &rtDW.dv[0];\r\n      simulationData->mData->mInputOffsets.mN = 2;\r\n      simulationData->mData->mInputOffsets.mX = &tmp_1[0];\r\n      simulationData->mData->mOutputs.mN = 3;\r\n      simulationData->mData->mOutputs.mX = &rtDW.STATE_1[0];\r\n      simulationData->mData->mSampleHits.mN = 0;\r\n      simulationData->mData->mSampleHits.mX = NULL;\r\n      simulationData->mData->mIsFundamentalSampleHit = false;\r\n      simulationData->mData->mTolerances.mN = 0;\r\n      simulationData->mData->mTolerances.mX = NULL;\r\n      simulationData->mData->mCstateHasChanged = false;\r\n      diagnosticManager = (NeuDiagnosticManager *)rtDW.STATE_1_DiagMgr;\r\n      diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n      tmp_2 = ne_simulator_method((NeslSimulator *)rtDW.STATE_1_Simulator,\r\n        NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n      if (tmp_2 != 0) {\r\n        tmp = error_buffer_is_empty(rtmGetErrorStatus(rtM));\r\n        if (tmp) {\r\n          msg = rtw_diagnostics_msg(diagnosticTree);\r\n          rtmSetErrorStatus(rtM, msg);\r\n        }\r\n      }\r\n\r\n      rtDW.STATE_1_FirstOutput = false;\r\n    } else {\r\n      rtDW.STATE_1[0] = rtX.DCMotor_ControlDC_Motor_Simscap[0];\r\n      rtDW.STATE_1[1] = rtX.DCMotor_ControlDC_Motor_Simscap[1];\r\n      rtDW.STATE_1[2] = rtX.DCMotor_ControlDC_Motor_Simscap[2];\r\n    }\r\n\r\n    /* End of SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n\r\n    /* SimscapeExecutionBlock: '<S14>/OUTPUT_1_1' */\r\n    rtDW.OUTPUT_1_1[0] = 0.0;\r\n    rtDW.OUTPUT_1_1[1] = 0.0;\r\n    rtDW.OUTPUT_1_1[1] += 0.004 * rtDW.STATE_1[1];\r\n    rtDW.OUTPUT_1_1[0] += rtDW.STATE_1[2];\r\n\r\n    /* FromWorkspace: '<S2>/FromWs' */\r\n    {\r\n      real_T *pDataValues = (real_T *) rtDW.FromWs_PWORK.DataPtr;\r\n      real_T *pTimeValues = (real_T *) rtDW.FromWs_PWORK.TimePtr;\r\n      int_T currTimeIndex = rtDW.FromWs_IWORK.PrevIndex;\r\n      real_T t = rtM->Timing.t[0];\r\n\r\n      /* Get index */\r\n      if (t <= pTimeValues[0]) {\r\n        currTimeIndex = 0;\r\n      } else if (t >= pTimeValues[57]) {\r\n        currTimeIndex = 56;\r\n      } else {\r\n        if (t < pTimeValues[currTimeIndex]) {\r\n          while (t < pTimeValues[currTimeIndex]) {\r\n            currTimeIndex--;\r\n          }\r\n        } else {\r\n          while (t >= pTimeValues[currTimeIndex + 1]) {\r\n            currTimeIndex++;\r\n          }\r\n        }\r\n      }\r\n\r\n      rtDW.FromWs_IWORK.PrevIndex = currTimeIndex;\r\n\r\n      /* Post output */\r\n      {\r\n        real_T t1 = pTimeValues[currTimeIndex];\r\n        real_T t2 = pTimeValues[currTimeIndex + 1];\r\n        if (t1 == t2) {\r\n          if (t < t1) {\r\n            rtb_FromWs = pDataValues[currTimeIndex];\r\n          } else {\r\n            rtb_FromWs = pDataValues[currTimeIndex + 1];\r\n          }\r\n        } else {\r\n          real_T f1 = (t2 - t) / (t2 - t1);\r\n          real_T f2 = 1.0 - f1;\r\n          real_T d1;\r\n          real_T d2;\r\n          int_T TimeIndex = currTimeIndex;\r\n          d1 = pDataValues[TimeIndex];\r\n          d2 = pDataValues[TimeIndex + 1];\r\n          rtb_FromWs = (real_T) rtInterpolate(d1, d2, f1, f2);\r\n          pDataValues += 58;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* ModelReference: '<Root>/Controller' */\r\n    Controller(&(rtDW.Controller_InstanceData.rtm), &rtb_FromWs,\r\n               &rtDW.OUTPUT_1_1[0], &rtDW.Controller_k,\r\n               &(rtDW.Controller_InstanceData.rtdw));\r\n\r\n    /* ModelReference: '<Root>/Controller1' */\r\n    Controller(&(rtDW.Controller1_InstanceData.rtm), &rtb_FromWs,\r\n               &rtDW.OUTPUT_1_1[0], &rtDW.Controller1,\r\n               &(rtDW.Controller1_InstanceData.rtdw));\r\n\r\n    /* SimscapeInputBlock: '<S14>/INPUT_1_1_1' */\r\n    rtDW.INPUT_1_1_1[0] = rtDW.Controller_k;\r\n    rtDW.INPUT_1_1_1[1] = 0.0;\r\n    rtDW.INPUT_1_1_1[2] = 0.0;\r\n    if (rtmIsMajorTimeStep(rtM)) {\r\n      rtDW.INPUT_1_1_1_Discrete[0] = !(rtDW.INPUT_1_1_1[0] ==\r\n        rtDW.INPUT_1_1_1_Discrete[1]);\r\n      rtDW.INPUT_1_1_1_Discrete[1] = rtDW.INPUT_1_1_1[0];\r\n    }\r\n\r\n    rtDW.INPUT_1_1_1[0] = rtDW.INPUT_1_1_1_Discrete[1];\r\n    rtDW.INPUT_1_1_1[3] = rtDW.INPUT_1_1_1_Discrete[0];\r\n\r\n    /* End of SimscapeInputBlock: '<S14>/INPUT_1_1_1' */\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    NeslSimulationData *simulationData;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T time;\r\n    int32_T tmp_2;\r\n    int_T tmp_1[2];\r\n    boolean_T tmp;\r\n    boolean_T tmp_0;\r\n\r\n    /* Update for SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n    simulationData = (NeslSimulationData *)rtDW.STATE_1_SimData;\r\n    time = rtM->Timing.t[0];\r\n    simulationData->mData->mTime.mN = 1;\r\n    simulationData->mData->mTime.mX = &time;\r\n    simulationData->mData->mContStates.mN = 3;\r\n    simulationData->mData->mContStates.mX =\r\n      &rtX.DCMotor_ControlDC_Motor_Simscap[0];\r\n    simulationData->mData->mDiscStates.mN = 0;\r\n    simulationData->mData->mDiscStates.mX = &rtDW.STATE_1_Discrete;\r\n    simulationData->mData->mModeVector.mN = 0;\r\n    simulationData->mData->mModeVector.mX = &rtDW.STATE_1_Modes;\r\n    tmp = false;\r\n    simulationData->mData->mFoundZcEvents = tmp;\r\n    tmp = rtmIsMajorTimeStep(rtM);\r\n    simulationData->mData->mIsMajorTimeStep = tmp;\r\n    tmp_0 = false;\r\n    simulationData->mData->mIsSolverAssertCheck = tmp_0;\r\n    simulationData->mData->mIsSolverCheckingCIC = false;\r\n    tmp_0 = rtsiIsSolverComputingJacobian(&rtM->solverInfo);\r\n    simulationData->mData->mIsComputingJacobian = tmp_0;\r\n    simulationData->mData->mIsEvaluatingF0 = false;\r\n    simulationData->mData->mIsSolverRequestingReset = false;\r\n    simulationData->mData->mIsOkayToUpdateMode = tmp;\r\n    tmp_1[0] = 0;\r\n    rtDW.dv1[0] = rtDW.INPUT_1_1_1[0];\r\n    rtDW.dv1[1] = rtDW.INPUT_1_1_1[1];\r\n    rtDW.dv1[2] = rtDW.INPUT_1_1_1[2];\r\n    rtDW.dv1[3] = rtDW.INPUT_1_1_1[3];\r\n    tmp_1[1] = 4;\r\n    simulationData->mData->mInputValues.mN = 4;\r\n    simulationData->mData->mInputValues.mX = &rtDW.dv1[0];\r\n    simulationData->mData->mInputOffsets.mN = 2;\r\n    simulationData->mData->mInputOffsets.mX = &tmp_1[0];\r\n    diagnosticManager = (NeuDiagnosticManager *)rtDW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_2 = ne_simulator_method((NeslSimulator *)rtDW.STATE_1_Simulator,\r\n      NESL_SIM_UPDATE, simulationData, diagnosticManager);\r\n    if (tmp_2 != 0) {\r\n      tmp = error_buffer_is_empty(rtmGetErrorStatus(rtM));\r\n      if (tmp) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(rtM, msg);\r\n      }\r\n    }\r\n\r\n    /* End of Update for SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n\r\n    /* Update for ModelReference: '<Root>/Controller' */\r\n    Controller_Update(&(rtDW.Controller_InstanceData.rtm),\r\n                      &(rtDW.Controller_InstanceData.rtdw));\r\n\r\n    /* Update for ModelReference: '<Root>/Controller1' */\r\n    Controller_Update(&(rtDW.Controller1_InstanceData.rtm),\r\n                      &(rtDW.Controller1_InstanceData.rtdw));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(rtM)) {\r\n    rt_ertODEUpdateContinuousStates(&rtM->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++rtM->Timing.clockTick0)) {\r\n      ++rtM->Timing.clockTickH0;\r\n    }\r\n\r\n    rtM->Timing.t[0] = rtsiGetSolverStopTime(&rtM->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [1.0E-5s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 1.0E-5, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      rtM->Timing.clockTick1++;\r\n      if (!rtM->Timing.clockTick1) {\r\n        rtM->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid DCMotor_Control_derivatives(void)\r\n{\r\n  XDot *_rtXdot;\r\n  _rtXdot = ((XDot *) rtM->derivs);\r\n\r\n  /* Derivatives for SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[0] = 0.0;\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[1] = 0.0;\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[2] = 0.0;\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[0] += -199191.464056792 *\r\n    rtX.DCMotor_ControlDC_Motor_Simscap[0];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[1] += 1.1860623188219483E+8 *\r\n    rtX.DCMotor_ControlDC_Motor_Simscap[0];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[0] += -28.2610464664868 *\r\n    rtX.DCMotor_ControlDC_Motor_Simscap[1];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[1] += -2991.464393393057 *\r\n    rtX.DCMotor_ControlDC_Motor_Simscap[1];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[2] += 0.004 *\r\n    rtX.DCMotor_ControlDC_Motor_Simscap[1];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[0] += 83354.171677110935 *\r\n    rtDW.INPUT_1_1_1[0];\r\n  _rtXdot->DCMotor_ControlDC_Motor_Simscap[1] += 0.11860623188219484 *\r\n    rtDW.INPUT_1_1_1[0];\r\n}\r\n\r\n/* Model initialize function */\r\nvoid DCMotor_Control_initialize(void)\r\n{\r\n  /* Registration code */\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&rtM->solverInfo, &rtM->Timing.simTimeStep);\r\n    rtsiSetTPtr(&rtM->solverInfo, &rtmGetTPtr(rtM));\r\n    rtsiSetStepSizePtr(&rtM->solverInfo, &rtM->Timing.stepSize0);\r\n    rtsiSetdXPtr(&rtM->solverInfo, &rtM->derivs);\r\n    rtsiSetContStatesPtr(&rtM->solverInfo, (real_T **) &rtM->contStates);\r\n    rtsiSetNumContStatesPtr(&rtM->solverInfo, &rtM->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&rtM->solverInfo,\r\n      &rtM->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&rtM->solverInfo,\r\n      &rtM->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&rtM->solverInfo,\r\n      &rtM->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&rtM->solverInfo, (&rtmGetErrorStatus(rtM)));\r\n    rtsiSetRTModelPtr(&rtM->solverInfo, rtM);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&rtM->solverInfo, MAJOR_TIME_STEP);\r\n  rtM->intgData.y = rtM->odeY;\r\n  rtM->intgData.f[0] = rtM->odeF[0];\r\n  rtM->intgData.f[1] = rtM->odeF[1];\r\n  rtM->intgData.f[2] = rtM->odeF[2];\r\n  rtM->contStates = ((X *) &rtX);\r\n  rtsiSetSolverData(&rtM->solverInfo, (void *)&rtM->intgData);\r\n  rtsiSetSolverName(&rtM->solverInfo,\"ode3\");\r\n  rtmSetTPtr(rtM, &rtM->Timing.tArray[0]);\r\n  rtM->Timing.stepSize0 = 1.0E-5;\r\n\r\n  /* Model Initialize function for ModelReference Block: '<Root>/Controller' */\r\n  Controller_initialize(rtmGetErrorStatusPointer(rtM), &(rtM->solverInfo),\r\n                        &(rtDW.Controller_InstanceData.rtm),\r\n                        &(rtDW.Controller_InstanceData.rtdw));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<Root>/Controller1' */\r\n  Controller_initialize(rtmGetErrorStatusPointer(rtM), &(rtM->solverInfo),\r\n                        &(rtDW.Controller1_InstanceData.rtm),\r\n                        &(rtDW.Controller1_InstanceData.rtdw));\r\n\r\n  {\r\n    NeslSimulationData *tmp_1;\r\n    NeslSimulator *tmp;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    char *msg;\r\n    real_T tmp_2;\r\n    int32_T tmp_3;\r\n    boolean_T tmp_0;\r\n\r\n    /* Start for SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n    tmp = nesl_lease_simulator(\r\n      \"DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration_1\", 0, 0);\r\n    rtDW.STATE_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(rtDW.STATE_1_Simulator);\r\n    if (tmp_0) {\r\n      DCMotor_Control_4a109994_1_gateway();\r\n      tmp = nesl_lease_simulator(\r\n        \"DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration_1\", 0, 0);\r\n      rtDW.STATE_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    rtDW.STATE_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    rtDW.STATE_1_DiagMgr = (void *)diagnosticManager;\r\n    rtDW.modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    rtDW.modelParameters.mSolverTolerance = 0.001;\r\n    rtDW.modelParameters.mVariableStepSolver = false;\r\n    rtDW.modelParameters.mIsUsingODEN = false;\r\n    rtDW.modelParameters.mFixedStepSize = 1.0E-5;\r\n    rtDW.modelParameters.mStartTime = 0.0;\r\n    rtDW.modelParameters.mLoadInitialState = false;\r\n    rtDW.modelParameters.mUseSimState = false;\r\n    rtDW.modelParameters.mLinTrimCompile = false;\r\n    rtDW.modelParameters.mLoggingMode = SSC_LOGGING_NONE;\r\n    rtDW.modelParameters.mRTWModifiedTimeStamp = 5.78363684E+8;\r\n    rtDW.modelParameters.mZcDisabled = false;\r\n    tmp_2 = 0.001;\r\n    rtDW.modelParameters.mSolverTolerance = tmp_2;\r\n    tmp_2 = 1.0E-5;\r\n    rtDW.modelParameters.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    rtDW.modelParameters.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    rtDW.modelParameters.mIsUsingODEN = tmp_0;\r\n    rtDW.modelParameters.mLoadInitialState = false;\r\n    rtDW.modelParameters.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)rtDW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)rtDW.STATE_1_Simulator,\r\n      &rtDW.modelParameters, diagnosticManager);\r\n    if (tmp_3 != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(rtM));\r\n      if (tmp_0) {\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(rtM, msg);\r\n      }\r\n    }\r\n\r\n    rtDW.STATE_1_FirstOutput = true;\r\n\r\n    /* End of Start for SimscapeExecutionBlock: '<S14>/STATE_1' */\r\n\r\n    /* Start for FromWorkspace: '<S2>/FromWs' */\r\n    {\r\n      static real_T pTimeValues0[] = { 0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0,\r\n        4.0, 5.0, 5.0, 6.0, 6.0, 7.0, 7.0, 8.0, 8.0, 9.0, 9.0, 10.0, 10.0, 11.0,\r\n        11.0, 12.0, 12.0, 13.0, 13.0, 14.0, 14.0, 15.0, 15.0, 16.0, 16.0, 17.0,\r\n        17.0, 18.0, 18.0, 19.0, 19.0, 20.0, 20.0, 21.0, 21.0, 22.0, 22.0, 23.0,\r\n        23.0, 24.0, 24.0, 25.0, 25.0, 26.0, 26.0, 27.0, 27.0, 28.0, 28.0, 30.0 }\r\n      ;\r\n\r\n      static real_T pDataValues0[] = { 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0,\r\n        2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0, 5.0, 5.0, 5.0,\r\n        5.0, 6.0, 6.0, 6.0, 6.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 6.0, 6.0, 5.0,\r\n        5.0, 5.0, 5.0, 4.0, 4.0, 4.0, 4.0, 3.0, 3.0, 3.0, 3.0, 2.0, 2.0, 2.0,\r\n        2.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0 } ;\r\n\r\n      rtDW.FromWs_PWORK.TimePtr = (void *) pTimeValues0;\r\n      rtDW.FromWs_PWORK.DataPtr = (void *) pDataValues0;\r\n      rtDW.FromWs_IWORK.PrevIndex = 0;\r\n    }\r\n\r\n    /* SystemInitialize for ModelReference: '<Root>/Controller' */\r\n    Controller_Init(&(rtDW.Controller_InstanceData.rtdw));\r\n\r\n    /* SystemInitialize for ModelReference: '<Root>/Controller1' */\r\n    Controller_Init(&(rtDW.Controller1_InstanceData.rtdw));\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCMotor_Control.h","type":"header","group":"model","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: DCMotor_Control.h\r\n *\r\n * Code generated for Simulink model 'DCMotor_Control'.\r\n *\r\n * Model version                  : 2.21\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Jun 29 00:50:41 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_DCMotor_Control_h_\r\n#define RTW_HEADER_DCMotor_Control_h_\r\n#include <math.h>\r\n#include <string.h>\r\n#ifndef DCMotor_Control_COMMON_INCLUDES_\r\n#define DCMotor_Control_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"nesl_rtw.h\"\r\n#include \"DCMotor_Control_4a109994_1_gateway.h\"\r\n#endif                                 /* DCMotor_Control_COMMON_INCLUDES_ */\r\n\r\n/* Child system includes */\r\n#include \"Controller.h\"\r\n\r\n/* Model Code Variants */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusPointer\r\n#define rtmGetErrorStatusPointer(rtm)  ((const char_T **)(&((rtm)->errorStatus)))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n#define DCMotor_Control_M              (rtM)\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  Controller_MdlrefDW Controller_InstanceData;/* '<Root>/Controller' */\r\n  Controller_MdlrefDW Controller1_InstanceData;/* '<Root>/Controller1' */\r\n  NeModelParameters modelParameters;\r\n  real_T STATE_1[3];                   /* '<S14>/STATE_1' */\r\n  real_T INPUT_1_1_1[4];               /* '<S14>/INPUT_1_1_1' */\r\n  real_T INPUT_1_1_1_Discrete[2];      /* '<S14>/INPUT_1_1_1' */\r\n  real_T dv[4];\r\n  real_T OUTPUT_1_1[2];                /* '<S14>/OUTPUT_1_1' */\r\n  real_T dv1[4];\r\n  real_T Controller_k;                 /* '<Root>/Controller' */\r\n  real_T Controller1;                  /* '<Root>/Controller1' */\r\n  real_T STATE_1_Discrete;             /* '<S14>/STATE_1' */\r\n  real_T OUTPUT_1_1_Discrete;          /* '<S14>/OUTPUT_1_1' */\r\n  real_T OUTPUT_1_0_Discrete;          /* '<S14>/OUTPUT_1_0' */\r\n  real_T time;\r\n  int_T STATE_1_Modes;                 /* '<S14>/STATE_1' */\r\n  int_T OUTPUT_1_1_Modes;              /* '<S14>/OUTPUT_1_1' */\r\n  struct {\r\n    int_T PrevIndex;\r\n  } FromWs_IWORK;                      /* '<S2>/FromWs' */\r\n\r\n  int_T OUTPUT_1_0_Modes;              /* '<S14>/OUTPUT_1_0' */\r\n  struct {\r\n    void *TimePtr;\r\n    void *DataPtr;\r\n    void *RSimInfoPtr;\r\n  } FromWs_PWORK;                      /* '<S2>/FromWs' */\r\n\r\n  void* STATE_1_Simulator;             /* '<S14>/STATE_1' */\r\n  void* STATE_1_SimData;               /* '<S14>/STATE_1' */\r\n  void* STATE_1_DiagMgr;               /* '<S14>/STATE_1' */\r\n  void* STATE_1_ZcLogger;              /* '<S14>/STATE_1' */\r\n  void* STATE_1_TsIndex;               /* '<S14>/STATE_1' */\r\n  void* OUTPUT_1_1_Simulator;          /* '<S14>/OUTPUT_1_1' */\r\n  void* OUTPUT_1_1_SimData;            /* '<S14>/OUTPUT_1_1' */\r\n  void* OUTPUT_1_1_DiagMgr;            /* '<S14>/OUTPUT_1_1' */\r\n  void* OUTPUT_1_1_ZcLogger;           /* '<S14>/OUTPUT_1_1' */\r\n  void* OUTPUT_1_1_TsIndex;            /* '<S14>/OUTPUT_1_1' */\r\n  void* OUTPUT_1_0_Simulator;          /* '<S14>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_SimData;            /* '<S14>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_DiagMgr;            /* '<S14>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_ZcLogger;           /* '<S14>/OUTPUT_1_0' */\r\n  void* OUTPUT_1_0_TsIndex;            /* '<S14>/OUTPUT_1_0' */\r\n  boolean_T STATE_1_FirstOutput;       /* '<S14>/STATE_1' */\r\n  boolean_T OUTPUT_1_1_FirstOutput;    /* '<S14>/OUTPUT_1_1' */\r\n  boolean_T OUTPUT_1_0_FirstOutput;    /* '<S14>/OUTPUT_1_0' */\r\n} DW;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T DCMotor_ControlDC_Motor_Simscap[3];/* '<S14>/STATE_1' */\r\n} X;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T DCMotor_ControlDC_Motor_Simscap[3];/* '<S14>/STATE_1' */\r\n} XDot;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T DCMotor_ControlDC_Motor_Simscap[3];/* '<S14>/STATE_1' */\r\n} XDis;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T *errorStatus;\r\n  RTWSolverInfo solverInfo;\r\n  X *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[3];\r\n  real_T odeF[3][3];\r\n  ODE3_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Continuous states (default storage) */\r\nextern X rtX;\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* Model entry point functions */\r\nextern void DCMotor_Control_initialize(void);\r\nextern void DCMotor_Control_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Add' : Unused code path elimination\r\n * Block '<Root>/Scope1' : Unused code path elimination\r\n * Block '<Root>/Scope2' : Unused code path elimination\r\n * Block '<Root>/Scope6' : Unused code path elimination\r\n * Block '<Root>/Scope7' : Unused code path elimination\r\n * Block '<Root>/Scope8' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'DCMotor_Control'\r\n * '<S1>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor'\r\n * '<S2>'   : 'DCMotor_Control/Signal Builder'\r\n * '<S3>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter'\r\n * '<S4>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter1'\r\n * '<S5>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter2'\r\n * '<S6>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter3'\r\n * '<S7>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/Simulink-PS Converter'\r\n * '<S8>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'\r\n * '<S9>'   : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter/EVAL_KEY'\r\n * '<S10>'  : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter1/EVAL_KEY'\r\n * '<S11>'  : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter2/EVAL_KEY'\r\n * '<S12>'  : 'DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink Converter3/EVAL_KEY'\r\n * '<S13>'  : 'DCMotor_Control/DC_Motor_Simscape_Motor/Simulink-PS Converter/EVAL_KEY'\r\n * '<S14>'  : 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration/EVAL_KEY'\r\n */\r\n#endif                                 /* RTW_HEADER_DCMotor_Control_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_backsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      backward substitution: solving Ux=b for real\r\n *      double precision float operands.\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\r\n * Abstract: Backward substitution: Solving Ux=b \r\n *           U: real, double\r\n *           b: real, double\r\n *           U is an upper (or unit upper) triangular full matrix.\r\n *           The entries in the lower triangle are ignored.\r\n *           U is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                   const real_T    *pb,\r\n                                   real_T          *x,\r\n                                   int_T            N,\r\n                                   int_T            P,\r\n                                   boolean_T        unit_upper)\r\n{\r\n  int_T i,k;\r\n  for(k=P; k>0; k--) {\r\n    real_T *pUcol = pU;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N-1;\r\n      real_T s = 0.0;\r\n      real_T *pUrow = pUcol--;          /* access current row of U */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pUrow * *xj--;\r\n          pUrow -= N;\r\n        }\r\n      }\r\n\r\n      if (unit_upper) {\r\n        *xj = *pb-- - s;\r\n      } else {\r\n        *xj = (*pb-- - s) / *pUrow;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_backsubrr_dbl.c */\r\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_forwardsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      forward substitution: solving Lx=b\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\r\n * Abstract: Forward substitution: solving Lx=b \r\n *           L: Real, double\r\n *           b: Real, double\r\n *           L is a lower (or unit lower) triangular full matrix.\r\n *           The entries in the upper triangle are ignored.\r\n *           L is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                  const real_T  *pb,\r\n                                  real_T        *x,\r\n                                  int_T          N,\r\n                                  int_T          P,\r\n                                  const int32_T *piv,\r\n                                  boolean_T      unit_lower)\r\n{  \r\n  /* Real inputs: */\r\n  int_T i, k;\r\n  for(k=0; k<P; k++) {\r\n    real_T *pLcol = pL;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N;\r\n      real_T s = 0.0;\r\n      real_T *pLrow = pLcol++;          /* access current row of L */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pLrow * *xj;\r\n          pLrow += N;\r\n          xj++;\r\n        }\r\n      }\r\n\r\n      if (unit_lower) {\r\n        *xj = pb[piv[i]] - s;\r\n      } else {\r\n        *xj = (pb[piv[i]] - s) / *pLrow;\r\n      }\r\n    }\r\n    pb += N;\r\n  }\r\n}\r\n\r\n/* [EOF] rt_forwardsubrr_dbl.c */\r\n"},{"name":"rt_lu_real.c","type":"source","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_lu_real.c     \r\n *\r\n * Abstract:\r\n *      Real-Time Workshop support routine for lu_real\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_lu_real  =======================================================\r\n * Abstract: A is real.\r\n *\r\n */\r\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\r\n                const int_T n,     /* number or rows = number of columns */\r\n                int32_T     *piv)  /* pivote vector                      */\r\n{\r\n  int_T k;\r\n\r\n  /* initialize row-pivot indices: */\r\n  for (k = 0; k < n; k++) {\r\n    piv[k] = k;\r\n  }\r\n\r\n  /* Loop over each column: */\r\n  for (k = 0; k < n; k++) {\r\n    const int_T kn = k*n;\r\n    int_T p = k;\r\n\r\n    /* Scan the lower triangular part of this column only\r\n     * Record row of largest value\r\n     */\r\n    {\r\n      int_T i;\r\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\r\n      for (i = k+1; i < n; i++) {\r\n        real_T q = fabs(A[i+kn]);\r\n        if (q > Amax) {p = i; Amax = q;}\r\n      }\r\n    }\r\n\r\n    /* swap rows if required */\r\n    if (p != k) {\r\n      int_T j;\r\n      int32_T t1;\r\n      for (j = 0; j < n; j++) {\r\n        real_T t;\r\n        const int_T j_n = j*n;\r\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\r\n      }\r\n      /* swap pivot row indices */\r\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\r\n    }\r\n\r\n    /* column reduction */\r\n    {\r\n      real_T Adiag = A[k+kn];\r\n      int_T i,j;\r\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\r\n\r\n        /* divide lower triangular part of column by max */\r\n        Adiag = 1.0/Adiag;\r\n        for (i = k+1; i < n; i++) {\r\n          A[i+kn] *= Adiag;\r\n        }\r\n\r\n        /* subtract multiple of column from remaining columns */\r\n        for (j = k+1; j < n; j++) {\r\n          int_T j_n = j*n;\r\n          for (i = k+1; i < n; i++) {\r\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_lu_real.c */\r\n"},{"name":"rt_matrixlib.h","type":"header","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef rt_matrixlib_h\r\n#define rt_matrixlib_h\r\n\r\n/* Copyright 2007-2013 The MathWorks, Inc.\r\n *\r\n * File    : rt_matrixlib.h\r\n * Abstract:\r\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\r\n *\r\n */\r\n\r\n\r\n/*==========*\r\n * Includes *\r\n *==========*/\r\n\r\n#include \"rtwtypes.h\"\r\n#include <limits.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Matrix Multiplication Utility Functions */\r\nextern void rt_MatMultRR_Dbl(real_T         *y, \r\n                             const real_T   *A, \r\n                             const real_T   *B, \r\n                             const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Dbl(creal_T       *y,\r\n                             const real_T  *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCR_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const real_T  *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCC_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultRR_Sgl(real32_T       *y,\r\n                             const real32_T *A,\r\n                             const real32_T *B,\r\n                             const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\r\n                             const real32_T  *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const real32_T  *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\r\n                                   const real_T *A,\r\n                                   const real_T *B,\r\n                                   const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\r\n                                   const real_T  *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const real_T  *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n#endif\r\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\r\n                                   const real32_T *A,\r\n                                   const real32_T *B,\r\n                                   const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\r\n                                   const real32_T  *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const real32_T  *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n#endif \r\n\r\n/* Matrix Inversion Utility Functions */\r\nextern void rt_lu_real(real_T      *A,\r\n                       const int_T n,\r\n                       int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx(creal_T *A,\r\n                       const int_T n,\r\n                       int32_T *piv);\r\n#endif\r\n\r\nextern void rt_lu_real_sgl(real32_T      *A,\r\n                           const int_T n,\r\n                           int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx_sgl(creal32_T *A,\r\n                           const int_T n,\r\n                           int32_T *piv);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                          const real_T    *pb,\r\n                                          real_T          *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                         const real_T  *pb,\r\n                                         real_T        *x,\r\n                                         int_T          N,\r\n                                         int_T          P,\r\n                                         const int32_T *piv,\r\n                                         boolean_T      unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\r\n                                         const real_T    *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\r\n                                          const real32_T    *pb,\r\n                                          real32_T          *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\r\n                                         const real32_T    *pb,\r\n                                         real32_T    *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\r\n                                         const real32_T    *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\n\r\nextern void rt_MatDivRR_Dbl(real_T        *Out,\r\n                            const real_T  *In1,\r\n                            const real_T  *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            real_T        *x,\r\n                            const int_T    dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\r\n                            const real_T  *In1,\r\n                            const creal_T *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const real_T  *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const creal_T *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n#endif\r\n\r\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\r\n                            const real32_T  *In1,\r\n                            const real32_T  *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            real32_T        *x,\r\n                            const int_T      dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\r\n                            const real32_T  *In1,\r\n                            const creal32_T *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const real32_T  *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const creal32_T *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n#endif\r\n\r\n\r\n/* Matrix multiplication defines */\r\n\r\n/* Quick (approximate) complex absolute value: */\r\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\r\n\r\n/* Quick (approximate) complex absolute value for singles: */\r\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \r\n\r\n#ifdef CREAL_T\r\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\r\n                                const creal_T In1,\r\n                                const creal_T In2);\r\n\r\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\r\n                                  const creal_T In1,\r\n                                  const creal_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\r\n                                     const creal_T In1);\r\n\r\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\r\n                                const creal32_T In1,\r\n                                const creal32_T In2);\r\n\r\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\r\n                                  const creal32_T In1,\r\n                                  const creal32_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\r\n                                     const creal32_T In1);\r\n\r\n#endif\r\n\r\nextern real_T rt_Hypot_Dbl(real_T In1,\r\n                           real_T In2);\r\n\r\nextern real32_T rt_Hypot_Sgl(real32_T In1,\r\n                             real32_T In2);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* rt_matrixlib_h */\r\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\r\n *\r\n * File: rt_matrixlib_dbl.c\r\n *\r\n * Abstract:\r\n *      Simulink Coder utility functions\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n#ifdef CREAL_T\r\nvoid rt_ComplexTimes_Dbl(creal_T* c,\r\n                         const creal_T a,\r\n                         const creal_T b)\r\n{\r\n    if (a.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.re * b.im;\r\n        if (b.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (b.re == 0.0 || a.re == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else if (b.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0 || a.re == 0.0) { \r\n            c->re = 0.0;\r\n        }\r\n    } else if (a.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0) {\r\n            c->im = 0.0;\r\n        }\r\n    } else if (b.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.re * b.im;\r\n    } else {\r\n        c->re = a.re * b.re - a.im * b.im;\r\n        c->im = a.re * b.im + a.im * b.re;\r\n    }\r\n}\r\n\r\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\r\n                           const creal_T a,\r\n                           const creal_T b)\r\n{\r\n    if (b.im == 0.0) {\r\n        c->re = a.re / b.re;\r\n        if (a.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else { /* a.im != 0.0 */\r\n            c->im = a.im / b.re;\r\n            if (a.re == 0.0) {\r\n                c->re = 0.0;\r\n            }\r\n        }\r\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\r\n        c->re = a.im / b.im;\r\n        c->im = -a.re / b.im;\r\n        if (a.re == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (a.im == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else {\r\n        real_T brm = fabs(b.re);\r\n        real_T bim = fabs(b.im);\r\n        if (brm > bim) {\r\n            real_T s = b.im / b.re;\r\n            real_T d = b.re + s * b.im;\r\n            c->im = (a.im - s * a.re) / d;\r\n            c->re = (a.re + s * a.im) / d;\r\n        } else if (brm == bim) {\r\n            real_T half = 0.5;\r\n            real_T sgnbr = b.re > 0.0 ? half : -half;\r\n            real_T sgnbi = b.im > 0.0 ? half : -half;\r\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\r\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\r\n        } else {\r\n            real_T s = b.re / b.im;\r\n            real_T d = b.im + s * b.re;\r\n            c->im = (s * a.im - a.re) / d;\r\n            c->re = (s * a.re + a.im) / d;\r\n        }\r\n    }\r\n}\r\n\r\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\r\n                              const creal_T In1)\r\n{\r\n    creal_T y;\r\n    y.re = 1.0;\r\n    y.im = 0.0;\r\n\r\n    rt_ComplexRDivide_Dbl(Out, y, In1);\r\n}\r\n\r\n#endif\r\n\r\n\r\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\r\n{\r\n    real_T y;\r\n    if (a != a || b != b) {\r\n        y = a + b;\r\n    } else {\r\n        real_T t;\r\n        if (fabs(a) > fabs(b)) {\r\n            t = b/a;\r\n            y = fabs(a)*sqrt(1.0 + t*t);\r\n        } else {\r\n            if (b == 0.0) {\r\n                y = 0.0;\r\n            } else {\r\n                t = a/b;\r\n                y = fabs(b)*sqrt(1.0 + t*t);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return y;\r\n}\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'Controller'.\r\n *\r\n * Model version                  : 2.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Jun 29 00:34:01 2022\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Sponsored License - for use in support of a program or activity\r\n * sponsored by MathWorks.  Not for government, commercial or other\r\n * non-sponsored organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'DCMotor_Control'.\r\n *\r\n * Model version                  : 2.21\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Jun 29 00:50:41 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"DCMotor_Control.h\"\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DCMotor_Control_4a109994_1.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_std.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"ne_dae_fwd.h\"\r\n#include \"ne_profiler_fwd.h\"\r\n#include \"ne_dae_construct.h\"\r\n#include \"nesl_la.h\"\r\n#include \"DCMotor_Control_4a109994_1.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n\r\nvoid DCMotor_Control_4a109994_1_dae( NeDae **dae, const NeModelParameters\r\n  *modelParams,\r\n  const NeSolverParameters *solverParams)\r\n{\r\n  PmAllocator *ne_allocator;\r\n  const McLinearAlgebraFactory *linear_algebra_ptr =\r\n    (solverParams->mLinearAlgebra == NE_FULL_LA) ?\r\n    get_rtw_linear_algebra() :\r\n    ((solverParams->mLinearAlgebra == NE_SPARSE_LA) ?\r\n     mc_get_csparse_linear_algebra() :\r\n     get_auto_linear_algebra());\r\n  NeRtpValues *rtpValues = NULL;\r\n  ne_allocator = pm_default_allocator();\r\n  ne_dae_create( dae,\r\n                DCMotor_Control_4a109994_1_dae_ds( ne_allocator ),\r\n                NULL,\r\n                FALSE,\r\n                rtpValues,\r\n                *solverParams,\r\n                *modelParams,\r\n                linear_algebra_ptr,\r\n                NULL,\r\n                NULL,\r\n                NULL,\r\n                ne_allocator,\r\n                DAEMON_CHOICE_NONE);\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifndef __DCMotor_Control_4a109994_1_h__\r\n#define __DCMotor_Control_4a109994_1_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void DCMotor_Control_4a109994_1_dae( NeDae **dae, const\r\n    NeModelParameters *modelParams,\r\n    const NeSolverParameters *solverParams);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                             /* ifndef __DCMotor_Control_4a109994_1_h__ */\r\n"},{"name":"DCMotor_Control_4a109994_1_ds.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds.c - body for module DCMotor_Control_4a109994_1_ds */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_il.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_all.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_act.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_exp.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_log.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"ssc_ml_fun.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n\r\nstatic int32_T ds_m_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_m(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dum_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dum(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_b_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_b(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_c_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_c(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_f(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vpf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vsf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf0(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_duf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_tduf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tdxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_v_x(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cer(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ic(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_icr(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_im(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_id(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_il(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_y(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_duy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dty_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dty(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_mode(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_zc(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_r(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_i(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_sfo(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_sfp(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_init_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_init_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_assert(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_passert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_iassert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_t(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v0(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_tmax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_l(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_j(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qx(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qu(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qt(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_q1(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qx_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qu_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_q1_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_var_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_eq_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_slv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_nldv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_sclv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imin(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imax(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dimin(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dimax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic void release_reference(NeDynamicSystem *ds);\r\nstatic void get_reference(NeDynamicSystem *ds);\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T);\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp);\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr);\r\nstatic NeEquationData s_equation_data[3] = { { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\",\r\n    2U, 0U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 2U, 2U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 2U,\r\n    4U, TRUE, 1.0, \"1\", } };\r\n\r\nstatic NeCERData *s_cer_data = NULL;\r\nstatic NeICRData *s_icr_data = NULL;\r\nstatic NeVariableData s_variable_data[3] = { {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.i_L\", 0U, 0,\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1.0, \"1\", 0.0, TRUE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Current\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.w\", 0U, 0,\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1.0, \"1\", 0.0, TRUE,\r\n    FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Angular velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.phi\", 0U, 0,\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\",\r\n    1.0, \"1\", 0.0, TRUE, FALSE, 1U, 1U, NE_INIT_MODE_MANDATORY, \"Angle\", } };\r\n\r\nstatic NeVariableData *s_discrete_data = NULL;\r\nstatic NeObservableData s_observable_data[47] = { {\r\n    \"DC_Motor_Simscape_Motor.Controlled_Voltage_Source.i\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Controlled Voltage Source\", 1U, 1U,\r\n    \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"DC_Motor_Simscape_Motor.Controlled_Voltage_Source.n.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Controlled Voltage Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Controlled_Voltage_Source.p.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Controlled Voltage Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Controlled_Voltage_Source.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Controlled Voltage Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"DC_Motor_Simscape_Motor.Controlled_Voltage_Source.vT\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Controlled Voltage Source\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"DC_Motor_Simscape_Motor.Current_Sensor.I\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Current Sensor\", 1U, 1U, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"I\", }, {\r\n    \"DC_Motor_Simscape_Motor.Current_Sensor.i1\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Current Sensor\", 1U, 1U, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_Motor_Simscape_Motor.Current_Sensor.n.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Current Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Current_Sensor.p.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Current Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Current_Sensor_I\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink\\nConverter2\", 1U, 1U,\r\n    \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current_Sensor_I\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.C.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"rad/s\", 1.0,\r\n    \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.R.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"rad/s\", 1.0,\r\n    \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.armature_winding_fault_factor\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Armature winding fault resistance correction factor ( closed = 1, open = 1/(G_faulted_armature*x_Ra) )\",\r\n  }, { \"DC_Motor_Simscape_Motor.DC_Motor.field_winding_fault_factor\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Field winding fault resistance correction factor ( closed = 1, open = 1/(G_faulted_field*Rf) )\",\r\n  }, { \"DC_Motor_Simscape_Motor.DC_Motor.fn.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.fp.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.ground_not_used.V.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.i\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Armature current\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.i_L\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.n.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.p.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.power_dissipated\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.t\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"N*m\", 1.0,\r\n    \"N*m\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Torque\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.v_f\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Field voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.DC_Motor.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U, \"rpm\", 1.0,\r\n    \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_MANDATORY, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Angular velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Electrical_Reference.V.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Electrical Reference\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Electrical_Reference1.V.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Electrical Reference1\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Electrical_Reference2.V.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Electrical Reference2\", 1U, 1U, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Gear_Box.O.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Gear Box\", 1U, 1U, \"rad/s\", 1.0,\r\n    \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Gear_Box.S.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Gear Box\", 1U, 1U, \"rad/s\", 1.0,\r\n    \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Gear_Box.t_in\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Gear Box\", 1U, 1U, \"N*m\", 1.0,\r\n    \"N*m\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Input shaft incoming torque\", }, {\r\n    \"DC_Motor_Simscape_Motor.Gear_Box.t_out\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Gear Box\", 1U, 1U, \"N*m\", 1.0,\r\n    \"N*m\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Output shaft incoming torque\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.A\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 1U,\r\n    1U, \"rad\", 1.0, \"1\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"A\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.C.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 1U,\r\n    1U, \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.R.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 1U,\r\n    1U, \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.W\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 1U,\r\n    1U, \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"W\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor.phi\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Ideal Rotational Motion Sensor\", 1U,\r\n    1U, \"deg\", 1.0, \"1\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_MANDATORY,\r\n    FALSE, TRUE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Angle\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_A\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink\\nConverter1\", 1U, 1U,\r\n    \"rad\", 1.0, \"1\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Ideal_Rotational_Motion_Sensor_A\", }, {\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_W\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink\\nConverter\", 1U, 1U,\r\n    \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Ideal_Rotational_Motion_Sensor_W\", }, {\r\n    \"DC_Motor_Simscape_Motor.Mechanical_Rotational_Reference.W.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Mechanical Rotational Reference\",\r\n    1U, 1U, \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE,\r\n    TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Mechanical_Rotational_Reference1.W.w\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Mechanical Rotational Reference1\",\r\n    1U, 1U, \"rad/s\", 1.0, \"1/s\", NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE,\r\n    TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Rotational velocity\", }, {\r\n    \"DC_Motor_Simscape_Motor.Simulink_PS_Converter_output\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Simulink-PS\\nConverter\", 1U, 1U,\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter_output\", }, {\r\n    \"DC_Motor_Simscape_Motor.Voltage_Sensor.V\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Voltage Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, {\r\n    \"DC_Motor_Simscape_Motor.Voltage_Sensor.n.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Voltage Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Voltage_Sensor.p.v\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Voltage Sensor\", 1U, 1U, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"DC_Motor_Simscape_Motor.Voltage_Sensor_V\",\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/PS-Simulink\\nConverter3\", 1U, 1U,\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor_V\", } };\r\n\r\nstatic NeModeData *s_major_mode_data = NULL;\r\nstatic NeZCData *s_zc_data = NULL;\r\nstatic NeRange *s_range = NULL;\r\nstatic NeAssertData s_assert_data[2] = { {\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 0U,\r\n    \"DC_Motor_Simscape_Motor.DC_Motor\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/DC Motor\", 1U, 1U,\r\n    \"DC_Motor_Simscape_Motor.DC_Motor\",\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", } };\r\n\r\nstatic NeRange s_assert_range[2] = { {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, } };\r\n\r\nstatic NeAssertData *s_param_assert_data = NULL;\r\nstatic NeRange *s_param_assert_range = NULL;\r\nstatic NeAssertData *s_initial_assert_data = NULL;\r\nstatic NeRange *s_initial_assert_range = NULL;\r\nstatic NeRange s_equation_range[6] = { {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/elec/library/m/+ee/+electromech/+brushed/dc_motor.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+mechanical/+sensors/angular_velocity.ssc\",\r\n    46U, 5U, 46U, 12U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2021b/toolbox/physmod/simscape/library/m/+foundation/+mechanical/+sensors/angular_velocity.ssc\",\r\n    46U, 9U, 46U, 17U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeRange *s_cer_range = NULL;\r\nstatic NeRange *s_icr_range = NULL;\r\nstatic NeParameterData *s_logical_parameter_data = NULL;\r\nstatic NeParameterData *s_integer_parameter_data = NULL;\r\nstatic NeParameterData *s_index_parameter_data = NULL;\r\nstatic NeParameterData *s_real_parameter_data = NULL;\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM_P.mNumCol = 3;\r\n  out->mM_P.mNumRow = 3;\r\n  out->mM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM.mN = 3;\r\n  out->mM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMM.mN = 3;\r\n  out->mVMM.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM_P.mNumCol = 3;\r\n  out->mDXM_P.mNumRow = 3;\r\n  out->mDXM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mDXM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM.mN = 0;\r\n  out->mDXM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM_P.mNumCol = 0;\r\n  out->mDDM_P.mNumRow = 3;\r\n  out->mDDM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDDM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM.mN = 0;\r\n  out->mDDM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM_P.mNumCol = 1;\r\n  out->mDUM_P.mNumRow = 3;\r\n  out->mDUM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDUM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM.mN = 0;\r\n  out->mDUM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM_P.mNumCol = 1;\r\n  out->mDTM_P.mNumRow = 3;\r\n  out->mDTM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM.mN = 0;\r\n  out->mDTM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM_P.mNumCol = 0;\r\n  out->mDPM_P.mNumRow = 3;\r\n  out->mDPM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDPM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM.mN = 0;\r\n  out->mDPM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA_P.mNumCol = 3;\r\n  out->mA_P.mNumRow = 3;\r\n  out->mA_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mA_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA.mN = 5;\r\n  out->mA.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB_P.mNumCol = 1;\r\n  out->mB_P.mNumRow = 3;\r\n  out->mB_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mB_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB.mN = 2;\r\n  out->mB.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC_P.mNumCol = 1;\r\n  out->mC_P.mNumRow = 3;\r\n  out->mC_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mC_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC.mN = 0;\r\n  out->mC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mF.mN = 3;\r\n  out->mF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMF.mN = 3;\r\n  out->mVMF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVPF.mN = 3;\r\n  out->mVPF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVSF.mN = 3;\r\n  out->mVSF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF.mN = 3;\r\n  out->mSLF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF0.mN = 3;\r\n  out->mSLF0.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF_P.mNumCol = 3;\r\n  out->mDXF_P.mNumRow = 3;\r\n  out->mDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF.mN = 0;\r\n  out->mDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF_P.mNumCol = 1;\r\n  out->mDUF_P.mNumRow = 3;\r\n  out->mDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF.mN = 0;\r\n  out->mDUF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF_P.mNumCol = 1;\r\n  out->mDTF_P.mNumRow = 3;\r\n  out->mDTF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF.mN = 0;\r\n  out->mDTF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF_P.mNumCol = 0;\r\n  out->mDDF_P.mNumRow = 3;\r\n  out->mDDF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDDF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF.mN = 0;\r\n  out->mDDF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF_P.mNumCol = 0;\r\n  out->mDPDXF_P.mNumRow = 0;\r\n  out->mDPDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDPDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF.mN = 0;\r\n  out->mDPDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF_P.mNumCol = 0;\r\n  out->mDWF_P.mNumRow = 3;\r\n  out->mDWF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDWF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF.mN = 0;\r\n  out->mDWF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUF_P.mNumCol = 1;\r\n  out->mTDUF_P.mNumRow = 3;\r\n  out->mTDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mTDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXF_P.mNumCol = 3;\r\n  out->mTDXF_P.mNumRow = 3;\r\n  out->mTDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mTDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_P.mNumCol = 1;\r\n  out->mDNF_P.mNumRow = 3;\r\n  out->mDNF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDNF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF.mN = 0;\r\n  out->mDNF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_V_X.mN = 3;\r\n  out->mDNF_V_X.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCER.mN = 0;\r\n  out->mCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER.mN = 0;\r\n  out->mDXCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER_P.mNumCol = 3;\r\n  out->mDXCER_P.mNumRow = 0;\r\n  out->mDXCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 4);\r\n  out->mDXCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIC.mN = 3;\r\n  out->mIC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR.mN = 0;\r\n  out->mICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IM.mN = 0;\r\n  out->mICR_IM.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_ID.mN = 0;\r\n  out->mICR_ID.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IL.mN = 0;\r\n  out->mICR_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR.mN = 0;\r\n  out->mDXICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR_P.mNumCol = 3;\r\n  out->mDXICR_P.mNumRow = 0;\r\n  out->mDXICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 4);\r\n  out->mDXICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR.mN = 0;\r\n  out->mDDICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR_P.mNumCol = 0;\r\n  out->mDDICR_P.mNumRow = 0;\r\n  out->mDDICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDDICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUICR_P.mNumCol = 1;\r\n  out->mTDUICR_P.mNumRow = 0;\r\n  out->mTDUICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mTDUICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM_P.mNumCol = 3;\r\n  out->mICRM_P.mNumRow = 0;\r\n  out->mICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM.mN = 0;\r\n  out->mICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM_P.mNumCol = 3;\r\n  out->mDXICRM_P.mNumRow = 0;\r\n  out->mDXICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 4);\r\n  out->mDXICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM.mN = 0;\r\n  out->mDXICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM_P.mNumCol = 0;\r\n  out->mDDICRM_P.mNumRow = 0;\r\n  out->mDDICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDDICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM.mN = 0;\r\n  out->mDDICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDUY_P.mNumCol = 1;\r\n  out->mMDUY_P.mNumRow = 4;\r\n  out->mMDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mMDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDXY_P.mNumCol = 3;\r\n  out->mMDXY_P.mNumRow = 4;\r\n  out->mMDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mMDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUY_P.mNumCol = 1;\r\n  out->mTDUY_P.mNumRow = 4;\r\n  out->mTDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mTDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXY_P.mNumCol = 3;\r\n  out->mTDXY_P.mNumRow = 4;\r\n  out->mTDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mTDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mY.mN = 4;\r\n  out->mY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY_P.mNumCol = 3;\r\n  out->mDXY_P.mNumRow = 4;\r\n  out->mDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY.mN = 4;\r\n  out->mDXY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY_P.mNumCol = 1;\r\n  out->mDUY_P.mNumRow = 4;\r\n  out->mDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY.mN = 2;\r\n  out->mDUY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY_P.mNumCol = 1;\r\n  out->mDTY_P.mNumRow = 4;\r\n  out->mDTY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY.mN = 0;\r\n  out->mDTY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMODE.mN = 0;\r\n  out->mMODE.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mZC.mN = 0;\r\n  out->mZC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_R.mN = 0;\r\n  out->mCACHE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_I.mN = 0;\r\n  out->mCACHE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_R.mN = 0;\r\n  out->mUPDATE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_I.mN = 0;\r\n  out->mUPDATE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_R.mN = 0;\r\n  out->mUPDATE2_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_I.mN = 0;\r\n  out->mUPDATE2_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_R.mN = 0;\r\n  out->mLOCK_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_I.mN = 0;\r\n  out->mLOCK_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_R.mN = 0;\r\n  out->mLOCK2_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_I.mN = 0;\r\n  out->mLOCK2_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFO.mN = 0;\r\n  out->mSFO.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFP.mN = 0;\r\n  out->mSFP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_R.mN = 0;\r\n  out->mINIT_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_I.mN = 0;\r\n  out->mINIT_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOG.mN = 28;\r\n  out->mLOG.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 28);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mASSERT.mN = 2;\r\n  out->mASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mPASSERT.mN = 0;\r\n  out->mPASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIASSERT.mN = 0;\r\n  out->mIASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_T.mN = 0;\r\n  out->mDEL_T.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V.mN = 0;\r\n  out->mDEL_V.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V0.mN = 0;\r\n  out->mDEL_V0.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_TMAX.mN = 0;\r\n  out->mDEL_TMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT_P.mNumCol = 3;\r\n  out->mDXDELT_P.mNumRow = 0;\r\n  out->mDXDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 4);\r\n  out->mDXDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT.mN = 0;\r\n  out->mDXDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT_P.mNumCol = 1;\r\n  out->mDUDELT_P.mNumRow = 0;\r\n  out->mDUDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDUDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT.mN = 0;\r\n  out->mDUDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT_P.mNumCol = 1;\r\n  out->mDTDELT_P.mNumRow = 0;\r\n  out->mDTDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDTDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT.mN = 0;\r\n  out->mDTDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_EXP.mN = 47;\r\n  out->mOBS_EXP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    47);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ACT.mN = 47;\r\n  out->mOBS_ACT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    47);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ALL.mN = 47;\r\n  out->mOBS_ALL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    47);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_IL.mN = 47;\r\n  out->mOBS_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 47);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_L.mN = 0;\r\n  out->mDP_L.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_I.mN = 0;\r\n  out->mDP_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_J.mN = 0;\r\n  out->mDP_J.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_R.mN = 0;\r\n  out->mDP_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX.mN = 0;\r\n  out->mQX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU.mN = 0;\r\n  out->mQU.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT.mN = 0;\r\n  out->mQT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1.mN = 0;\r\n  out->mQ1.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX_P.mNumCol = 3;\r\n  out->mQX_P.mNumRow = 3;\r\n  out->mQX_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  out->mQX_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU_P.mNumCol = 1;\r\n  out->mQU_P.mNumRow = 3;\r\n  out->mQU_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQU_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT_P.mNumCol = 1;\r\n  out->mQT_P.mNumRow = 3;\r\n  out->mQT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1_P.mNumCol = 1;\r\n  out->mQ1_P.mNumRow = 3;\r\n  out->mQ1_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQ1_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVAR_TOL.mN = 3;\r\n  out->mVAR_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mEQ_TOL.mN = 3;\r\n  out->mEQ_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLV.mN = 3;\r\n  out->mLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLV.mN = 3;\r\n  out->mSLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mNLDV.mN = 3;\r\n  out->mNLDV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSCLV.mN = 3;\r\n  out->mSCLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMIN.mN = 3;\r\n  out->mIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMAX.mN = 3;\r\n  out->mIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMIN.mN = 0;\r\n  out->mDIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMAX.mN = 0;\r\n  out->mDIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic void release_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  if (--_ds->mRefCnt == 0) {\r\n    _ds->mAlloc.mFreeFcn(&_ds->mAlloc, _ds);\r\n  }\r\n}\r\n\r\nstatic void get_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  ++_ds->mRefCnt;\r\n}\r\n\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T kp)\r\n{\r\n  _NeDynamicSystem *_ds = (_NeDynamicSystem *)ds;\r\n  (void) kp;\r\n  ne_ds_get_reference(&_ds->mBase);\r\n  return &_ds->mBase;\r\n}\r\n\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp)\r\n{\r\n  (void)ds;\r\n  (void)kp;\r\n  memcpy(out->mX, in->mX.mX, sizeof(real_T)*out->mN);\r\n}\r\n\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr)\r\n{\r\n  (void)ds;\r\n  memcpy(outl->mX, inl->mX, sizeof(int32_T)*inl->mN);\r\n  memcpy(outi->mX, ini->mX, sizeof(int32_T)*ini->mN);\r\n  memcpy(outj->mX, inj->mX, sizeof(int32_T)*inj->mN);\r\n  memcpy(outr->mX, inr->mX, sizeof(real_T)*inr->mN);\r\n}\r\n\r\nNeDynamicSystem *DCMotor_Control_4a109994_1_dae_ds(PmAllocator *allocator)\r\n{\r\n  NeDynamicSystem *ds;\r\n  _NeDynamicSystem *_ds;\r\n  static NeDsIoInfo input_info[1];\r\n  static NeDsIoInfo output_info[4];\r\n\r\n  /* allocate dynamic system data and extended data */\r\n  _ds = (_NeDynamicSystem *)allocator->mCallocFcn( allocator, sizeof\r\n    (_NeDynamicSystem), 1);\r\n  _ds->mAlloc = *allocator;\r\n  _ds->mRefCnt = 1;\r\n  ds = &_ds->mBase;\r\n\r\n  /* setup sizes */\r\n  ds->mNumVariables = 3;\r\n  ds->mNumDiscreteRealVariables = 0;\r\n  ds->mNumDifferentialVariables = 3;\r\n  ds->mNumEquations = 3;\r\n  ds->mNumCEResiduals = 0;\r\n  ds->mNumICResiduals = 0;\r\n  ds->mNumModes = 0;\r\n  ds->mNumMajorModes = 0;\r\n  ds->mNumRealCache = 0;\r\n  ds->mNumIntCache = 0;\r\n  ds->mNumObservables = 47;\r\n  ds->mNumObservableElements = 47;\r\n  ds->mNumZcs = 0;\r\n  ds->mNumAsserts = 2;\r\n  ds->mNumAssertRanges = 2;\r\n  ds->mNumParamAsserts = 0;\r\n  ds->mNumParamAssertRanges = 0;\r\n  ds->mNumInitialAsserts = 0;\r\n  ds->mNumInitialAssertRanges = 0;\r\n  ds->mNumRanges = 0;\r\n  ds->mNumEquationRanges = 6;\r\n  ds->mNumCERRanges = 0;\r\n  ds->mNumICRRanges = 0;\r\n  ds->mNumFundamentalSamples = 0;\r\n  ds->mNumDelays = 0;\r\n  ds->mNumLogicalParameters = 0;\r\n  ds->mNumIntegerParameters = 0;\r\n  ds->mNumIndexParameters = 0;\r\n  ds->mNumRealParameters = 0;\r\n  ds->mNumLogicalDerivedParameters = 0;\r\n  ds->mNumIntegerDerivedParameters = 0;\r\n  ds->mNumIndexDerivedParameters = 0;\r\n  ds->mNumRealDerivedParameters = 0;\r\n  ds->mIsOutputLinear = TRUE;\r\n  ds->mIsOutputSwitchedLinear = TRUE;\r\n  ds->mIsScalable = FALSE;\r\n\r\n  /* setup ios */\r\n  ds->mNumIo[NE_INPUT_IO_TYPE] = 1;\r\n  input_info[0].mIdentifier =\r\n    \"DC_Motor_Simscape_Motor.Simulink_PS_Converter_output\";\r\n  input_info[0].mM = 1;\r\n  input_info[0].mN = 1;\r\n  input_info[0].mName = \"DC_Motor_Simscape_Motor.Simulink_PS_Converter_output\";\r\n  input_info[0].mUnit = \"1\";\r\n  ds->mIo[NE_INPUT_IO_TYPE] = input_info;\r\n  ds->mNumIo[NE_OUTPUT_IO_TYPE] = 4;\r\n  output_info[0].mIdentifier = \"DC_Motor_Simscape_Motor.Current_Sensor_I\";\r\n  output_info[0].mM = 1;\r\n  output_info[0].mN = 1;\r\n  output_info[0].mName = \"DC_Motor_Simscape_Motor.Current_Sensor_I\";\r\n  output_info[0].mUnit = \"A\";\r\n  output_info[1].mIdentifier =\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_A\";\r\n  output_info[1].mM = 1;\r\n  output_info[1].mN = 1;\r\n  output_info[1].mName =\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_A\";\r\n  output_info[1].mUnit = \"rad\";\r\n  output_info[2].mIdentifier =\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_W\";\r\n  output_info[2].mM = 1;\r\n  output_info[2].mN = 1;\r\n  output_info[2].mName =\r\n    \"DC_Motor_Simscape_Motor.Ideal_Rotational_Motion_Sensor_W\";\r\n  output_info[2].mUnit = \"rad/s\";\r\n  output_info[3].mIdentifier = \"DC_Motor_Simscape_Motor.Voltage_Sensor_V\";\r\n  output_info[3].mM = 1;\r\n  output_info[3].mN = 1;\r\n  output_info[3].mName = \"DC_Motor_Simscape_Motor.Voltage_Sensor_V\";\r\n  output_info[3].mUnit = \"V\";\r\n  ds->mIo[NE_OUTPUT_IO_TYPE] = output_info;\r\n\r\n  /* setup administration methods */\r\n  ds->mReleaseReference = release_reference;\r\n  ds->mGetReference = get_reference;\r\n  ds->mDiagnosticsDsFcn = diagnostics;\r\n  ds->mExpandFcn = expand;\r\n  ds->mRtpMapFcn = rtpmap;\r\n  ds->mMethods[NE_DS_METHOD_M_P] = ds_m_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_M_P] = ds_output_m_p;\r\n  ds->mMethods[NE_DS_METHOD_M] = ds_m;\r\n  ds->mMakeOutput[NE_DS_METHOD_M] = ds_output_m;\r\n  ds->mMethods[NE_DS_METHOD_VMM] = ds_vmm;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMM] = ds_output_vmm;\r\n  ds->mMethods[NE_DS_METHOD_DXM_P] = ds_dxm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM_P] = ds_output_dxm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXM] = ds_dxm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM] = ds_output_dxm;\r\n  ds->mMethods[NE_DS_METHOD_DDM_P] = ds_ddm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM_P] = ds_output_ddm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDM] = ds_ddm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM] = ds_output_ddm;\r\n  ds->mMethods[NE_DS_METHOD_DUM_P] = ds_dum_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM_P] = ds_output_dum_p;\r\n  ds->mMethods[NE_DS_METHOD_DUM] = ds_dum;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM] = ds_output_dum;\r\n  ds->mMethods[NE_DS_METHOD_DTM_P] = ds_dtm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM_P] = ds_output_dtm_p;\r\n  ds->mMethods[NE_DS_METHOD_DTM] = ds_dtm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM] = ds_output_dtm;\r\n  ds->mMethods[NE_DS_METHOD_DPM_P] = ds_dpm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM_P] = ds_output_dpm_p;\r\n  ds->mMethods[NE_DS_METHOD_DPM] = ds_dpm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM] = ds_output_dpm;\r\n  ds->mMethods[NE_DS_METHOD_A_P] = ds_a_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_A_P] = ds_output_a_p;\r\n  ds->mMethods[NE_DS_METHOD_A] = ds_a;\r\n  ds->mMakeOutput[NE_DS_METHOD_A] = ds_output_a;\r\n  ds->mMethods[NE_DS_METHOD_B_P] = ds_b_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_B_P] = ds_output_b_p;\r\n  ds->mMethods[NE_DS_METHOD_B] = ds_b;\r\n  ds->mMakeOutput[NE_DS_METHOD_B] = ds_output_b;\r\n  ds->mMethods[NE_DS_METHOD_C_P] = ds_c_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_C_P] = ds_output_c_p;\r\n  ds->mMethods[NE_DS_METHOD_C] = ds_c;\r\n  ds->mMakeOutput[NE_DS_METHOD_C] = ds_output_c;\r\n  ds->mMethods[NE_DS_METHOD_F] = ds_f;\r\n  ds->mMakeOutput[NE_DS_METHOD_F] = ds_output_f;\r\n  ds->mMethods[NE_DS_METHOD_VMF] = ds_vmf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMF] = ds_output_vmf;\r\n  ds->mMethods[NE_DS_METHOD_VPF] = ds_vpf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VPF] = ds_output_vpf;\r\n  ds->mMethods[NE_DS_METHOD_VSF] = ds_vsf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VSF] = ds_output_vsf;\r\n  ds->mMethods[NE_DS_METHOD_SLF] = ds_slf;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF] = ds_output_slf;\r\n  ds->mMethods[NE_DS_METHOD_SLF0] = ds_slf0;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF0] = ds_output_slf0;\r\n  ds->mMethods[NE_DS_METHOD_DXF_P] = ds_dxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF_P] = ds_output_dxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DXF] = ds_dxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF] = ds_output_dxf;\r\n  ds->mMethods[NE_DS_METHOD_DUF_P] = ds_duf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF_P] = ds_output_duf_p;\r\n  ds->mMethods[NE_DS_METHOD_DUF] = ds_duf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF] = ds_output_duf;\r\n  ds->mMethods[NE_DS_METHOD_DTF_P] = ds_dtf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF_P] = ds_output_dtf_p;\r\n  ds->mMethods[NE_DS_METHOD_DTF] = ds_dtf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF] = ds_output_dtf;\r\n  ds->mMethods[NE_DS_METHOD_DDF_P] = ds_ddf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF_P] = ds_output_ddf_p;\r\n  ds->mMethods[NE_DS_METHOD_DDF] = ds_ddf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF] = ds_output_ddf;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF_P] = ds_dpdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF_P] = ds_output_dpdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF] = ds_dpdxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF] = ds_output_dpdxf;\r\n  ds->mMethods[NE_DS_METHOD_DWF_P] = ds_dwf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF_P] = ds_output_dwf_p;\r\n  ds->mMethods[NE_DS_METHOD_DWF] = ds_dwf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF] = ds_output_dwf;\r\n  ds->mMethods[NE_DS_METHOD_TDUF_P] = ds_tduf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUF_P] = ds_output_tduf_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXF_P] = ds_tdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXF_P] = ds_output_tdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF_P] = ds_dnf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_P] = ds_output_dnf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF] = ds_dnf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF] = ds_output_dnf;\r\n  ds->mMethods[NE_DS_METHOD_DNF_V_X] = ds_dnf_v_x;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_V_X] = ds_output_dnf_v_x;\r\n  ds->mMethods[NE_DS_METHOD_CER] = ds_cer;\r\n  ds->mMakeOutput[NE_DS_METHOD_CER] = ds_output_cer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER] = ds_dxcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER] = ds_output_dxcer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER_P] = ds_dxcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER_P] = ds_output_dxcer_p;\r\n  ds->mMethods[NE_DS_METHOD_IC] = ds_ic;\r\n  ds->mMakeOutput[NE_DS_METHOD_IC] = ds_output_ic;\r\n  ds->mMethods[NE_DS_METHOD_ICR] = ds_icr;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR] = ds_output_icr;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IM] = ds_icr_im;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IM] = ds_output_icr_im;\r\n  ds->mMethods[NE_DS_METHOD_ICR_ID] = ds_icr_id;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_ID] = ds_output_icr_id;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IL] = ds_icr_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IL] = ds_output_icr_il;\r\n  ds->mMethods[NE_DS_METHOD_DXICR] = ds_dxicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR] = ds_output_dxicr;\r\n  ds->mMethods[NE_DS_METHOD_DXICR_P] = ds_dxicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR_P] = ds_output_dxicr_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICR] = ds_ddicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR] = ds_output_ddicr;\r\n  ds->mMethods[NE_DS_METHOD_DDICR_P] = ds_ddicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR_P] = ds_output_ddicr_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUICR_P] = ds_tduicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUICR_P] = ds_output_tduicr_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM_P] = ds_icrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM_P] = ds_output_icrm_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM] = ds_icrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM] = ds_output_icrm;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM_P] = ds_dxicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM_P] = ds_output_dxicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM] = ds_dxicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM] = ds_output_dxicrm;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM_P] = ds_ddicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM_P] = ds_output_ddicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM] = ds_ddicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM] = ds_output_ddicrm;\r\n  ds->mMethods[NE_DS_METHOD_MDUY_P] = ds_mduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDUY_P] = ds_output_mduy_p;\r\n  ds->mMethods[NE_DS_METHOD_MDXY_P] = ds_mdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDXY_P] = ds_output_mdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUY_P] = ds_tduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUY_P] = ds_output_tduy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXY_P] = ds_tdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXY_P] = ds_output_tdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_Y] = ds_y;\r\n  ds->mMakeOutput[NE_DS_METHOD_Y] = ds_output_y;\r\n  ds->mMethods[NE_DS_METHOD_DXY_P] = ds_dxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY_P] = ds_output_dxy_p;\r\n  ds->mMethods[NE_DS_METHOD_DXY] = ds_dxy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY] = ds_output_dxy;\r\n  ds->mMethods[NE_DS_METHOD_DUY_P] = ds_duy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY_P] = ds_output_duy_p;\r\n  ds->mMethods[NE_DS_METHOD_DUY] = ds_duy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY] = ds_output_duy;\r\n  ds->mMethods[NE_DS_METHOD_DTY_P] = ds_dty_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY_P] = ds_output_dty_p;\r\n  ds->mMethods[NE_DS_METHOD_DTY] = ds_dty;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY] = ds_output_dty;\r\n  ds->mMethods[NE_DS_METHOD_MODE] = ds_mode;\r\n  ds->mMakeOutput[NE_DS_METHOD_MODE] = ds_output_mode;\r\n  ds->mMethods[NE_DS_METHOD_ZC] = ds_zc;\r\n  ds->mMakeOutput[NE_DS_METHOD_ZC] = ds_output_zc;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_R] = ds_cache_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_R] = ds_output_cache_r;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_I] = ds_cache_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_I] = ds_output_cache_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_R] = ds_update_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_R] = ds_output_update_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_I] = ds_update_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_I] = ds_output_update_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_R] = ds_update2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_R] = ds_output_update2_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_I] = ds_update2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_I] = ds_output_update2_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_R] = ds_lock_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_R] = ds_output_lock_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_I] = ds_lock_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_I] = ds_output_lock_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_R] = ds_lock2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_R] = ds_output_lock2_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_I] = ds_lock2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_I] = ds_output_lock2_i;\r\n  ds->mMethods[NE_DS_METHOD_SFO] = ds_sfo;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFO] = ds_output_sfo;\r\n  ds->mMethods[NE_DS_METHOD_SFP] = ds_sfp;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFP] = ds_output_sfp;\r\n  ds->mMethods[NE_DS_METHOD_INIT_R] = ds_init_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_R] = ds_output_init_r;\r\n  ds->mMethods[NE_DS_METHOD_INIT_I] = ds_init_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_I] = ds_output_init_i;\r\n  ds->mMethods[NE_DS_METHOD_LOG] = DCMotor_Control_4a109994_1_ds_log;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOG] = ds_output_log;\r\n  ds->mMethods[NE_DS_METHOD_ASSERT] = ds_assert;\r\n  ds->mMakeOutput[NE_DS_METHOD_ASSERT] = ds_output_assert;\r\n  ds->mMethods[NE_DS_METHOD_PASSERT] = ds_passert;\r\n  ds->mMakeOutput[NE_DS_METHOD_PASSERT] = ds_output_passert;\r\n  ds->mMethods[NE_DS_METHOD_IASSERT] = ds_iassert;\r\n  ds->mMakeOutput[NE_DS_METHOD_IASSERT] = ds_output_iassert;\r\n  ds->mMethods[NE_DS_METHOD_DEL_T] = ds_del_t;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_T] = ds_output_del_t;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V] = ds_del_v;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V] = ds_output_del_v;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V0] = ds_del_v0;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V0] = ds_output_del_v0;\r\n  ds->mMethods[NE_DS_METHOD_DEL_TMAX] = ds_del_tmax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_TMAX] = ds_output_del_tmax;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT_P] = ds_dxdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT_P] = ds_output_dxdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT] = ds_dxdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT] = ds_output_dxdelt;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT_P] = ds_dudelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT_P] = ds_output_dudelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT] = ds_dudelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT] = ds_output_dudelt;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT_P] = ds_dtdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT_P] = ds_output_dtdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT] = ds_dtdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT] = ds_output_dtdelt;\r\n  ds->mMethods[NE_DS_METHOD_OBS_EXP] = DCMotor_Control_4a109994_1_ds_obs_exp;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_EXP] = ds_output_obs_exp;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ACT] = DCMotor_Control_4a109994_1_ds_obs_act;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ACT] = ds_output_obs_act;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ALL] = DCMotor_Control_4a109994_1_ds_obs_all;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ALL] = ds_output_obs_all;\r\n  ds->mMethods[NE_DS_METHOD_OBS_IL] = DCMotor_Control_4a109994_1_ds_obs_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_IL] = ds_output_obs_il;\r\n  ds->mMethods[NE_DS_METHOD_DP_L] = ds_dp_l;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_L] = ds_output_dp_l;\r\n  ds->mMethods[NE_DS_METHOD_DP_I] = ds_dp_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_I] = ds_output_dp_i;\r\n  ds->mMethods[NE_DS_METHOD_DP_J] = ds_dp_j;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_J] = ds_output_dp_j;\r\n  ds->mMethods[NE_DS_METHOD_DP_R] = ds_dp_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_R] = ds_output_dp_r;\r\n  ds->mMethods[NE_DS_METHOD_QX] = ds_qx;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX] = ds_output_qx;\r\n  ds->mMethods[NE_DS_METHOD_QU] = ds_qu;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU] = ds_output_qu;\r\n  ds->mMethods[NE_DS_METHOD_QT] = ds_qt;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT] = ds_output_qt;\r\n  ds->mMethods[NE_DS_METHOD_Q1] = ds_q1;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1] = ds_output_q1;\r\n  ds->mMethods[NE_DS_METHOD_QX_P] = ds_qx_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX_P] = ds_output_qx_p;\r\n  ds->mMethods[NE_DS_METHOD_QU_P] = ds_qu_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU_P] = ds_output_qu_p;\r\n  ds->mMethods[NE_DS_METHOD_QT_P] = ds_qt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT_P] = ds_output_qt_p;\r\n  ds->mMethods[NE_DS_METHOD_Q1_P] = ds_q1_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1_P] = ds_output_q1_p;\r\n  ds->mMethods[NE_DS_METHOD_VAR_TOL] = ds_var_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_VAR_TOL] = ds_output_var_tol;\r\n  ds->mMethods[NE_DS_METHOD_EQ_TOL] = ds_eq_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_EQ_TOL] = ds_output_eq_tol;\r\n  ds->mMethods[NE_DS_METHOD_LV] = ds_lv;\r\n  ds->mMakeOutput[NE_DS_METHOD_LV] = ds_output_lv;\r\n  ds->mMethods[NE_DS_METHOD_SLV] = ds_slv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLV] = ds_output_slv;\r\n  ds->mMethods[NE_DS_METHOD_NLDV] = ds_nldv;\r\n  ds->mMakeOutput[NE_DS_METHOD_NLDV] = ds_output_nldv;\r\n  ds->mMethods[NE_DS_METHOD_SCLV] = ds_sclv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SCLV] = ds_output_sclv;\r\n  ds->mMethods[NE_DS_METHOD_IMIN] = ds_imin;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMIN] = ds_output_imin;\r\n  ds->mMethods[NE_DS_METHOD_IMAX] = ds_imax;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMAX] = ds_output_imax;\r\n  ds->mMethods[NE_DS_METHOD_DIMIN] = ds_dimin;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMIN] = ds_output_dimin;\r\n  ds->mMethods[NE_DS_METHOD_DIMAX] = ds_dimax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMAX] = ds_output_dimax;\r\n\r\n  /* equation data */\r\n  ds->mEquationData = s_equation_data;\r\n\r\n  /* cer data */\r\n  ds->mCERData = s_cer_data;\r\n\r\n  /* icr data */\r\n  ds->mICRData = s_icr_data;\r\n\r\n  /* continuous variable data */\r\n  ds->mVariableData = s_variable_data;\r\n\r\n  /* discrete variable data */\r\n  ds->mDiscreteData = s_discrete_data;\r\n\r\n  /* observable data */\r\n  ds->mObservableData = s_observable_data;\r\n\r\n  /* major mode data */\r\n  ds->mMajorModeData = s_major_mode_data;\r\n\r\n  /* zc data */\r\n  ds->mZCData = s_zc_data;\r\n\r\n  /* ranges */\r\n  ds->mRanges = s_range;\r\n\r\n  /* assert data */\r\n  ds->mAssertData = s_assert_data;\r\n\r\n  /* assert ranges */\r\n  ds->mAssertRanges = s_assert_range;\r\n\r\n  /* param assert data */\r\n  ds->mParamAssertData = s_param_assert_data;\r\n\r\n  /* param assert ranges */\r\n  ds->mParamAssertRanges = s_param_assert_range;\r\n\r\n  /* initial assert data */\r\n  ds->mInitialAssertData = s_initial_assert_data;\r\n\r\n  /* initial assert ranges */\r\n  ds->mInitialAssertRanges = s_initial_assert_range;\r\n\r\n  /* equation ranges */\r\n  ds->mEquationRanges = s_equation_range;\r\n\r\n  /* cer ranges */\r\n  ds->mCERRanges = s_cer_range;\r\n\r\n  /* icr ranges */\r\n  ds->mICRRanges = s_icr_range;\r\n\r\n  /* parameters */\r\n  ds->mLogicalParameters = s_logical_parameter_data;\r\n  ds->mIntegerParameters = s_integer_parameter_data;\r\n  ds->mIndexParameters = s_index_parameter_data;\r\n  ds->mRealParameters = s_real_parameter_data;\r\n\r\n  /* constant tables */\r\n  ds->mNumLargeArray = 0;\r\n  return (NeDynamicSystem *)_ds;\r\n}\r\n\r\nstatic int32_T ds_assert (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  (void)t1;\r\n  out = t2->mASSERT;\r\n  out.mX[0] = 1;\r\n  out.mX[1] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_passert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_iassert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cer (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXCER_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_tmax (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_t (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXDELT_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUDELT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTDELT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfp (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfo (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_f (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mF;\r\n  out.mX[0] = -0.0;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = -0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXF_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a (const NeDynamicSystem *sys, const NeDynamicSystemInput *t14,\r\n                     NeDsMethodOutput *t15)\r\n{\r\n  PmRealVector out;\r\n  (void)t14;\r\n  out = t15->mA;\r\n  out.mX[0] = 0.9999999976103;\r\n  out.mX[1] = 0.99999999761030012;\r\n  out.mX[2] = 0.00014187880255196977;\r\n  out.mX[3] = -2.5221814560432331E-5;\r\n  out.mX[4] = 0.004;\r\n  (void)sys;\r\n  (void)t15;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mA_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mJc[2] = 5;\r\n  out.mJc[3] = 5;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  out.mIr[2] = 0;\r\n  out.mIr[3] = 1;\r\n  out.mIr[4] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b (const NeDynamicSystem *sys, const NeDynamicSystemInput *t3,\r\n                     NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  (void)t3;\r\n  out = t4->mB;\r\n  out.mX[0] = -0.41846256752324562;\r\n  out.mX[1] = 9.999999976103E-10;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mB_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mC_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tdxf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXF_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mJc[2] = 5;\r\n  out.mJc[3] = 5;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  out.mIr[2] = 0;\r\n  out.mIr[3] = 1;\r\n  out.mIr[4] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDWF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPDXF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDNF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_v_x (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mDNF_V_X;\r\n  out.mX[0] = true;\r\n  out.mX[1] = true;\r\n  out.mX[2] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF0;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vpf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVPF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vsf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVSF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ic (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIC;\r\n  out.mX[0] = 0.0;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_im (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_id (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_il (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICR_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICR_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUICR_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mICRM_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICRM_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICRM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imin (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  out.mX[1] = -pmf_get_inf();\r\n  out.mX[2] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imax (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  out.mX[1] = pmf_get_inf();\r\n  out.mX[2] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimin (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimax (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mM;\r\n  out.mX[0] = -5.020295434573378E-6;\r\n  out.mX[1] = 8.4312601601199681E-9;\r\n  out.mX[2] = 1.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mM_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 3;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  out.mIr[2] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXM_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMM;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mode (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_l (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_j (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1 (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQX_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQU_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQ1_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_var_tol (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mVAR_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_eq_tol (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mEQ_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lv (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_nldv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mNLDV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sclv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSCLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_y (const NeDynamicSystem *sys, const NeDynamicSystemInput *t2,\r\n                     NeDsMethodOutput *t3)\r\n{\r\n  PmRealVector out;\r\n  real_T U_idx_0;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_2;\r\n  U_idx_0 = t2->mU.mX[0];\r\n  X_idx_0 = t2->mX.mX[0];\r\n  X_idx_1 = t2->mX.mX[1];\r\n  X_idx_2 = t2->mX.mX[2];\r\n  out = t3->mY;\r\n  out.mX[0] = -((X_idx_0 * -0.9999999976103 + X_idx_1 * 3.390477744584422E-13) +\r\n                U_idx_0 * -9.999999976103E-10);\r\n  out.mX[1] = X_idx_2;\r\n  out.mX[2] = X_idx_1 * 0.004;\r\n  out.mX[3] = U_idx_0;\r\n  (void)sys;\r\n  (void)t3;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t4, NeDsMethodOutput *t5)\r\n{\r\n  PmRealVector out;\r\n  (void)t4;\r\n  out = t5->mDXY;\r\n  out.mX[0] = 0.9999999976103;\r\n  out.mX[1] = -3.390477744584422E-13;\r\n  out.mX[2] = 0.004;\r\n  out.mX[3] = 1.0;\r\n  (void)sys;\r\n  (void)t5;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXY_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 3;\r\n  out.mJc[3] = 4;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 0;\r\n  out.mIr[2] = 2;\r\n  out.mIr[3] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t2, NeDsMethodOutput *t3)\r\n{\r\n  PmRealVector out;\r\n  (void)t2;\r\n  out = t3->mDUY;\r\n  out.mX[0] = 9.999999976103E-10;\r\n  out.mX[1] = 1.0;\r\n  (void)sys;\r\n  (void)t3;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 3;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDUY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDXY_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 3;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXY_P;\r\n  out.mNumCol = 3ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 3;\r\n  out.mJc[3] = 4;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 0;\r\n  out.mIr[2] = 2;\r\n  out.mIr[3] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 4ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_zc (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds.h - header for module DCMotor_Control_4a109994_1_ds */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_H 1\r\n\r\n  extern NeDynamicSystem *DCMotor_Control_4a109994_1_dae_ds(PmAllocator\r\n    *allocator );\r\n\r\n#endif                             /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_external_struct.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifndef struct__ExternalFunctionStructTag\r\n#define struct__ExternalFunctionStructTag\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_externals.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_log.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_log.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCMotor_Control_4a109994_1_ds_log(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  real_T U_idx_0;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_2;\r\n  real_T t1;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  X_idx_0 = t3->mX.mX[0];\r\n  X_idx_1 = t3->mX.mX[1];\r\n  X_idx_2 = t3->mX.mX[2];\r\n  out = t4->mLOG;\r\n  DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i = (X_idx_0 *\r\n    -0.9999999976103 + X_idx_1 * 3.390477744584422E-13) + U_idx_0 *\r\n    -9.999999976103E-10;\r\n  t1 = X_idx_1 * 0.004;\r\n  out.mX[0] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[1] = U_idx_0;\r\n  out.mX[2] = U_idx_0;\r\n  out.mX[3] = U_idx_0;\r\n  out.mX[4] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[5] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[6] = U_idx_0;\r\n  out.mX[7] = U_idx_0;\r\n  out.mX[8] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[9] = X_idx_1;\r\n  out.mX[10] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[11] = X_idx_0;\r\n  out.mX[12] = U_idx_0;\r\n  out.mX[13] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i *\r\n    DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i * 0.0023897 * 1000.0;\r\n  out.mX[14] = U_idx_0;\r\n  out.mX[15] = X_idx_1 * 9.5492965855137211;\r\n  out.mX[16] = X_idx_1 * 0.004;\r\n  out.mX[17] = X_idx_1;\r\n  out.mX[18] = X_idx_2;\r\n  out.mX[19] = X_idx_1 * 0.004;\r\n  out.mX[20] = t1;\r\n  out.mX[21] = X_idx_2 * 57.295779513082323;\r\n  out.mX[22] = X_idx_2;\r\n  out.mX[23] = t1;\r\n  out.mX[24] = U_idx_0;\r\n  out.mX[25] = U_idx_0;\r\n  out.mX[26] = U_idx_0;\r\n  out.mX[27] = U_idx_0;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_log.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds_log.h - header for method DCMotor_Control_4a109994_1_ds_log */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_LOG_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_LOG_H 1\r\n\r\n  int32_T DCMotor_Control_4a109994_1_ds_log(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                         /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_LOG_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_act.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_act.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCMotor_Control_4a109994_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  real_T U_idx_0;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_2;\r\n  real_T t1;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  X_idx_0 = t3->mX.mX[0];\r\n  X_idx_1 = t3->mX.mX[1];\r\n  X_idx_2 = t3->mX.mX[2];\r\n  out = t4->mOBS_ACT;\r\n  DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i = (X_idx_0 *\r\n    -0.9999999976103 + X_idx_1 * 3.390477744584422E-13) + U_idx_0 *\r\n    -9.999999976103E-10;\r\n  t1 = X_idx_1 * 0.004;\r\n  out.mX[0] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = U_idx_0;\r\n  out.mX[3] = U_idx_0;\r\n  out.mX[4] = U_idx_0;\r\n  out.mX[5] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[6] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[7] = U_idx_0;\r\n  out.mX[8] = U_idx_0;\r\n  out.mX[9] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = X_idx_1;\r\n  out.mX[12] = 1.0;\r\n  out.mX[13] = 1.0;\r\n  out.mX[14] = 0.0;\r\n  out.mX[15] = 0.0;\r\n  out.mX[16] = 0.0;\r\n  out.mX[17] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[18] = X_idx_0;\r\n  out.mX[19] = 0.0;\r\n  out.mX[20] = U_idx_0;\r\n  out.mX[21] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i *\r\n    DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i * 0.0023897 * 1000.0;\r\n  out.mX[22] = 0.0;\r\n  out.mX[23] = U_idx_0;\r\n  out.mX[24] = 0.0;\r\n  out.mX[25] = X_idx_1 * 9.5492965855137211;\r\n  out.mX[26] = 0.0;\r\n  out.mX[27] = 0.0;\r\n  out.mX[28] = 0.0;\r\n  out.mX[29] = X_idx_1 * 0.004;\r\n  out.mX[30] = X_idx_1;\r\n  out.mX[31] = 0.0;\r\n  out.mX[32] = 0.0;\r\n  out.mX[33] = X_idx_2;\r\n  out.mX[34] = 0.0;\r\n  out.mX[35] = X_idx_1 * 0.004;\r\n  out.mX[36] = t1;\r\n  out.mX[37] = X_idx_2 * 57.295779513082323;\r\n  out.mX[38] = X_idx_2;\r\n  out.mX[39] = t1;\r\n  out.mX[40] = 0.0;\r\n  out.mX[41] = 0.0;\r\n  out.mX[42] = U_idx_0;\r\n  out.mX[43] = U_idx_0;\r\n  out.mX[44] = 0.0;\r\n  out.mX[45] = U_idx_0;\r\n  out.mX[46] = U_idx_0;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_act.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds_obs_act.h - header for method DCMotor_Control_4a109994_1_ds_obs_act */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_ACT_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_OBS_ACT_H 1\r\n\r\n  int32_T DCMotor_Control_4a109994_1_ds_obs_act(const NeDynamicSystem *sys,\r\n    const NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                     /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_ACT_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_all.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_all.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCMotor_Control_4a109994_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  real_T U_idx_0;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_2;\r\n  real_T t1;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  X_idx_0 = t3->mX.mX[0];\r\n  X_idx_1 = t3->mX.mX[1];\r\n  X_idx_2 = t3->mX.mX[2];\r\n  out = t4->mOBS_ALL;\r\n  DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i = (X_idx_0 *\r\n    -0.9999999976103 + X_idx_1 * 3.390477744584422E-13) + U_idx_0 *\r\n    -9.999999976103E-10;\r\n  t1 = X_idx_1 * 0.004;\r\n  out.mX[0] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = U_idx_0;\r\n  out.mX[3] = U_idx_0;\r\n  out.mX[4] = U_idx_0;\r\n  out.mX[5] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[6] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[7] = U_idx_0;\r\n  out.mX[8] = U_idx_0;\r\n  out.mX[9] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = X_idx_1;\r\n  out.mX[12] = 1.0;\r\n  out.mX[13] = 1.0;\r\n  out.mX[14] = 0.0;\r\n  out.mX[15] = 0.0;\r\n  out.mX[16] = 0.0;\r\n  out.mX[17] = -DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i;\r\n  out.mX[18] = X_idx_0;\r\n  out.mX[19] = 0.0;\r\n  out.mX[20] = U_idx_0;\r\n  out.mX[21] = DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i *\r\n    DC_Motor_Simscape_Motor_Controlled_Voltage_Source_i * 0.0023897 * 1000.0;\r\n  out.mX[22] = 0.0;\r\n  out.mX[23] = U_idx_0;\r\n  out.mX[24] = 0.0;\r\n  out.mX[25] = X_idx_1 * 9.5492965855137211;\r\n  out.mX[26] = 0.0;\r\n  out.mX[27] = 0.0;\r\n  out.mX[28] = 0.0;\r\n  out.mX[29] = X_idx_1 * 0.004;\r\n  out.mX[30] = X_idx_1;\r\n  out.mX[31] = 0.0;\r\n  out.mX[32] = 0.0;\r\n  out.mX[33] = X_idx_2;\r\n  out.mX[34] = 0.0;\r\n  out.mX[35] = X_idx_1 * 0.004;\r\n  out.mX[36] = t1;\r\n  out.mX[37] = X_idx_2 * 57.295779513082323;\r\n  out.mX[38] = X_idx_2;\r\n  out.mX[39] = t1;\r\n  out.mX[40] = 0.0;\r\n  out.mX[41] = 0.0;\r\n  out.mX[42] = U_idx_0;\r\n  out.mX[43] = U_idx_0;\r\n  out.mX[44] = 0.0;\r\n  out.mX[45] = U_idx_0;\r\n  out.mX[46] = U_idx_0;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_all.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds_obs_all.h - header for method DCMotor_Control_4a109994_1_ds_obs_all */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_ALL_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_OBS_ALL_H 1\r\n\r\n  int32_T DCMotor_Control_4a109994_1_ds_obs_all(const NeDynamicSystem *sys,\r\n    const NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                     /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_ALL_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_exp.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_exp.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCMotor_Control_4a109994_1_ds_obs_exp(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mOBS_EXP;\r\n  out.mX[0] = 0.0;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = 0.0;\r\n  out.mX[3] = 0.0;\r\n  out.mX[4] = 0.0;\r\n  out.mX[5] = 0.0;\r\n  out.mX[6] = 0.0;\r\n  out.mX[7] = 0.0;\r\n  out.mX[8] = 0.0;\r\n  out.mX[9] = 0.0;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = 0.0;\r\n  out.mX[12] = 1.0;\r\n  out.mX[13] = 1.0;\r\n  out.mX[14] = 0.0;\r\n  out.mX[15] = 0.0;\r\n  out.mX[16] = 0.0;\r\n  out.mX[17] = 0.0;\r\n  out.mX[18] = 0.0;\r\n  out.mX[19] = 0.0;\r\n  out.mX[20] = 0.0;\r\n  out.mX[21] = 0.0;\r\n  out.mX[22] = 0.0;\r\n  out.mX[23] = 0.0;\r\n  out.mX[24] = 0.0;\r\n  out.mX[25] = 0.0;\r\n  out.mX[26] = 0.0;\r\n  out.mX[27] = 0.0;\r\n  out.mX[28] = 0.0;\r\n  out.mX[29] = 0.0;\r\n  out.mX[30] = 0.0;\r\n  out.mX[31] = 0.0;\r\n  out.mX[32] = 0.0;\r\n  out.mX[33] = 0.0;\r\n  out.mX[34] = 0.0;\r\n  out.mX[35] = 0.0;\r\n  out.mX[36] = 0.0;\r\n  out.mX[37] = 0.0;\r\n  out.mX[38] = 0.0;\r\n  out.mX[39] = 0.0;\r\n  out.mX[40] = 0.0;\r\n  out.mX[41] = 0.0;\r\n  out.mX[42] = 0.0;\r\n  out.mX[43] = 0.0;\r\n  out.mX[44] = 0.0;\r\n  out.mX[45] = 0.0;\r\n  out.mX[46] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_exp.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds_obs_exp.h - header for method DCMotor_Control_4a109994_1_ds_obs_exp */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_EXP_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_OBS_EXP_H 1\r\n\r\n  int32_T DCMotor_Control_4a109994_1_ds_obs_exp(const NeDynamicSystem *sys,\r\n    const NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                     /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_EXP_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_il.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_sys_struct.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_obs_il.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_externals.h\"\r\n#include \"DCMotor_Control_4a109994_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T DCMotor_Control_4a109994_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mOBS_IL;\r\n  out.mX[0] = false;\r\n  out.mX[1] = true;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  out.mX[15] = true;\r\n  out.mX[16] = true;\r\n  out.mX[17] = false;\r\n  out.mX[18] = true;\r\n  out.mX[19] = true;\r\n  out.mX[20] = false;\r\n  out.mX[21] = false;\r\n  out.mX[22] = true;\r\n  out.mX[23] = false;\r\n  out.mX[24] = true;\r\n  out.mX[25] = true;\r\n  out.mX[26] = true;\r\n  out.mX[27] = true;\r\n  out.mX[28] = true;\r\n  out.mX[29] = true;\r\n  out.mX[30] = true;\r\n  out.mX[31] = true;\r\n  out.mX[32] = true;\r\n  out.mX[33] = true;\r\n  out.mX[34] = true;\r\n  out.mX[35] = true;\r\n  out.mX[36] = true;\r\n  out.mX[37] = true;\r\n  out.mX[38] = true;\r\n  out.mX[39] = true;\r\n  out.mX[40] = true;\r\n  out.mX[41] = true;\r\n  out.mX[42] = false;\r\n  out.mX[43] = false;\r\n  out.mX[44] = true;\r\n  out.mX[45] = false;\r\n  out.mX[46] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_obs_il.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n/* DCMotor_Control_4a109994_1_ds_obs_il.h - header for method DCMotor_Control_4a109994_1_ds_obs_il */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_IL_H\r\n#define DCMOTOR_CONTROL_4A109994_1_DS_OBS_IL_H 1\r\n\r\n  int32_T DCMotor_Control_4a109994_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif                      /* #ifndef DCMOTOR_CONTROL_4A109994_1_DS_OBS_IL_H */\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_ds_sys_struct.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifndef struct__NeDynamicSystemTag\r\n#define struct__NeDynamicSystemTag\r\n\r\ntypedef struct _NeDynamicSystemTag {\r\n  NeDynamicSystem mBase;\r\n  int32_T mRefCnt;\r\n  PmAllocator mAlloc;\r\n} _NeDynamicSystem;\r\n\r\n#else\r\n\r\ntypedef struct _NeDynamicSystemTag _NeDynamicSystem;\r\n\r\n#endif\r\n"},{"name":"DCMotor_Control_4a109994_1_gateway.c","type":"source","group":"legacy","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifdef MATLAB_MEX_FILE\r\n#include \"tmwtypes.h\"\r\n#else\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"nesl_rtw.h\"\r\n#include \"DCMotor_Control_4a109994_1.h\"\r\n#include \"DCMotor_Control_4a109994_1_gateway.h\"\r\n\r\nvoid DCMotor_Control_4a109994_1_gateway(void)\r\n{\r\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0, 0, 1e-05, 0, 0,\r\n    0, 0, (SscLoggingSetting) 0, 578363684, 0, };\r\n\r\n  NeSolverParameters solverparams = { 0, 0, 1, 0, 0, 0.001, 1e-06, 1e-09, 0, 0,\r\n    100, 0, 1, 0, 1e-09, 0, (NeLocalSolverChoice) 0, 0.001, 0, 3, 2, 0, 2,\r\n    (NeLinearAlgebraChoice) 0, (NeEquationFormulationChoice) 0, 1024, 1, 0.001,\r\n    (NePartitionStorageMethod) 0, 1024, (NePartitionMethod) 0, };\r\n\r\n  const NeOutputParameters* outputparameters = NULL;\r\n  NeDae* dae;\r\n  size_t numOutputs = 0;\r\n  int* rtpDaes = NULL;\r\n  int* rtwLogDaes = NULL;\r\n\r\n  {\r\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, { 0,\r\n        1, }, };\r\n\r\n    outputparameters = outputparameters_init;\r\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\r\n  }\r\n\r\n  DCMotor_Control_4a109994_1_dae(&dae,\r\n    &modelparams,\r\n    &solverparams);\r\n  nesl_register_simulator_group(\r\n    \"DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration_1\",\r\n    1,\r\n    &dae,\r\n    &solverparams,\r\n    &modelparams,\r\n    numOutputs,\r\n    outputparameters,\r\n    0,\r\n    rtpDaes,\r\n    0,\r\n    rtwLogDaes);\r\n}\r\n"},{"name":"DCMotor_Control_4a109994_1_gateway.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifndef __DCMotor_Control_4a109994_1_gateway_h__\r\n#define __DCMotor_Control_4a109994_1_gateway_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void DCMotor_Control_4a109994_1_gateway(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                    /* #ifndef __DCMotor_Control_4a109994_1_gateway_h__ */\r\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'DCMotor_Control/DC_Motor_Simscape_Motor/Solver Configuration'.\r\n */\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SSC_ML_FUN_H\r\n#define SSC_ML_FUN_H                   1\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n};\r\n\r\n#endif\r\n"},{"name":"CoderAssumpTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\extern\\include\\coder\\connectivity\\CoderAssumpTgtAppSvc","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#ifndef CoderAssumpTgtAppSvc_CInterface_h\n#define CoderAssumpTgtAppSvc_CInterface_h\n\n#include \"CoderAssumpTgtAppSvc_spec.h\"\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_CODERASSUMPTGTAPPSVC) \n    typedef uint8_T IOUnit_T;  \n#else\n    #include \"xilcomms_rtiostream.h\"\n#endif\n\n#define CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID 3\n\n#ifdef USE_CODERASSUMPTGTAPPSVC_ERROR\n    static const uint8_T CODERASSUMPTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_CODERASSUMPTGTAPPSVC_SUCCESS\n    static const uint8_T CODERASSUMPTGTAPPSVC_SUCCESS = 1;\n#endif\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcCreate(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C void coderAssumpTgtAppSvcDestroy(void);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C IOUnit_T* coderAssumpTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint8_T coderAssumpTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nCODERASSUMPTGTAPPSVC_API_EXTERN_C uint16_T coderAssumpTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"DCMotor_Control_sbs.c","type":"source","group":"SILPIL","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw\\sil","tag":"In-the-Loop:Host","groupDisplay":"SIL/PIL files","code":"/*\r\n * DCMotor_Control_sbs.c\r\n *\r\n * Automatically generated s-function with I/O interface for:\r\n * Component: DCMotor_Control\r\n * Component Simulink Path: DCMotor_Control\r\n * Simulation Mode: SIL\r\n *\r\n */\r\n\r\n#define S_FUNCTION_NAME                DCMotor_Control_sbs\r\n#define S_FUNCTION_LEVEL               2\r\n#if !defined(RTW_GENERATED_S_FUNCTION)\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include \"simstruc.h\"\r\n#include \"simtarget/slMdlrefSimTargetCoreHeaders.h\"\r\n#include \"simtarget/slMdlrefSimTargetInstrumentationHeaders.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"coder/connectivity_core/xilutils/xilutils.h\"\r\n#include \"coder/simulinkcoder/xilutils_sl/xilutils_sl.h\"\r\n#include \"rtiostream_utils.h\"\r\n#include \"coder/connectivity/xilcomms_rtiostream/xilcomms_rtiostream.h\"\r\n#include \"coder/connectivity/XILHostAppSvc/XILHostAppSvc_CInterface.h\"\r\n#include \"messages/slMessagesSfcnBridge.h\"\r\n#include \"strings/slStringSfcnAPI.h\"\r\n#include \"mwstringutil.h\"\r\n#include \"coder/connectivity/CoderAssumpHostAppSvc/CoderAssumpHostAppSvc_CInterface.h\"\r\n\r\nstatic real_T rtInf;\r\nstatic real_T rtMinusInf;\r\n\r\n/* Response case labels */\r\nenum ResponseIDs {\r\n  RESPONSE_ERROR = 0,\r\n  RESPONSE_OUTPUT_PRE_DATA = 1,\r\n  RESPONSE_OUTPUT_DATA = 2,\r\n  RESPONSE_PRINTF = 3,\r\n  RESPONSE_FOPEN = 4,\r\n  RESPONSE_FPRINTF = 5,\r\n  RESPONSE_SIGNAL_RAISED = 6\r\n};\r\n\r\ntypedef struct {\r\n  FILE ** Fd;\r\n  mwSize size;\r\n  int32_T fidOffset;\r\n} targetIOFd_T;\r\n\r\ntypedef enum {\r\n  XIL_INIT_COMMAND = 0,\r\n  XIL_INITIALIZE_COMMAND,\r\n  XIL_SYSTEM_INITIALIZE_COMMAND,\r\n  XIL_OUTPUT_COMMAND,\r\n  XIL_TERMINATE_COMMAND,\r\n  XIL_ENABLE_COMMAND,\r\n  XIL_DISABLE_COMMAND,\r\n  XIL_CONST_OUTPUT_COMMAND,\r\n  XIL_PROCESS_PARAMS_COMMAND,\r\n  XIL_CLIENT_SERVER_COMMAND,\r\n  XIL_SHUTDOWN_COMMAND,\r\n  XIL_UPDATE_COMMAND,\r\n  XIL_SYSTEM_RESET_COMMAND,\r\n  XIL_PAUSE_COMMAND\r\n}\r\n  XIL_COMMAND_TYPE_ENUM;\r\n\r\nstatic RegMdlInfo rtMdlInfo_DCMotor_Control[1] = { \"\",\r\n  MDL_INFO_ID_GLOBAL_RTW_CONSTRUCT, 0, 0, NULL };\r\n\r\nstatic char * getSimulinkBlockPath(SimStruct *S)\r\n{\r\n  char * simulinkBlockPath = NULL;\r\n  const char * origBlockPath = ssGetPath(S);\r\n  const char * searchString = \"TmpSFcnForModelReference_\";\r\n  const char * searchPtr;\r\n  size_t origLength, searchAndNameLength, copyAmount;\r\n  char * secondPart;\r\n  size_t nameLength;\r\n  origLength = strlen(origBlockPath);\r\n  searchPtr = strstr(origBlockPath, searchString);\r\n  if (searchPtr == NULL) {\r\n    return simulinkBlockPath;\r\n  }\r\n\r\n  searchAndNameLength = strlen(searchPtr);\r\n  copyAmount = origLength - searchAndNameLength;\r\n  simulinkBlockPath = (char *) mxCalloc((mwSize) (origLength + 1), sizeof(char));\r\n  simulinkBlockPath = strncpy(simulinkBlockPath, origBlockPath, copyAmount);\r\n  simulinkBlockPath[copyAmount] = '\\0';\r\n  nameLength = searchAndNameLength - strlen(searchString);\r\n  secondPart = &simulinkBlockPath[copyAmount];\r\n  secondPart = strncpy(secondPart, &origBlockPath[origLength - nameLength],\r\n                       nameLength);\r\n  secondPart[nameLength] = '\\0';\r\n  return simulinkBlockPath;\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S);\r\nstatic void mdlTerminate(SimStruct *S);\r\n\r\n/* grow the buffer for target I/O Fd array\r\n * targetIOFd->Fd is NULL on failure */\r\nstatic void growTargetIOFd(SimStruct *S, targetIOFd_T * IOFd, mwSize\r\n  requiredSize)\r\n{\r\n  if (IOFd->size < requiredSize) {\r\n    IOFd->Fd = (FILE**)mxRealloc(IOFd->Fd, requiredSize * sizeof(FILE*));\r\n    if (IOFd->Fd == NULL) {\r\n      ssSetErrorStatus( S,\"growTargetIOFd: mxRealloc failed.\");\r\n    } else {\r\n      mexMakeMemoryPersistent(IOFd->Fd);\r\n      IOFd->size = requiredSize;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic void closeAndFreeTargetIOFd(SimStruct *S)\r\n{\r\n  int i;\r\n  if (ssGetPWork(S) != NULL) {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        for (i=0; i<targetIOFdPtr->size; i++) {\r\n          if (targetIOFdPtr->Fd[i] != NULL) {\r\n            fclose(targetIOFdPtr->Fd[i]);\r\n          }                            /* if */\r\n        }                              /* for */\r\n\r\n        mxFree(targetIOFdPtr->Fd);\r\n      }                                /* if */\r\n\r\n      mxFree(targetIOFdPtr);\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 3, NULL);\r\n  }                                    /* if */\r\n}\r\n\r\n/* receive one packet of data and dispatch to owning application */\r\nstatic boolean_T recvData(SimStruct *S, void* pComms)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  if (pXILUtils == NULL) {\r\n    ssSetErrorStatus( S,\"pXILUtils is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilCommsRun(pComms, pXILUtils) !=\r\n    XILCOMMS_RTIOSTREAM_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* send data via xil comms */\r\nstatic boolean_T sendData(SimStruct *S, void* pXILService, XIL_IOBuffer_T\r\n  * IOBuffer, mwSize sendSize)\r\n{\r\n  int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n  if (pCommErrorOccurred == NULL) {\r\n    ssSetErrorStatus( S,\"pCommErrorOccurred is NULL.\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  *pCommErrorOccurred = (xilHostAppSvcSend(pXILService, IOBuffer->data, sendSize)\r\n    != XILHOSTAPPSVC_SUCCESS);\r\n  return (*pCommErrorOccurred?XILHOSTAPPSVC_ERROR:XILHOSTAPPSVC_SUCCESS);\r\n}\r\n\r\n/* implements command dispatch */\r\nstatic boolean_T commandDispatch(SimStruct *S, XIL_IOBuffer_T* IOBuffer, mwSize\r\n  dataOutSize)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  /* send the data */\r\n  if (sendData(S, pXILService, IOBuffer, dataOutSize) != XILHOSTAPPSVC_SUCCESS)\r\n  {\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\n/* implements command response */\r\nstatic boolean_T commandResponse(SimStruct *S, mwSize* dataInSize,\r\n  XILCommandResponseType* commandType)\r\n{\r\n  void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n  if (pXILService == NULL) {\r\n    ssSetErrorStatus( S,\"pXILService is NULL!\");\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }                                    /* if */\r\n\r\n  {\r\n    /* receive the response data */\r\n    uint8_T COMMAND_COMPLETE = 0;\r\n    void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n    if (pComms == NULL) {\r\n      ssSetErrorStatus( S,\"pComms is NULL!\");\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }                                  /* if */\r\n\r\n    while (!COMMAND_COMPLETE) {\r\n      xilHostAppSvcSetIsResponseComplete(pXILService, 0);\r\n      if (recvData(S, pComms) != XILHOSTAPPSVC_SUCCESS) {\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }                                /* if */\r\n\r\n      COMMAND_COMPLETE = xilHostAppSvcGetIsResponseComplete(pXILService);\r\n    }                                  /* while */\r\n\r\n    /* determine command response type */\r\n    *commandType = (XILCommandResponseType) COMMAND_COMPLETE;\r\n    *dataInSize = xilHostAppSvcGetPayloadSizeForOneStep(pXILService);\r\n    return XILHOSTAPPSVC_SUCCESS;\r\n  }\r\n}\r\n\r\nstatic void copyIOData(void * const dstPtr, void * const srcPtr, uint8_T **\r\n  const tgtPtrPtr, size_t numElements, size_t cTypeSize)\r\n{\r\n  size_t maxBytesConsumed = numElements * cTypeSize;\r\n  memcpy(dstPtr, srcPtr, maxBytesConsumed);\r\n  (*tgtPtrPtr)+=(maxBytesConsumed/sizeof(**tgtPtrPtr));\r\n}\r\n\r\nstatic void copyStringIOData(void * const dstPtr, void * const srcPtr, uint8_T **\r\n  const tgtPtrPtr, size_t numElements, size_t cTypeSize, uint8_T isInput)\r\n{\r\n  size_t maxBytesConsumed = numElements * cTypeSize;\r\n  if (isInput) {\r\n    suWriteSILStringInput((char *)dstPtr, (int32_T)numElements, srcPtr);\r\n  } else {\r\n    suWriteSILStringOutput(dstPtr, (char *)srcPtr, (int32_T)numElements);\r\n  }                                    /* if */\r\n\r\n  (*tgtPtrPtr)+=(maxBytesConsumed/sizeof(**tgtPtrPtr));\r\n}\r\n\r\nstatic void callStopHookAndFreeSFcnMemory(SimStruct *S)\r\n{\r\n  closeAndFreeTargetIOFd(S);\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted != NULL) && (*pIsXILApplicationStarted == 1))\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (pXILUtils) {\r\n          mxArray *rhs[3];\r\n          char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n          if (simulinkBlockPath == NULL) {\r\n            ssSetErrorStatus(S,\r\n                             \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n            return;\r\n          }\r\n\r\n          rhs[ 0 ] = mxCreateString(\r\n            \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n          rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n          rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n          xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionPILStopHook\");\r\n          mxFree((void *) simulinkBlockPath);\r\n        }                              /* if */\r\n      }\r\n    }                                  /* if */\r\n\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      *pIsXILApplicationStarted = 0;\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    XIL_IOBuffer_T* IOBufferPtr;\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    if (rtIOStreamDataPtr != NULL) {\r\n      {\r\n        int errorStatus = rtIOStreamUnloadLib(&rtIOStreamDataPtr->libH);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamUnloadLib failed.\");\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree(rtIOStreamDataPtr->lib);\r\n      mxDestroyArray(rtIOStreamDataPtr->MATLABObject);\r\n      mxFree(rtIOStreamDataPtr);\r\n      ssSetPWorkValue(S, 0, NULL);\r\n    }                                  /* if */\r\n\r\n    if (silDebuggingDataPtr != NULL) {\r\n      mxFree(silDebuggingDataPtr->componentBlockPath);\r\n      mxFree(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n      mxFree(silDebuggingDataPtr);\r\n      ssSetPWorkValue(S, 2, NULL);\r\n    }                                  /* if */\r\n\r\n    IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      mxFree(IOBufferPtr->data);\r\n      mxFree(IOBufferPtr);\r\n      ssSetPWorkValue(S, 1, NULL);\r\n    }                                  /* if */\r\n\r\n    closeAndFreeTargetIOFd(S);\r\n    if (ssGetPWork(S) != NULL) {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      void * pComms = (void *) ssGetPWorkValue(S, 7);\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      void * pCoderAssumptionsApp = (void *) ssGetPWorkValue(S, 10);\r\n      if (pCoderAssumptionsApp != NULL) {\r\n        coderAssumpHostAppSvcDestroy(pCoderAssumptionsApp);\r\n        ssSetPWorkValue(S, 10, NULL);\r\n      }                                /* if */\r\n\r\n      if (pXILService != NULL) {\r\n        xilHostAppSvcDestroy(pXILService);\r\n        ssSetPWorkValue(S, 9, NULL);\r\n      }                                /* if */\r\n\r\n      if (pComms != NULL) {\r\n        xilCommsDestroy(pComms);\r\n        ssSetPWorkValue(S, 7, NULL);\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T processResponseError(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  uint8_T errorId = **mxMemUnitPtrPtr;\r\n  (*mxMemUnitPtrPtr)++;\r\n  if (errorId) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pilverification:PILError\");\r\n      rhs[1] = mxCreateDoubleScalar(errorId);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  }                                    /* if */\r\n\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponsePrintf(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T PRINTF_ERROR;\r\n  uint16_T PRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint8_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &PRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(PRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    uint8_T *pPrintBuff;\r\n    pPrintBuff = *mxMemUnitPtrPtr;\r\n    if (pPrintBuff[PRINTF_SIZE-1] == '\\0') {\r\n      mexPrintf(\"%s\", pPrintBuff);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + PRINTF_SIZE;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFopen(SimStruct * S, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  uint16_T FOPEN_FID;\r\n  uint16_T FOPEN_NAME_SIZE;\r\n  targetIOFd_T *targetIOFdPtr;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FOPEN_NAME_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n  if (targetIOFdPtr != NULL) {\r\n    /* check fid increments by 1 */\r\n    if (targetIOFdPtr->fidOffset + 1 == FOPEN_FID) {\r\n      targetIOFdPtr->fidOffset = FOPEN_FID;\r\n      growTargetIOFd(S, targetIOFdPtr, targetIOFdPtr->fidOffset + 1);\r\n      if (targetIOFdPtr->Fd != NULL) {\r\n        uint8_T *pFopenBuff;\r\n        targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = NULL;\r\n        pFopenBuff = (*mxMemUnitPtrPtr);\r\n        if (pFopenBuff[FOPEN_NAME_SIZE-1] == '\\0') {\r\n          FILE * tmpFd = NULL;\r\n          tmpFd = fopen((char *) pFopenBuff,\"w\");\r\n          if (tmpFd != NULL) {\r\n            /* save the file descriptor */\r\n            targetIOFdPtr->Fd[targetIOFdPtr->fidOffset] = tmpFd;\r\n          } else {\r\n            {\r\n              void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n              mxArray * rhs[ 2 ];\r\n              rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenError\");\r\n              rhs[1] = mxCreateString((char *) pFopenBuff);\r\n              xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n              return XILHOSTAPPSVC_ERROR;\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    } else {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pil:TargetIOFopenFidError\");\r\n        rhs[1] = mxCreateDoubleScalar(FOPEN_FID);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + FOPEN_NAME_SIZE;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseFprintf(SimStruct * S, uint8_T\r\n  ** mxMemUnitPtrPtr)\r\n{\r\n  const int TARGET_IO_SUCCESS = 0;\r\n  uint8_T FPRINTF_ERROR;\r\n  uint16_T FPRINTF_FID;\r\n  uint16_T FPRINTF_SIZE;\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_ERROR;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint8_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_FID;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * simDataMemUnitPtr;\r\n      simDataMemUnitPtr = (uint8_T *) &FPRINTF_SIZE;\r\n\r\n      {\r\n        size_t num_elements = 1;\r\n\r\n        {\r\n          copyIOData(simDataMemUnitPtr, *mxMemUnitPtrPtr, &*mxMemUnitPtrPtr,\r\n                     num_elements, sizeof(uint16_T));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (FPRINTF_ERROR != TARGET_IO_SUCCESS) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 2 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:TargetIOError\");\r\n      rhs[1] = mxCreateDoubleScalar(FPRINTF_ERROR);\r\n      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n      return XILHOSTAPPSVC_ERROR;\r\n    }\r\n  } else {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) ssGetPWorkValue(S, 3);\r\n    if (targetIOFdPtr != NULL) {\r\n      if (targetIOFdPtr->size > FPRINTF_FID) {\r\n        if (targetIOFdPtr->Fd[FPRINTF_FID] != NULL) {\r\n          uint8_T *pFprintfBuff;\r\n          pFprintfBuff = (*mxMemUnitPtrPtr);\r\n          if (pFprintfBuff[FPRINTF_SIZE-1] == '\\0') {\r\n            fprintf(targetIOFdPtr->Fd[FPRINTF_FID], \"%s\", pFprintfBuff);\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  (*mxMemUnitPtrPtr) = (*mxMemUnitPtrPtr) + FPRINTF_SIZE ;\r\n  return XILHOSTAPPSVC_SUCCESS;\r\n}\r\n\r\nstatic boolean_T processResponseSignalRaised(SimStruct * S, uint8_T\r\n  ** mxMemUnitPtrPtr)\r\n{\r\n  const char *signalStr[5] = { \"SIGFPE\", \"SIGILL\", \"SIGABRT\", \"SIGSEGV\",\r\n    \"Unknown Signal\" };\r\n\r\n  uint8_T errorId = **mxMemUnitPtrPtr;\r\n  (*mxMemUnitPtrPtr)++;\r\n\r\n  {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    mxArray * rhs[ 3 ];\r\n    rhs[0] = mxCreateString(\"Connectivity:target:CaughtTargetSignalWithStderr\");\r\n    rhs[1] = mxCreateString(signalStr[errorId]);\r\n    rhs[2] = mxCreateDoubleScalar(ssGetT(S));\r\n    xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n    return XILHOSTAPPSVC_ERROR;\r\n  }\r\n}\r\n\r\nstatic boolean_T processErrorAndTargetIOResponseCases(SimStruct * S, const int\r\n  responseId, uint8_T ** mxMemUnitPtrPtr)\r\n{\r\n  switch (responseId) {\r\n   case RESPONSE_ERROR:\r\n    {\r\n      return processResponseError(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_PRINTF:\r\n    {\r\n      return processResponsePrintf(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_FOPEN:\r\n    {\r\n      return processResponseFopen(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_FPRINTF:\r\n    {\r\n      return processResponseFprintf(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   case RESPONSE_SIGNAL_RAISED:\r\n    {\r\n      return processResponseSignalRaised(S, mxMemUnitPtrPtr);\r\n    }\r\n\r\n   default:\r\n    {\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        mxArray * rhs[ 2 ];\r\n        rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n        rhs[1] = mxCreateDoubleScalar(responseId);\r\n        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n        return XILHOSTAPPSVC_ERROR;\r\n      }\r\n    }\r\n  }                                    /* switch */\r\n}\r\n\r\nstatic size_t getBusElementDimension(SimStruct * S, DTypeId dType, int_T\r\n  offsetIdx, const int_T ** dimsOut, int_T * numDims)\r\n{\r\n  int_T numDimensions = ssGetBusElementNumDimensions(S, dType, offsetIdx);\r\n  const int_T *dims = ssGetBusElementDimensions(S, dType, offsetIdx);\r\n  size_t numElements = 1;\r\n  int j = 0;\r\n  for (j = 0; j< numDimensions; j++) {\r\n    numElements *= dims[j];\r\n  }                                    /* for */\r\n\r\n  *dimsOut = dims;\r\n  *numDims = numDimensions;\r\n  return numElements;\r\n}\r\n\r\n/* Process params function shared between mdlStart and mdlProcessParams */\r\nstatic void processParams(SimStruct * S)\r\n{\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    if ((pIsXILApplicationStarted!=NULL) && (*pIsXILApplicationStarted==1)) {\r\n      /* update run time params */\r\n      ssUpdateAllTunableParamsAsRunTimeParams(S);\r\n\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_PROCESS_PARAMS_COMMAND;\r\n              mxMemUnitPtr++;\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                                 num_elements, sizeof(uint32_T));\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              mwSize dataInSize = 0;\r\n              if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (dataInSize>0) {\r\n                size_t dataInMemUnitSize = dataInSize;\r\n                uint8_T responseId = 0;\r\n                uint8_T * mxMemUnitPtrEnd;\r\n                mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n                mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n                while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                  /* read response id */\r\n                  responseId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                           &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\nstatic boolean_T startAndSetupApplication(SimStruct *S)\r\n{\r\n  {\r\n    {\r\n      mxArray *rhs[4];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      rhs[3] = mxCreateString(\"uint8\");\r\n\r\n      {\r\n        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, 0, 4, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILStartHook\")\r\n            !=XIL_UTILS_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    {                                  /* record that the XIL application has started */\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      *pIsXILApplicationStarted = 1;\r\n      ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n    }\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[3];\r\n    mxArray *lhs[5];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 5, lhs, 3, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionGetRtIOStreamInfoHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n    }\r\n\r\n    mxFree((void *) simulinkBlockPath);\r\n\r\n    {\r\n      XIL_RtIOStreamData_T* rtIOStreamDataPtr = (XIL_RtIOStreamData_T*) mxCalloc\r\n        (1, sizeof(XIL_RtIOStreamData_T));\r\n      if (rtIOStreamDataPtr == NULL) {\r\n        ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n        return false;\r\n      }                                /* if */\r\n\r\n      rtIOStreamDataPtr->lib = mxArrayToString(lhs[0]);\r\n      rtIOStreamDataPtr->MATLABObject = mxDuplicateArray(lhs[1]);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr);\r\n      mexMakeMemoryPersistent(rtIOStreamDataPtr->lib);\r\n      mexMakeArrayPersistent(rtIOStreamDataPtr->MATLABObject);\r\n      rtIOStreamDataPtr->streamID = *mxGetPr(lhs[2]);\r\n      rtIOStreamDataPtr->recvTimeout = *mxGetPr(lhs[3]);\r\n      rtIOStreamDataPtr->sendTimeout = *mxGetPr(lhs[4]);\r\n      rtIOStreamDataPtr->isRtIOStreamCCall = 1;\r\n      rtIOStreamDataPtr->ioMxClassID = mxUINT8_CLASS;\r\n      rtIOStreamDataPtr->ioDataSize = sizeof(uint8_T);\r\n      rtIOStreamDataPtr->targetRecvBufferSizeBytes = 50000;\r\n      rtIOStreamDataPtr->targetSendBufferSizeBytes = 50000;\r\n\r\n      {\r\n        int errorStatus = rtIOStreamLoadLib(&rtIOStreamDataPtr->libH,\r\n          rtIOStreamDataPtr->lib);\r\n        if (errorStatus) {\r\n          ssSetErrorStatus( S,\"rtIOStreamLoadLib failed.\");\r\n          return false;\r\n        }                              /* if */\r\n      }\r\n\r\n      ssSetPWorkValue(S, 0, rtIOStreamDataPtr);\r\n    }\r\n\r\n    {\r\n      int i;\r\n      for (i=0; i<5; i++) {\r\n        mxDestroyArray(lhs[i]);\r\n      }                                /* for */\r\n    }\r\n  }\r\n\r\n  {\r\n    XIL_IOBuffer_T* IOBufferPtr = (XIL_IOBuffer_T *) mxCalloc(1, sizeof\r\n      (XIL_IOBuffer_T));\r\n    if (IOBufferPtr == NULL) {\r\n      ssSetErrorStatus( S,\"Error in allocating memory through mxCalloc.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(IOBufferPtr);\r\n    ssSetPWorkValue(S, 1, IOBufferPtr);\r\n  }\r\n\r\n  {\r\n    SIL_DEBUGGING_DATA_T* silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T*) mxCalloc\r\n      (1, sizeof(SIL_DEBUGGING_DATA_T));\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return false;\r\n    }\r\n\r\n    if (silDebuggingDataPtr == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory through mxCalloc for SIL_DEBUGGING_DATA_T.\");\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    silDebuggingDataPtr->componentBlockPath = strcpy((char *) mxCalloc(strlen\r\n      (simulinkBlockPath)+1, sizeof(char)), simulinkBlockPath);\r\n    silDebuggingDataPtr->SILPILInterfaceFcnStr = strcpy((char*) mxCalloc(57,\r\n      sizeof(char)), \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    silDebuggingDataPtr->inTheLoopType = 4;\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->componentBlockPath);\r\n    mexMakeMemoryPersistent(silDebuggingDataPtr->SILPILInterfaceFcnStr);\r\n    ssSetPWorkValue(S, 2, silDebuggingDataPtr);\r\n    mxFree((void *) simulinkBlockPath);\r\n  }\r\n\r\n  {\r\n    targetIOFd_T * targetIOFdPtr = (targetIOFd_T *) mxCalloc(1, sizeof\r\n      (targetIOFd_T));\r\n    if (targetIOFdPtr == NULL) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    mexMakeMemoryPersistent(targetIOFdPtr);\r\n    targetIOFdPtr->size = 0;\r\n    targetIOFdPtr->Fd = NULL;\r\n    targetIOFdPtr->fidOffset = -1;\r\n    ssSetPWorkValue(S, 3, targetIOFdPtr);\r\n  }\r\n\r\n  {\r\n    void* pConnectionOptions = NULL;\r\n    void* pComms = NULL;\r\n    void* pXILService = NULL;\r\n    void* pMemUnitTransformer = NULL;\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    uint8_T memUnitSizeBytes = 1;\r\n    uint8_T ioDataTypeSizeBytes = sizeof(uint8_T);\r\n    XIL_RtIOStreamData_T * rtIOStreamDataPtr = (XIL_RtIOStreamData_T *)\r\n      ssGetPWorkValue(S, 0);\r\n    SIL_DEBUGGING_DATA_T * silDebuggingDataPtr = (SIL_DEBUGGING_DATA_T *)\r\n      ssGetPWorkValue(S, 2);\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    void * pCoderAssumptionsApp = NULL;\r\n    if (xilCommsCreate(&pComms, rtIOStreamDataPtr, silDebuggingDataPtr,\r\n                       memUnitSizeBytes, pMemUnitTransformer, pXILUtils, 0) !=\r\n        XILCOMMS_RTIOSTREAM_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    if (xilHostAppSvcCreate(&pXILService, pComms, pXILUtils, IOBufferPtr,\r\n                            memUnitSizeBytes, ioDataTypeSizeBytes, 0) !=\r\n        XILHOSTAPPSVC_SUCCESS) {\r\n      return false;\r\n    }                                  /* if */\r\n\r\n    {\r\n      mxArray * codeGenComponent = mxCreateString(\"DCMotor_Control\");\r\n      mxArray *rhs[3];\r\n      char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n      if (simulinkBlockPath == NULL) {\r\n        ssSetErrorStatus(S,\r\n                         \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n        return false;\r\n      }\r\n\r\n      rhs[ 0 ] = mxCreateString(\r\n        \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n      rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n      rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n      if (coderAssumpHostAppSvcCreate(&pCoderAssumptionsApp, pComms, pXILUtils,\r\n           0, 1, codeGenComponent, rhs[0], rhs[1], rhs[2], 1, 0, 1) !=\r\n          CODERASSUMPHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      mxFree((void *) simulinkBlockPath);\r\n    }\r\n\r\n    xilCommsRegisterApplication(pComms, pXILService);\r\n    xilCommsRegisterApplication(pComms, pCoderAssumptionsApp);\r\n    ssSetPWorkValue(S, 9, pXILService);\r\n    ssSetPWorkValue(S, 7, pComms);\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n    ssSetPWorkValue(S, 10, pCoderAssumptionsApp);\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return false;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_INIT_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return false;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return false;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n\r\n#define RESPONSE_TYPE_SIZE             7\r\n\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return false;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               case RESPONSE_TYPE_SIZE:\r\n                {\r\n                  uint8_T typeBytes;\r\n                  uint8_T typeId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  typeBytes = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (typeId) {\r\n                   case SS_SINGLE:\r\n                    {\r\n                      if (typeBytes != 4) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:SingleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(4);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   case SS_DOUBLE:\r\n                    {\r\n                      if (typeBytes != 8) {\r\n                        {\r\n                          void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                          mxArray * rhs[ 3 ];\r\n                          rhs[0] = mxCreateString(\r\n                            \"PIL:pilverification:DoubleUnsupported\");\r\n                          rhs[1] = mxCreateDoubleScalar(8);\r\n                          rhs[2] = mxCreateDoubleScalar(typeBytes);\r\n                          xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n                          return false;\r\n                        }\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownTypeId\");\r\n                        rhs[1] = mxCreateDoubleScalar(typeId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        return false;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return false;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n\r\n  /* initialize parameters */\r\n  processParams(S);\r\n  return true;\r\n}\r\n\r\nstatic void sendInitializeCommand(SimStruct *S)\r\n{\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_INITIALIZE_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnid = 0;\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n              {\r\n                size_t num_elements = 1;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstatic void initializeInfAndMinusInf(void)\r\n{\r\n  typedef struct {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  } LittleEndianIEEEDouble;\r\n\r\n  rtInf = 0.0;\r\n  rtMinusInf = 0.0;\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal1;\r\n\r\n    tmpVal1.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal1.bitVal.words.wordL = 0x00000000U;\r\n    rtInf = tmpVal1.fltVal;\r\n  }\r\n\r\n  {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal2;\r\n\r\n    tmpVal2.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal2.bitVal.words.wordL = 0x00000000U;\r\n    rtMinusInf = tmpVal2.fltVal;\r\n  }\r\n}\r\n\r\nstatic void mdlSystemInitialize(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    int * pIsXILApplicationStartedLocal = (int *) ssGetPWorkValue(S, 5);\r\n    if (pIsXILApplicationStartedLocal == NULL || (*pIsXILApplicationStartedLocal)\r\n        == 0) {\r\n      boolean_T applicationStarted = startAndSetupApplication(S);\r\n      if (!applicationStarted) {\r\n        return;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n\r\n    sendInitializeCommand(S);\r\n  }\r\n}\r\n\r\nstatic void mdlPeriodicOutputUpdate(SimStruct *S, int_T tid);\r\n\r\n/* This function checks the attributes of tunable parameters. */\r\n#define MDL_CHECK_PARAMETERS\r\n#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlCheckParameters(SimStruct *S)\r\n{\r\n}\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSFcnParams(S, 0);            /* Number of expected parameters */\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif\r\n\r\n    if (ssGetErrorStatus(S) != (NULL))\r\n      return;\r\n  } else {\r\n    /* Parameter mismatch will be reported by Simulink */\r\n    return;\r\n  }\r\n\r\n  ssSetNumContStates(S, 0);\r\n  ssSetNumDiscStates(S, 0);\r\n\r\n  /* no support for SimState */\r\n  ssSetSimStateCompliance(S, DISALLOW_SIM_STATE);\r\n\r\n  /* Allow signal dimensions greater than 2 */\r\n  ssAllowSignalsWithMoreThan2D(S);\r\n\r\n  /* Allow fixed-point data types with 33 or more bits */\r\n  ssFxpSetU32BitRegionCompliant(S,1);\r\n  initializeInfAndMinusInf();\r\n  ssSetRTWGeneratedSFcn(S, 2);\r\n  if ((S->mdlInfo->genericFcn != (NULL)) && (!(S->mdlInfo->genericFcn)(S,\r\n        GEN_FCN_CHK_MODELREF_SFUN_HAS_MODEL_BLOCK, -1, (NULL)))) {\r\n    return;\r\n  }\r\n\r\n  slmrInitializeIOPortDataVectors(S, 0, 0);\r\n  if (!ssSetNumInputPorts(S, 0))\r\n    return;\r\n  if (!ssSetNumOutputPorts(S, 0))\r\n    return;\r\n  ssSetAcceptsFcnCallInputs(S);\r\n  ssSetNumSampleTimes(S, 1);\r\n  ssSetParameterTuningCompliance(S, true);\r\n  ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n    DISALLOW_SAMPLE_TIME_INHERITANCE);\r\n  ssSetOptions(S, SS_OPTION_ALLOW_CONSTANT_PORT_SAMPLE_TIME |\r\n               SS_OPTION_SUPPORTS_ALIAS_DATA_TYPES |\r\n               SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME |\r\n               SS_OPTION_CALL_TERMINATE_ON_EXIT);\r\n  slmrRegisterSystemInitializeMethod(S, mdlSystemInitialize);\r\n  slmrRegisterPeriodicOutputUpdateMethod(S, mdlPeriodicOutputUpdate);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S) ) {\r\n    ssSetNumPWork(S, 0);\r\n  } else {\r\n    ssSetNumPWork(S, 11);\r\n  }                                    /* if */\r\n\r\n  ssSetNumRWork(S, 0);\r\n  ssSetNumIWork(S, 0);\r\n  ssSetNumModes(S, 0);\r\n  ssSetNumNonsampledZCs(S, 0);\r\n  ssSetModelReferenceNormalModeSupport(S, MDL_START_AND_MDL_PROCESS_PARAMS_OK);\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  if (S->mdlInfo->genericFcn != (NULL) &&\r\n      ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssRegModelRefMdlInfo(S, (char *)\"DCMotor_Control\", rtMdlInfo_DCMotor_Control,\r\n                         0);\r\n  }\r\n\r\n#endif\r\n\r\n  /* DWork */\r\n  if (!ssRTWGenIsAccelerator(S)) {\r\n    ssSetNumDWork(S, 0);\r\n  }                                    /* if */\r\n\r\n  ssSetNeedAbsoluteTime(S, 1);\r\n}\r\n\r\n#define MDL_SET_INPUT_PORT_SAMPLE_TIME                           /* Change to #undef to remove function */\r\n#if defined(MDL_SET_INPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetInputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* sample times are fully specified, not inherited */\r\n}\r\n\r\n#endif                                 /* MDL_SET_INPUT_PORT_SAMPLE_TIME */\r\n\r\n#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME                          /* Change to #undef to remove function */\r\n#if defined(MDL_SET_OUTPUT_PORT_SAMPLE_TIME) && defined(MATLAB_MEX_FILE)\r\n\r\nstatic void mdlSetOutputPortSampleTime(SimStruct *S, int_T portIdx, real_T\r\n  sampleTime, real_T offsetTime)\r\n{\r\n  /* sample times are fully specified, not inherited */\r\n}\r\n\r\n#endif                                 /* MDL_SET_OUTPUT_PORT_SAMPLE_TIME */\r\n\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  ssSetSampleTime(S, 0, 1e-05);\r\n  ssSetOffsetTime(S, 0, 0);\r\n  return;\r\n}\r\n\r\n#define MDL_SETUP_RUNTIME_RESOURCES                              /* Change to #undef to remove function */\r\n#if defined(MDL_SETUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlSetupRuntimeResources(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  {\r\n    mxArray * error = NULL;\r\n    error = mexCallMATLABWithTrap( 0, NULL, 0, NULL,\r\n      \"rtw.pil.checkEmbeddedCoderInstalled\");\r\n    if (error != NULL) {\r\n      mexCallMATLAB( 0, NULL, 1, &error, \"throw\");\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    mxArray * lhs[1];\r\n    mxArray * error = NULL;\r\n    char * installVersion;\r\n    error = mexCallMATLABWithTrap(1, lhs, 0, NULL, \"rtw.pil.getPILVersion\");\r\n    if (error != NULL) {\r\n      mxDestroyArray(error);\r\n      ssSetErrorStatus( S,\r\n                       \"Failed to determine the installed In-the-Loop version for comparison against the In-the-Loop s-function version (release 9.11 (R2021b)_15). To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory).\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (mxIsEmpty(lhs[0])) {\r\n      ssSetErrorStatus( S,\"rtw.pil.getPILVersion returned empty!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    installVersion = mxArrayToString(lhs[0]);\r\n    mxDestroyArray(lhs[0]);\r\n    if (installVersion == NULL) {\r\n      ssSetErrorStatus( S,\"Failed to determine installed In-the-Loop version.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (strcmp(installVersion, \"9.11 (R2021b)_15\") != 0) {\r\n      ssSetErrorStatus( S,\r\n                       \"The In-the-Loop s-function is incompatible with the installed In-the-Loop version (see ver('matlab')); it was generated for release 9.11 (R2021b)_15. To avoid this error, remove the In-the-Loop s-function from your MATLAB path (e.g. delete it or move to a clean working directory)\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    mxFree(installVersion);\r\n  }\r\n\r\n  {\r\n    int retValXILUtils = XIL_UTILS_SUCCESS;\r\n    void* pXILUtils = NULL;\r\n    retValXILUtils = xilSimulinkUtilsCreate(&pXILUtils, S);\r\n    if (retValXILUtils!=XIL_UTILS_SUCCESS) {\r\n      ssSetErrorStatus( S,\"Error instantiating XIL Utils!\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    ssSetPWorkValue(S, 6, pXILUtils);\r\n  }\r\n\r\n  {\r\n    int * pCommErrorOccurred = (int *) mxCalloc(1, sizeof(int));\r\n    if (pCommErrorOccurred == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pCommErrorOccurred through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pCommErrorOccurred = 0;\r\n    mexMakeMemoryPersistent(pCommErrorOccurred);\r\n    ssSetPWorkValue(S, 4, pCommErrorOccurred);\r\n  }\r\n\r\n  {\r\n    int * pIsXILApplicationStarted = (int *) mxCalloc(1, sizeof(int));\r\n    if (pIsXILApplicationStarted == NULL) {\r\n      ssSetErrorStatus( S,\r\n                       \"Error in allocating memory for pIsXILApplicationStarted through mxCalloc.\");\r\n      return;\r\n    }                                  /* if */\r\n\r\n    *pIsXILApplicationStarted = 0;\r\n    mexMakeMemoryPersistent(pIsXILApplicationStarted);\r\n    ssSetPWorkValue(S, 5, pIsXILApplicationStarted);\r\n  }\r\n\r\n  {\r\n    mxArray *rhs[4];\r\n    mxArray *lhs[2];\r\n    char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n    if (simulinkBlockPath == NULL) {\r\n      ssSetErrorStatus(S,\r\n                       \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n      return;\r\n    }\r\n\r\n    rhs[ 0 ] = mxCreateString(\r\n      \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n    rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n    rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n    rhs[3] = mxCreateString(ssGetPath(ssGetRootSS(S)));\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (xilUtilsCallMATLAB(pXILUtils, 2, lhs, 4, rhs,\r\n                             \"rtw.pil.SILPILInterface.sfunctionInitializeHook\")\r\n          !=XIL_UTILS_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      char * rootLoggingPath;\r\n      rootLoggingPath = mxArrayToString(lhs[1]);\r\n      mxFree((void *) simulinkBlockPath);\r\n      mxFree(rootLoggingPath);\r\n    }\r\n\r\n    mxDestroyArray(lhs[0]);\r\n    mxDestroyArray(lhs[1]);\r\n  }\r\n}\r\n\r\n#endif                                 /* MDL_SETUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_SIM_STATUS_CHANGE                                    /* Change to #undef to remove function */\r\n#if defined(MDL_SIM_STATUS_CHANGE)\r\n\r\nstatic void mdlSimStatusChange(SimStruct *S, ssSimStatusChangeType simStatus)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  if (simStatus == SIM_PAUSE) {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n      if (IOBufferPtr != NULL) {\r\n        void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n        if (pXILService != NULL) {\r\n          if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return ;\r\n          }                            /* if */\r\n\r\n          if (IOBufferPtr->data != NULL) {\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n            /* write command id */\r\n            *mxMemUnitPtr = (uint8_T) XIL_PAUSE_COMMAND;\r\n            mxMemUnitPtr++;\r\n\r\n            {\r\n              {\r\n                uint8_T * simDataMemUnitPtr;\r\n                uint32_T commandDataFcnid = 0;\r\n                simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                {\r\n                  size_t num_elements = 1;\r\n\r\n                  {\r\n                    copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                               num_elements, sizeof(uint32_T));\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }\r\n\r\n    {\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n        /* dispatch command to the target */\r\n        if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        {\r\n          XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n          while (commandResponseType != XIL_STEP_COMPLETE) {\r\n            /* receive command from the target */\r\n            mwSize dataInSize = 0;\r\n            if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              return ;\r\n            }                          /* if */\r\n\r\n            if (dataInSize>0) {\r\n              size_t dataInMemUnitSize = dataInSize;\r\n              uint8_T responseId = 0;\r\n              uint8_T * mxMemUnitPtrEnd;\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n              mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n              while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                /* read response id */\r\n                responseId = *mxMemUnitPtr;\r\n                mxMemUnitPtr++;\r\n                switch (responseId) {\r\n                 case RESPONSE_ERROR:\r\n                 case RESPONSE_PRINTF:\r\n                 case RESPONSE_FOPEN:\r\n                 case RESPONSE_FPRINTF:\r\n                 case RESPONSE_SIGNAL_RAISED:\r\n                  {\r\n                    if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                         &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                      return ;\r\n                    }                  /* if */\r\n                    break;\r\n                  }\r\n\r\n                 default:\r\n                  {\r\n                    {\r\n                      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                      mxArray * rhs[ 2 ];\r\n                      rhs[0] = mxCreateString(\r\n                        \"PIL:pilverification:UnknownResponseId\");\r\n                      rhs[1] = mxCreateDoubleScalar(responseId);\r\n                      xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                      return ;\r\n                    }\r\n                    break;\r\n                  }\r\n                }                      /* switch */\r\n              }                        /* while */\r\n            }                          /* if */\r\n          }                            /* while */\r\n        }\r\n      }\r\n    }\r\n\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      if (pXILUtils) {\r\n        mxArray *rhs[3];\r\n        char * simulinkBlockPath = getSimulinkBlockPath(S);\r\n        if (simulinkBlockPath == NULL) {\r\n          ssSetErrorStatus(S,\r\n                           \"ModelBlock SIL/PIL unexpected error: getSimulinkBlockPath returned NULL pointer. Check search string was found in ssGetPath.\\n\");\r\n          return;\r\n        }\r\n\r\n        rhs[ 0 ] = mxCreateString(\r\n          \"@coder.connectivity.SimulinkInterface.getSILPILInterface\");\r\n        rhs[ 1 ] = mxCreateDoubleScalar( 4 );\r\n        rhs[ 2 ] = mxCreateString(simulinkBlockPath);\r\n        if (xilUtilsCallMATLAB(pXILUtils, 0, NULL, 3, rhs,\r\n                               \"rtw.pil.SILPILInterface.sfunctionPILPauseHook\")\r\n            != XIL_UTILS_SUCCESS) {\r\n          return ;\r\n        }                              /* if */\r\n\r\n        mxFree((void *) simulinkBlockPath);\r\n      }                                /* if */\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SIM_STATUS_CHANGE */\r\n\r\nstatic void XILoutputTID01(SimStruct *S, int tid)\r\n{\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    if (IOBufferPtr != NULL) {\r\n      void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n      if (pXILService != NULL) {\r\n        if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 9, 0)!=\r\n            XILHOSTAPPSVC_SUCCESS) {\r\n          return;\r\n        }                              /* if */\r\n\r\n        if (IOBufferPtr->data != NULL) {\r\n          mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n          /* write command id */\r\n          *mxMemUnitPtr = (uint8_T) XIL_OUTPUT_COMMAND;\r\n          mxMemUnitPtr++;\r\n\r\n          {\r\n            {\r\n              uint8_T * simDataMemUnitPtr;\r\n              uint32_T commandDataFcnidTID[2] = { 0, 1 };\r\n\r\n              simDataMemUnitPtr = (uint8_T *) &commandDataFcnidTID[0];\r\n\r\n              {\r\n                size_t num_elements = 2;\r\n\r\n                {\r\n                  copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                             num_elements, sizeof(uint32_T));\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }                              /* if */\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  {\r\n    {\r\n      uint8_T * mxMemUnitPtr;\r\n      mwSize dataInSize = 0;\r\n      XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n      /* dispatch command to the target */\r\n      if (commandDispatch(S, IOBufferPtr, 9)!=XILHOSTAPPSVC_SUCCESS) {\r\n        return;\r\n      }                                /* if */\r\n\r\n      {\r\n        XILCommandResponseType commandResponseType = XIL_COMMAND_NOT_COMPLETE;\r\n        while (commandResponseType != XIL_STEP_COMPLETE) {\r\n          /* receive command from the target */\r\n          mwSize dataInSize = 0;\r\n          if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n              XILHOSTAPPSVC_SUCCESS) {\r\n            return;\r\n          }                            /* if */\r\n\r\n          if (dataInSize>0) {\r\n            size_t dataInMemUnitSize = dataInSize;\r\n            uint8_T responseId = 0;\r\n            uint8_T * mxMemUnitPtrEnd;\r\n            mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n            mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n            while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n              /* read response id */\r\n              responseId = *mxMemUnitPtr;\r\n              mxMemUnitPtr++;\r\n              switch (responseId) {\r\n               case RESPONSE_ERROR:\r\n               case RESPONSE_PRINTF:\r\n               case RESPONSE_FOPEN:\r\n               case RESPONSE_FPRINTF:\r\n               case RESPONSE_SIGNAL_RAISED:\r\n                {\r\n                  if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                       &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                    return;\r\n                  }                    /* if */\r\n                  break;\r\n                }\r\n\r\n               default:\r\n                {\r\n                  {\r\n                    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                    mxArray * rhs[ 2 ];\r\n                    rhs[0] = mxCreateString(\r\n                      \"PIL:pilverification:UnknownResponseId\");\r\n                    rhs[1] = mxCreateDoubleScalar(responseId);\r\n                    xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                    return;\r\n                  }\r\n                  break;\r\n                }\r\n              }                        /* switch */\r\n            }                          /* while */\r\n          }                            /* if */\r\n        }                              /* while */\r\n      }\r\n    }\r\n  }\r\n\r\n  {\r\n    uint8_T * mxMemUnitPtr;\r\n    mwSize dataInSize = 0;\r\n    XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n    mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n    if (dataInSize>0) {\r\n      size_t dataInMemUnitSize = dataInSize;\r\n      uint8_T responseId = 0;\r\n      uint8_T * mxMemUnitPtrEnd;\r\n      mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n      mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n      while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n        /* read response id */\r\n        responseId = *mxMemUnitPtr;\r\n        mxMemUnitPtr++;\r\n        switch (responseId) {\r\n         case RESPONSE_ERROR:\r\n         case RESPONSE_PRINTF:\r\n         case RESPONSE_FOPEN:\r\n         case RESPONSE_FPRINTF:\r\n         case RESPONSE_SIGNAL_RAISED:\r\n          {\r\n            if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                 &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n              return;\r\n            }                          /* if */\r\n            break;\r\n          }\r\n\r\n         default:\r\n          {\r\n            {\r\n              void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n              mxArray * rhs[ 2 ];\r\n              rhs[0] = mxCreateString(\"PIL:pilverification:UnknownResponseId\");\r\n              rhs[1] = mxCreateDoubleScalar(responseId);\r\n              xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        }                              /* switch */\r\n      }                                /* while */\r\n    }                                  /* if */\r\n  }\r\n}\r\n\r\n#define MDL_PROCESS_PARAMETERS\r\n#if defined(MDL_PROCESS_PARAMETERS)\r\n\r\nstatic void mdlProcessParameters(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  processParams(S);\r\n}\r\n\r\n#endif                                 /* MDL_PROCESS_PARAMETERS */\r\n\r\n#define MDL_SET_WORK_WIDTHS                                      /* Change to #undef to remove function */\r\n#if defined(MDL_SET_WORK_WIDTHS)\r\n\r\nstatic void mdlSetWorkWidths(SimStruct *S)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    if (S->mdlInfo->genericFcn != (NULL)) {\r\n      _GenericFcn fcn = S->mdlInfo->genericFcn;\r\n      ssSetSignalSizesComputeType(S, SS_VARIABLE_SIZE_FROM_INPUT_VALUE_AND_SIZE);\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_SET_WORK_WIDTHS */\r\n\r\nstatic void mdlPeriodicOutputUpdate(SimStruct *S, int_T tid)\r\n{\r\n  /* Periodic Output Update sample time matching */\r\n  /* check for sample time hit associated with task 1 */\r\n  if (tid == 0) {\r\n    XILoutputTID01(S, tid);\r\n  }                                    /* if */\r\n}\r\n\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  /* Singlerate scheduling */\r\n  /* check for sample time hit associated with task 1 */\r\n  if (ssIsSampleHit(S, 0, tid)) {\r\n    XILoutputTID01(S, tid);\r\n  }                                    /* if */\r\n}\r\n\r\n#define MDL_UPDATE\r\n#if defined(MDL_UPDATE)\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n}\r\n\r\n#endif\r\n\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n  int commErrorOccurred = 0;\r\n  int isXILApplicationStarted = 0;\r\n\r\n  {\r\n    if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n      return;\r\n    }                                  /* if */\r\n\r\n    if (ssGetPWork(S) != NULL) {\r\n      int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n      int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n      if (pCommErrorOccurred != NULL) {\r\n        commErrorOccurred = *pCommErrorOccurred;\r\n      }                                /* if */\r\n\r\n      if (pIsXILApplicationStarted != NULL) {\r\n        isXILApplicationStarted = *pIsXILApplicationStarted;\r\n      }                                /* if */\r\n    }                                  /* if */\r\n  }\r\n\r\n  if (isXILApplicationStarted) {\r\n    if (!commErrorOccurred) {\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 5, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_TERMINATE_COMMAND;\r\n              mxMemUnitPtr++;\r\n\r\n              {\r\n                {\r\n                  uint8_T * simDataMemUnitPtr;\r\n                  uint32_T commandDataFcnid = 0;\r\n                  simDataMemUnitPtr = (uint8_T *) &commandDataFcnid;\r\n\r\n                  {\r\n                    size_t num_elements = 1;\r\n\r\n                    {\r\n                      copyIOData(mxMemUnitPtr, simDataMemUnitPtr, &mxMemUnitPtr,\r\n                                 num_elements, sizeof(uint32_T));\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 5)!=XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n\r\n          {\r\n            XILCommandResponseType commandResponseType =\r\n              XIL_COMMAND_NOT_COMPLETE;\r\n            while (commandResponseType != XIL_STEP_COMPLETE) {\r\n              /* receive command from the target */\r\n              mwSize dataInSize = 0;\r\n              if (commandResponse(S, &dataInSize, &commandResponseType) !=\r\n                  XILHOSTAPPSVC_SUCCESS) {\r\n                callStopHookAndFreeSFcnMemory(S);\r\n                return;\r\n              }                        /* if */\r\n\r\n              if (dataInSize>0) {\r\n                size_t dataInMemUnitSize = dataInSize;\r\n                uint8_T responseId = 0;\r\n                uint8_T * mxMemUnitPtrEnd;\r\n                mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n                mxMemUnitPtrEnd = mxMemUnitPtr + dataInMemUnitSize - 1;\r\n                while (mxMemUnitPtr <= mxMemUnitPtrEnd) {\r\n                  /* read response id */\r\n                  responseId = *mxMemUnitPtr;\r\n                  mxMemUnitPtr++;\r\n                  switch (responseId) {\r\n                   case RESPONSE_ERROR:\r\n                   case RESPONSE_PRINTF:\r\n                   case RESPONSE_FOPEN:\r\n                   case RESPONSE_FPRINTF:\r\n                   case RESPONSE_SIGNAL_RAISED:\r\n                    {\r\n                      if (processErrorAndTargetIOResponseCases(S, responseId,\r\n                           &mxMemUnitPtr)== XILHOSTAPPSVC_ERROR) {\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }                /* if */\r\n                      break;\r\n                    }\r\n\r\n                   default:\r\n                    {\r\n                      {\r\n                        void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n                        mxArray * rhs[ 2 ];\r\n                        rhs[0] = mxCreateString(\r\n                          \"PIL:pilverification:UnknownResponseId\");\r\n                        rhs[1] = mxCreateDoubleScalar(responseId);\r\n                        xilUtilsHandleError(pXILUtils, 2 , rhs );\r\n                        callStopHookAndFreeSFcnMemory(S);\r\n                        return;\r\n                      }\r\n                      break;\r\n                    }\r\n                  }                    /* switch */\r\n                }                      /* while */\r\n              }                        /* if */\r\n            }                          /* while */\r\n          }\r\n        }\r\n      }\r\n\r\n      {\r\n        uint8_T * mxMemUnitPtr;\r\n        mwSize dataInSize = 0;\r\n        XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n        if (IOBufferPtr != NULL) {\r\n          void * pXILService = (void *) ssGetPWorkValue(S, 9);\r\n          if (pXILService != NULL) {\r\n            if (xilHostAppSvcGrowIOBuffer(pXILService, IOBufferPtr, 1, 0)!=\r\n                XILHOSTAPPSVC_SUCCESS) {\r\n              callStopHookAndFreeSFcnMemory(S);\r\n              return;\r\n            }                          /* if */\r\n\r\n            if (IOBufferPtr->data != NULL) {\r\n              mxMemUnitPtr = (uint8_T *) IOBufferPtr->data;\r\n\r\n              /* write command id */\r\n              *mxMemUnitPtr = (uint8_T) XIL_SHUTDOWN_COMMAND;\r\n              mxMemUnitPtr++;\r\n            }                          /* if */\r\n          }                            /* if */\r\n        }                              /* if */\r\n      }\r\n\r\n      {\r\n        {\r\n          uint8_T * mxMemUnitPtr;\r\n          mwSize dataInSize = 0;\r\n          XIL_IOBuffer_T * IOBufferPtr = (XIL_IOBuffer_T *) ssGetPWorkValue(S, 1);\r\n\r\n          /* dispatch command to the target */\r\n          if (commandDispatch(S, IOBufferPtr, 1)!=XILHOSTAPPSVC_SUCCESS) {\r\n            callStopHookAndFreeSFcnMemory(S);\r\n            return;\r\n          }                            /* if */\r\n        }\r\n      }\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  callStopHookAndFreeSFcnMemory(S);\r\n}\r\n\r\n#define MDL_CLEANUP_RUNTIME_RESOURCES                            /* Change to #undef to remove function */\r\n#if defined(MDL_CLEANUP_RUNTIME_RESOURCES)\r\n\r\nstatic void mdlCleanupRuntimeResources(SimStruct *S)\r\n{\r\n  mdlTerminate(S);\r\n  if (ssRTWGenIsCodeGen(S) || ssIsExternalSim(S)) {\r\n    return;\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    int * pIsXILApplicationStarted = (int *) ssGetPWorkValue(S, 5);\r\n    int * pCommErrorOccurred = (int *) ssGetPWorkValue(S, 4);\r\n    if (pIsXILApplicationStarted != NULL) {\r\n      mxFree(pIsXILApplicationStarted);\r\n      ssSetPWorkValue(S, 5, NULL);\r\n    }                                  /* if */\r\n\r\n    if (pCommErrorOccurred != NULL) {\r\n      mxFree(pCommErrorOccurred);\r\n      ssSetPWorkValue(S, 4, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n\r\n  if (ssGetPWork(S) != NULL) {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    if (pXILUtils != NULL) {\r\n      xilUtilsDestroy(pXILUtils);\r\n      ssSetPWorkValue(S, 6, NULL);\r\n    }                                  /* if */\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_CLEANUP_RUNTIME_RESOURCES */\r\n\r\n#define MDL_ENABLE\r\n#if defined(MDL_ENABLE)\r\n\r\nstatic void mdlEnable(SimStruct *S)\r\n{\r\n  if (ssGetT(S) != ssGetTStart(S)) {\r\n    {\r\n      void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n      mxArray * rhs[ 3 ];\r\n      rhs[0] = mxCreateString(\"PIL:pil:EnableDisableCallbackError\");\r\n      rhs[1] = mxCreateString(\"enable\");\r\n      rhs[2] = mxCreateString(\"enable\");\r\n      xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n      return;\r\n    }\r\n  }                                    /* if */\r\n}\r\n\r\n#endif                                 /* MDL_ENABLE */\r\n\r\n#define MDL_DISABLE\r\n#if defined(MDL_DISABLE)\r\n\r\nstatic void mdlDisable(SimStruct *S)\r\n{\r\n  {\r\n    void * pXILUtils = (void *) ssGetPWorkValue(S, 6);\r\n    mxArray * rhs[ 3 ];\r\n    rhs[0] = mxCreateString(\"PIL:pil:EnableDisableCallbackError\");\r\n    rhs[1] = mxCreateString(\"disable\");\r\n    rhs[2] = mxCreateString(\"disable\");\r\n    xilUtilsHandleError(pXILUtils, 3 , rhs );\r\n    return;\r\n  }\r\n}\r\n\r\n#endif                                 /* MDL_DISABLE */\r\n\r\n/* Required S-function trailer */\r\n#ifdef MATLAB_MEX_FILE                 /* Is this file being compiled as a MEX-file? */\r\n#include \"simulink.c\"                  /* MEX-file interface mechanism */\r\n#include \"fixedpoint.c\"\r\n#else\r\n#error Assertion failed: file must be compiled as a MEX-file\r\n#endif\r\n"},{"name":"XILTgtAppSvc.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_h\n#define XILTgtAppSvc_h\n\n#include \"XILTgtAppSvc_spec.h\"\n#include \"rtwtypes.h\"\n\n#if defined (USING_CS_API) || defined(BUILDING_LIBMWCODER_XILTGTAPPSVC)\n       \n    typedef uint8_T IOUnit_T;   \n#else\n   \n    #include \"xilcomms_rtiostream.h\"\n#endif\n       \n#ifdef USE_XILTGTAPPSVC_ERROR\n    static const boolean_T XILTGTAPPSVC_ERROR = 0;\n#endif\n#ifdef USE_XILTGTAPPSVC_SUCCESS\n    static const boolean_T XILTGTAPPSVC_SUCCESS = 1;\n#endif\n\n#define XIL_RTIOSTREAM_BASED_SERVICE_ID 1\ntypedef enum {XIL_COMMAND_NOT_COMPLETE=0,\n              XIL_COMMAND_COMPLETE,\n              XIL_STEP_COMPLETE} XILCommandResponseType;\n             \n#endif\n"},{"name":"XILTgtAppSvc_CInterface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\extern\\include\\coder\\connectivity\\XILTgtAppSvc","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2015 The MathWorks, Inc. */\n\n#ifndef XILTgtAppSvc_CInterface_h\n#define XILTgtAppSvc_CInterface_h\n\n#include \"XILTgtAppSvc.h\"\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcCreate(void);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcDestroy(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T* xilTgtAppSvcGetReceivedData(uint16_T* size);\n\nXILTGTAPPSVC_API_EXTERN_C void xilTgtAppSvcFreeLastReceivedData(void);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcAllocBuffer(void** ppBuf,\n        const uint16_T size);\n\nXILTGTAPPSVC_API_EXTERN_C IOUnit_T* xilTgtAppSvcGetBufferDataPtr(void* pBufVoid);\n\nXILTGTAPPSVC_API_EXTERN_C uint8_T xilTgtAppSvcSend(void* pBufVoid,\n        const uint16_T payloadSize);\n\nXILTGTAPPSVC_API_EXTERN_C uint16_T xilTgtAppSvcGetMaxPayloadCapacity(void);\n\n#endif\n"},{"name":"coder_assumptions_app.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"coder_assumptions_app.h\"\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n\n/*\n * Include coder_assumptions.h for Hardware Implementation setting\n * preprocessor validation checks.\n * These checks verify fundamental data types that the comms \n * stack relies on, e.g. uint8_T, uint16_T, uint32_T.\n *\n * Also access the global results variables and the entry point\n * function for running coder assumptions tests.\n */\n#include \"coder_assumptions.h\" \n\n/* combine arguments (after expanding arguments) */\n#define CA_EXP_CONCAT(a,b) CA_CONCAT(a,b)\n#define CA_CONCAT(a,b) a ## b\n\n/* Compile time static assert for checking fundamental assumptions such \n * as sizeof values for specific data types. */\n#define CA_STATIC_ASSERT(expr, msg) typedef char CA_EXP_CONCAT(assert_failed__, msg) [(expr) ? (+1) : (-1)]\n\n#define CA_RETURN_IF_ERROR(errCode) if((errCode) != XIL_DATA_STREAM_SUCCESS) return (errCode)\n\n#include \"coder_assumptions_hwimpl.h\"\n\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* MemUnit_T can be any of uint8_T, uint16_T, uint32_T\n    * Just check it is consistent with MEM_UNIT_BYTES */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == MEM_UNIT_BYTES, INVALID_MEMUNIT_T);\n#else\n   /* Verify MemUnit_T: sizeof must be 1 */\n   CA_STATIC_ASSERT(sizeof(MemUnit_T) == 1, MEMUNIT_T_NOT_SIZEOF_1);\n   /* Verify MEM_UNIT_BYTES: must match the size of the largest integer that has sizeof == 1 \n    * Only word addressable targets up to 32-bits are supported. */\n   CA_STATIC_ASSERT((sizeof(uint32_T) == 1) ? MEM_UNIT_BYTES == 4 : \n                 (sizeof(uint16_T) == 1) ? MEM_UNIT_BYTES == 2 :\n                 (sizeof(uint8_T) == 1) ? MEM_UNIT_BYTES == 1 : 0, INVALID_MEM_UNIT_BYTES);\n#endif\n                 \n#include \"coder_assumptions_shared_enums.h\"\n\nstatic MemUnit_T pwsEnabled;\n\n\nstatic XIL_DATA_STREAM_ERROR_CODE sendResult(const CA_TestResult result, \n                                             const MemUnit_T resultType, \n                                             const MemUnit_T actual, \n                                             const MemUnit_T assumed) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode;\n   MemUnit_T tmp;\n   /* send result type */\n   errorCode = coderAssumptionsWriteData(&resultType, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send result status */\n   tmp = (MemUnit_T) result.status;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* send result msg id */\n   tmp = (MemUnit_T) result.msg;\n   errorCode = coderAssumptionsWriteData(&tmp, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send actual */\n   errorCode = coderAssumptionsWriteData(&actual, sizeof(MemUnit_T));   \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* send assumed */\n   errorCode = coderAssumptionsWriteData(&assumed, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* final return */\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE transmitMemUnitBytes(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode; \n   const MemUnit_T memUnitBytes = MEM_UNIT_BYTES;\n\n   /* send memUnitBytes */\n   errorCode = coderAssumptionsWriteData(&memUnitBytes, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n    \n   errorCode = coderAssumptionsSendWriteBuffer();  \n   CA_RETURN_IF_ERROR(errorCode);\n   \n   return errorCode;\n}\n\n/* portable word sizes specified checks */\nstatic XIL_DATA_STREAM_ERROR_CODE sendPWS(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode; \n    MemUnit_T commandId;  \n   \n    /* send CA_PWS */\n    commandId = CA_PWS;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    \n    /* PWS enabled in build */\n    commandId = CA_PWS_ENABLED;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    pwsEnabled = (MemUnit_T) CA_Actual_HWImpl.portableWordSizes;\n    errorCode = coderAssumptionsWriteData(&pwsEnabled, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* extended PWS checks */\n    if (pwsEnabled) {\n       /* config setting mismatch */\n       errorCode = sendResult(CA_PortableWordSizes_Results.configSetting, \n                                    (MemUnit_T) CA_PWS_CONFIG_SETTING,  \n                                    (MemUnit_T) CA_Actual_HWImpl.portableWordSizes, \n                                    (MemUnit_T) CA_Expected_HWImpl.portableWordSizes);\n       CA_RETURN_IF_ERROR(errorCode);\n    }\n\n\n    errorCode = coderAssumptionsSendWriteBuffer();  \n    CA_RETURN_IF_ERROR(errorCode);\n\n    return errorCode;\n}\n\n/* hardware implementation checks message 1 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl1(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;    \n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_1 */    \n   commandId = CA_HW_IMPL_SIZES_1;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per char */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerChar, \n         (MemUnit_T) CA_HW_IMPL_BIT_CHAR,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerChar, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerChar);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per short */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerShort, \n         (MemUnit_T) CA_HW_IMPL_BIT_SHORT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerShort, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerShort);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per int */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerInt, \n         (MemUnit_T) CA_HW_IMPL_BIT_INT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerInt, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerInt);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 2 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl2(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n   \n   /* send CA_HW_IMPL_SIZES_2 */    \n   commandId = CA_HW_IMPL_SIZES_2;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* support long long */\n   errorCode = sendResult(CA_HWImpl_Results.supportLongLong, \n         (MemUnit_T) CA_HW_IMPL_SUPPORT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.supportLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.supportLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per long long */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerLongLong, \n         (MemUnit_T) CA_HW_IMPL_BIT_LONGLONG,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerLongLong, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerLongLong);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per float */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerFloat, \n         (MemUnit_T) CA_HW_IMPL_BIT_FLOAT,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerFloat, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerFloat);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per double */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerDouble, \n         (MemUnit_T) CA_HW_IMPL_BIT_DOUBLE,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerDouble, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerDouble);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation checks message 3 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl3(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_3 */    \n   commandId = CA_HW_IMPL_SIZES_3;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per pointer */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPointer, \n         (MemUnit_T) CA_HW_IMPL_BIT_POINTER,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPointer, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPointer);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per size_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerSizeT, \n         (MemUnit_T) CA_HW_IMPL_BIT_SIZE_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerSizeT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerSizeT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* bit per ptrdiff_t */\n   errorCode = sendResult(CA_HWImpl_Results.bitsPerPtrDiffT, \n         (MemUnit_T) CA_HW_IMPL_BIT_PTRDIFF_T,  \n         (MemUnit_T) CA_Actual_HWImpl.bitsPerPtrDiffT, \n         (MemUnit_T) CA_Expected_HWImpl.bitsPerPtrDiffT);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n\n/* hardware implementation checks message 4 */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHWImpl4(void) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   MemUnit_T commandId;\n\n   /* send CA_HW_IMPL_SIZES_4 */\n   commandId = CA_HW_IMPL_SIZES_4;\n   errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* byte order */\n   errorCode = sendResult(CA_HWImpl_Results.byteOrder, \n         (MemUnit_T) CA_HW_IMPL_BYTE_ORDER,  \n         (MemUnit_T) CA_Actual_HWImpl.byteOrder, \n         (MemUnit_T) CA_Expected_HWImpl.byteOrder);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* integer division rounding */\n   errorCode = sendResult(CA_HWImpl_Results.intDivRoundTo, \n         (MemUnit_T) CA_HW_IMPL_INT_DIV_ROUND,  \n         (MemUnit_T) CA_Actual_HWImpl.intDivRoundTo, \n         (MemUnit_T) CA_Expected_HWImpl.intDivRoundTo);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* shift right on a signed integer */\n   errorCode = sendResult(CA_HWImpl_Results.shiftRightBehavior, \n         (MemUnit_T) CA_HW_IMPL_SHIFT_RIGHT,  \n         (MemUnit_T) CA_Actual_HWImpl.shiftRightBehavior, \n         (MemUnit_T) CA_Expected_HWImpl.shiftRightBehavior);\n   CA_RETURN_IF_ERROR(errorCode);\n\n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\n/* hardware implementation, checks unrelated to sizes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendHardwareChecks(void){\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n    MemUnit_T commandId;\n\n    commandId = CA_CHECKS_1;\n    errorCode = coderAssumptionsWriteData(&commandId, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n\n   /* memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.memoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_MEMORY_STARTUP,\n         (MemUnit_T) CA_Actual_HWImpl.memoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.memoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* dynamic memory at startup */\n   errorCode = sendResult(CA_HWImpl_Results.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_HW_IMPL_DYNAMIC_MEMORY,\n         (MemUnit_T) CA_Actual_HWImpl.dynamicMemoryAtStartup,\n         (MemUnit_T) CA_Expected_HWImpl.dynamicMemoryAtStartup);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal flush to zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalFlushToZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_FTZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalFlushToZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalFlushToZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* denormal as zero */\n   errorCode = sendResult(CA_HWImpl_Results.denormalAsZero,\n         (MemUnit_T) CA_HW_IMPL_DENORMAL_DAZ,\n         (MemUnit_T) CA_Actual_HWImpl.denormalAsZero,\n         (MemUnit_T) CA_Expected_HWImpl.denormalAsZero);\n   CA_RETURN_IF_ERROR(errorCode);\n   \n   /* transmit message */\n   errorCode = coderAssumptionsSendWriteBuffer();\n   CA_RETURN_IF_ERROR(errorCode);\n\n   return errorCode;\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE runChecks(void) {\n    XIL_DATA_STREAM_ERROR_CODE errorCode;\n    MemUnit_T endTransmission = CA_END_TRANSMIT;\n\n     /* first, run the coder assumptions checks */\n    CA_Run_Tests();\n\n    /* now send the results to the host */\n    errorCode = transmitMemUnitBytes();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendPWS();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    errorCode = sendHWImpl1();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl2();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl3();\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = sendHWImpl4();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* send results of miscellaneous checks */\n    errorCode = sendHardwareChecks();\n    CA_RETURN_IF_ERROR(errorCode);\n\n    /* let host know all tests have completed */\n    errorCode = coderAssumptionsWriteData(&endTransmission, sizeof(MemUnit_T));\n    CA_RETURN_IF_ERROR(errorCode);\n    errorCode = coderAssumptionsSendWriteBuffer();\n    \n    /* final return */\n    return errorCode;\n}\n\n\n/* \n * XIL interface entry points \n *\n */\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void) {\n   if (runChecks() != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;\n   }\n   else {\n      return XIL_INTERFACE_LIB_SUCCESS;\n   }\n}\n"},{"name":"coder_assumptions_app.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_app.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsRun(void);\n"},{"name":"coder_assumptions_data_stream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_ERROR\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n#include \"coder_assumptions_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API    \n   #define CA_TX_BUFFER_MEMUNIT_SIZE coderAssumpTgtAppSvcGetMaxPayloadCapacity()\n   #define BUFFER_HEADER_SIZE 0    \n#else\n   #include \"rx_tx_buffer_sizes.h\"    \n#endif\n\nstatic void* pBuffer;\nstatic IOUnit_T* coderAssumptionsWriteDataPtr;\nstatic uint16_T coderAssumptionsWriteDataAvail;\n\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n\n   const size_t WRITE_BUFFER_SIZE = CA_TX_BUFFER_MEMUNIT_SIZE - BUFFER_HEADER_SIZE;\n   size_t sizeToTransfer = size;\n\n   /* check to see if buffer will overflow */\n   if ((coderAssumptionsWriteDataAvail + sizeToTransfer) > WRITE_BUFFER_SIZE) {\n      errorCode = XIL_WRITE_DATA_ERROR;\n      return errorCode;\n   }\n\n   /* copy data into write buffer */\n   memcpy((void *) coderAssumptionsWriteDataPtr, src, sizeToTransfer);\n   coderAssumptionsWriteDataAvail += (uint16_T) sizeToTransfer;\n   coderAssumptionsWriteDataPtr += sizeToTransfer;\n\n   return errorCode;\n}\n\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the app will \n     * use for transmission\n     */\n    if (!coderAssumpTgtAppSvcAllocBuffer(&pBuffer, CA_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* set coderAssumptionsWriteDataPtr pointer */\n    coderAssumptionsWriteDataPtr = coderAssumpTgtAppSvcGetBufferDataPtr(pBuffer); \n    \n    /* ready for next command */\n    coderAssumptionsWriteDataAvail = 0;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* send pending writes */\nXIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void) {\n   /* send */\n   if (coderAssumpTgtAppSvcSend(pBuffer, coderAssumptionsWriteDataAvail) == CODERASSUMPTGTAPPSVC_ERROR) {             \n      return XIL_WRITE_DATA_ERROR;\n   }   \n   \n   /* reset */\n   if (resetCoderAssumptionsWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_WRITE_DATA_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void) {    \n    /* Create coder assumptions app service */\n    if (coderAssumpTgtAppSvcCreate() != CODERASSUMPTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n\n   /* Reset write buffer */\n   return resetCoderAssumptionsWriteBuffer();\n}\n\nvoid coderAssumptionsTerminate(void) {      \n   coderAssumpTgtAppSvcDestroy();\n}\n"},{"name":"coder_assumptions_data_stream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2017 The MathWorks, Inc. */\n\n/* \n * File: coder_assumptions_data_stream.h\n *\n */\t\t\t\t\t \n\n#include \"xil_error_codes.h\"\n#include <stddef.h>\n\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsWriteData(const void * src, const size_t size);\nextern XIL_DATA_STREAM_ERROR_CODE coderAssumptionsSendWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE resetCoderAssumptionsWriteBuffer(void);\nextern XIL_INTERFACE_LIB_ERROR_CODE coderAssumptionsInit(void);\nextern void coderAssumptionsTerminate(void);\n"},{"name":"coder_assumptions_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_CODERASSUMPTGTAPPSVC_SUCCESS\n\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"CoderAssumpTgtAppSvc_CInterface.h\"\n\n/* coder assumptions buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T coderAssumpWriteBuffer[CA_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T coderAssumpTgtAppSvcCreate(void) {\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\nextern void coderAssumpTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T coderAssumpTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &coderAssumpWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return CODERASSUMPTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to the coder assumptions buffer data */\nextern IOUnit_T * coderAssumpTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &coderAssumpWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T coderAssumpTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, CODERASSUMP_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"coder_assumptions_shared_enums.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2017-2020 The MathWorks, Inc. */\n\n#ifndef __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n#define __CODER_ASSUMPTIONS_SHARED_ENUMS_H__\n\ntypedef enum {\n   CA_LITTLE_ENDIAN = 0, \n   CA_BIG_ENDIAN, \n   CA_UNSPECIFIED,\n   CA_UNABLE_TO_DETERMINE_ON_TARGET\n} CA_EndianessValue;\n\ntypedef enum {\n   CA_FLOOR = 0,\n   CA_ZERO, \n   CA_UNDEFINED\n} CA_IntDivRoundToValue;\n\ntypedef enum {\n   CA_NOT_RUN = 0,\n   CA_FAIL,\n   CA_PASS, \n   CA_WARN,\n   CA_INFO,\n   CA_SKIP\n} CA_TestResultStatus;\n\ntypedef enum {\n   CA_NO_MSG = 0,\n   CA_WARN_INT_DIV_UNDEFINED,\n   CA_WARN_BYTE_ORDER_UNSPECIFIED,\n   CA_ERROR_PWS_CONFIG_SETTING\n} CA_TestResultMsgId;\n\ntypedef enum {\n   CA_HW_IMPL_SIZES_1=0,\n   CA_HW_IMPL_SIZES_2, \n   CA_HW_IMPL_SIZES_3,\n   CA_HW_IMPL_SIZES_4,\n   CA_CHECKS_1,     /* Results of checks unrelated to hardware sizes. */\n   CA_PWS,\n   CA_END_TRANSMIT  /* Sent when CA transmissions have finished. */\n} CODERASSUMPTIONS_COMMAND;\n\ntypedef enum {\n   CA_HW_IMPL_BIT_CHAR = 0,\n   CA_HW_IMPL_BIT_SHORT,\n   CA_HW_IMPL_BIT_INT, \n   CA_HW_IMPL_BIT_LONG, \n   CA_HW_IMPL_BIT_LONGLONG, \n   CA_HW_IMPL_BIT_FLOAT, \n   CA_HW_IMPL_BIT_DOUBLE, \n   CA_HW_IMPL_BIT_POINTER, \n   CA_HW_IMPL_BIT_SIZE_T, \n   CA_HW_IMPL_BIT_PTRDIFF_T, \n   CA_HW_IMPL_SUPPORT_LONGLONG,\n   CA_HW_IMPL_SHIFT_RIGHT,\n   CA_HW_IMPL_INT_DIV_ROUND,\n   CA_HW_IMPL_BYTE_ORDER,\n   CA_HW_IMPL_MEMORY_STARTUP,\n   CA_HW_IMPL_DYNAMIC_MEMORY,\n   CA_HW_IMPL_DENORMAL_FTZ,\n   CA_HW_IMPL_DENORMAL_DAZ\n} CA_HW_IMPL_RESULT;\n\ntypedef enum {\n   CA_PWS_ENABLED = 0,\n   CA_PWS_CONFIG_SETTING\n} CA_PWS_RESULT;\n\n#endif\n\n"},{"name":"comms_interface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n#ifndef comms_interface_h\n#define comms_interface_h\n\n/* error codes */\n#ifdef USE_COMMS_ERROR\n    static const int COMMS_ERROR = 0;\n#endif\n#ifdef USE_COMMS_SUCCESS\n    static const int COMMS_SUCCESS = 1;\n#endif\n\n/* initialize comm service */\nextern int commsInit(const int argc, void * argv[]);\n\n/* terminate comm service */\nextern int commsTerminate(void);\n\n#endif\n"},{"name":"rtiostream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\rtiostream\\src","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/*\n * Copyright 2007-2012 The MathWorks, Inc.\n *\n * File: rtiostream.h     \n *\n * Abstract:\n *  Function prototypes and defines for rtIOStream API.\n */\n\n#ifndef RTIOSTREAM_H\n#define RTIOSTREAM_H\n\n#include <stddef.h>\n\n#define RTIOSTREAM_ERROR (-1)\n#define RTIOSTREAM_NO_ERROR (0)\n\n/* Note: if the functions declared in this file should be compiled into a shared\n * library (e.g. a .dll file on Windows), you must ensure that the functions are\n * externally visible. The procedure to achieve this depends on the compiler and\n * linker you are using. For example, on Windows, you may need to provide an\n * exports definition .def file that lists all of the functions to be\n * exported; see ./rtiostream/rtiostream_pc.def for a suitable .def file.\n */\n\n#ifndef RTIOSTREAMAPI\n#define RTIOSTREAMAPI \n#endif \n\nRTIOSTREAMAPI int rtIOStreamOpen(\n    int    argc,\n    void * argv[]\n);\n\nRTIOSTREAMAPI int rtIOStreamSend(\n    int          streamID,\n    const void * src, \n    size_t       size,\n    size_t     * sizeSent\n    );\n\nRTIOSTREAMAPI int rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd\n    );\n\nRTIOSTREAMAPI int rtIOStreamClose(\n    int streamID\n    );\n\n\n#endif /* #ifndef RTIOSTREAM_H */\n"},{"name":"rtiostream_tcpip.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\rtiostream\\src\\rtiostreamtcpip","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rtiostream_tcpip.c     \n *\n * Abstract: This source file implements both client-side and server-side TCP/IP\n *  and UDP/IP communication. Typically, this driver is used to support host-target\n *  communication where the client-side device driver runs on the host and the\n *  server-side driver runs on the target. For this implementation, both\n *  client-side and server-side driver code has been combined into a single\n *  file.\n *\n *  If you are using this code as a starting point to implement a TCP/IP or \n *  UDP/IP driver for a custom target it is only necessary to include code \n *  for the server side of the connection.\n */\n\n#ifndef _WIN32\n/* Required BSD Unix extensions are not available by default on certain Unix\n * distributions */\n#define _DEFAULT_SOURCE     /* _DEFAULT_SOURCE must be defined to avoid\n                               _BSD_SOURCE deprecation warning\n                               for glibc >= 2.20 */\n#define _BSD_SOURCE         /* Required to support glibc <= 2.19 */\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include \"rtiostream.h\"\n#include \"tmwtypes.h\"\n\n#ifdef _WIN32\n  /* WINDOWS */\n\n#if defined(_MSC_VER)\n /* temporarily disable warning triggered\n  * by windows.h */\n #pragma warning(push)\n #pragma warning(disable: 4255)\n#endif\n\n#include <windows.h>\n\n#if defined(_MSC_VER)\n /* restore warning */\n #pragma warning(pop)\n#endif\n\n# ifdef __LCC__\n# ifndef __LCC64__\n#   include <winsock2.h>\n# endif\n#   include <errno.h>\n# endif\n\n#define RTIOSTREAM_ECONNRESET WSAECONNRESET\n\n#elif defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n# include <netinet/tcp.h> \n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n\n#else\n  /* UNIX */\n# include <signal.h>\n# include <sys/time.h>      /* Linux */\n# include <sys/types.h>     /* Linux */\n# include <sys/socket.h>\n# include <sys/poll.h>\n# include <netinet/in.h>    /* Linux */\n# include <netinet/tcp.h>   /* Linux */\n# include <arpa/inet.h>     /* Linux */\n# include <netdb.h>\n# include <errno.h>\n# include <fcntl.h>  \n# include <unistd.h>\n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n#endif\n\n#if defined(_WIN32) || defined(VXWORKS)\n#define USE_SELECT  \n#endif\n\n#ifdef USE_MEXPRINTF\n#include \"mex.h\"\n#define printf mexPrintf\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) mexPrintf(FORMAT, ARG1)\n#else\n/* If stdout is redirected to file, it is essential that the port number is \n * available immediately in the output file. With LCC, printf does not flush \n * correctly to the redirected output file - use fprintf & fflush instead. */\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) fprintf(stdout, FORMAT, ARG1); \\\n                                         fflush(stdout)\n#endif\n\n/***************** DEFINES ****************************************************/                                         \n#define HOSTNAME_MAXLEN (64U)\n\n#define SERVER_PORT_NUM  (17725U)   /* sqrt(pi)*10000 */\n\n/* \n * EXT_BLOCKING  \n *\n * Depending on the implementation of the main program (e.g., grt_main.c,\n * rt_main.c), the EXT_BLOCKING flag must be set to either 0 or 1.\n *\n * rt_main.c (tornado/vxworks): rt_main.c is a real-time, multi-tasking target.\n * The upload and packet servers are called via background (low priority) tasks.\n * In this case, it is o.k. for the transport function to block as the blocked\n * tasks will simply be pre-empted in order to enable the model to run.  It is\n * desirable to block instead of to poll to free up the cpu for any other\n * potential work. \n */\n#ifdef VXWORKS\n# define EXT_BLOCKING (1)  \n#else\n# define EXT_BLOCKING (0)  \n#endif\n\n/* timeout of 0 means to return immediately */\n#define BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n/* timeout of -1 means to wait indefinitely */\n#define BLOCKING_RECV_TIMEOUT_NEVER (-1)\n/* rogue value for blocking receive timeout */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT (-2)\n/* timeout of -3 means to wait for 10 ms to avoid high CPU load */\n#define BLOCKING_RECV_TIMEOUT_10MS (-3)\n/* wake up from blocking every second */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT (1) \n/* only wake up from blocking when data arrives */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER (BLOCKING_RECV_TIMEOUT_NEVER)\n/* server wait time for client to close its socket */\n#define BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN (60)\n\n/* define a set of verbosity levels:\n *\n * 0: no verbose output\n * 1: verbose output with data\n * 2: extra verbose output including when data size is zero*/\ntypedef enum {VERBOSITY_LEVEL_0=0, VERBOSITY_LEVEL_1, VERBOSITY_LEVEL_2} VerbosityLevel;\n/* default verbosity value */\n#define DEFAULT_VERBOSITY VERBOSITY_LEVEL_0\n\n/* default protocol value */\n#define DEFAULT_PROTOCOL TCP_PROTOCOL\n/* allowed -protocol strings */\n#define TCP_PROTOCOL_STRING \"TCP\"\n#define UDP_PROTOCOL_STRING \"UDP\"\n#define UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING \"UDP_PACKET_LOSS_DETECTION\"\n\n/* default UDP max packet size \n *\n * The maximum size of UDP packets that are transmitted / received must be\n * consistent on the host and target otherwise receive errors will occur at \n * the side with the smaller buffer size specified.\n *\n * Use the \"-maxudppacketsize SIZE\" argument to specify a different packet size.\n * This option is particularly useful when using a custom server implementation\n * that uses a different max packet size to the default. \n *\n * The maximum UDP payload is 65507 bytes, which can be achieved for localhost\n * based communications on Linux and Windows, but Mac has a lower size of\n * 9216.\n */\n#define UDP_MAX_PACKET_SIZE 9216\n#define DEFAULT_MAX_UDP_PACKET_SIZE UDP_MAX_PACKET_SIZE\n/* increase the UDP socket receive size to decrease the \n * possibility of buffer overflow */\n#define DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST (512 * 1024) \n#define DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST (512 * 1024) \n\n#define DEFAULT_IS_USING_SEQ_NUM 1\n\n#ifdef WIN32\n  /* WINDOWS */\n# define close closesocket\n# define SOCK_ERR SOCKET_ERROR\n#else\n  /* UNIX, VXWORKS */\n# define INVALID_SOCKET (-1)\n# define SOCK_ERR (-1)\n\n  typedef int SOCKET;\n#endif\n\n/*\n * send prototype differs on different platforms. The following typedefs\n * suppress compiler warnings.\n */\n#if defined(WIN32)\ntypedef const char * send_buffer_t;\n#elif defined(VXWORKS)\ntypedef char * send_buffer_t;\n#else\ntypedef const void * send_buffer_t;\n#endif\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n/***************** TYPEDEFS **************************************************/\n\n#if (defined(_WIN32)) || (defined(VXWORKS))\n   /* socklen_t may not be available */\n   typedef int rtiostream_socklen_t;\n#else\n   typedef socklen_t rtiostream_socklen_t;\n#endif\n\n/* Server specific data structure */\ntypedef struct ServerData_tag {\n    int       port;           /* port number associated with the server socket */\n    SOCKET    listenSock;     /* listening socket to accept incoming connections */\n    char      *serverInfoFile; /* the filename that is used to write the server \n                                 port number when dynamic port allocation is used */                      \n} ServerData;\n\n/* UDP send / receive buffer data structure */\ntypedef struct UDPPacketBuffer_tag {\n    char * buffer; /* pointer to the buffer */\n    char * dataPtr; /* pointer to the current position in the buffer */\n    int dataAvail; /* amount of data in the buffer */\n} UDPPacketBuffer;\n\n/* Type for the optional UDP sequence number */\ntypedef uint32_T udpSeqNum_T;\n/* byte size of the UDP sequence number */\n#define UDP_SEQ_NUM_SIZE ((int) sizeof(udpSeqNum_T))\n\n/* UDP specific data structure */\ntypedef struct UDPData_tag {\n   int isUsingSeqNum; /* is this connection using sequence numbers */\n   int maxPacketSize; /* max packet size (buffer size) */\n   UDPPacketBuffer * recvBuffer; /* buffer for an incoming datagram */\n   UDPPacketBuffer * sendBuffer; /* buffer for an outgoing datagram */\n   udpSeqNum_T sendSeqNum; /* sequence number to add to outgoing datagrams */\n   udpSeqNum_T expectedRecvSeqNum; /* expected sequence number in incoming \n                                   datagrams */\n   int resetExpectedRecvSeqNum; /* flags whether to reset expectedRecvSeqNum\n                                   to the sequence number of the next incoming\n                                   datagram */\n} UDPData;\n\n/* enum of supported communications protocols */\ntypedef enum {TCP_PROTOCOL, UDP_PROTOCOL} CommsProtocol;\n\n/* Data encapsulating a single client / server connection  */\ntypedef struct ConnectionData_tag {\n   int isInUse; /* is this ConnectionData instance currently in use? */\n   int isServer; /* is this ConnectionData instance a Server (or client)? */\n   int blockingRecvTimeout; /*    Timeout value in seconds. rtIOStreamRecv \n                                  blocks until at least some of the requested \n                                  data is available or the timeout expires.   \n                                  If a timeout occurs the receiveSize will be 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n                                  means to block for 0 seconds (polling mode). \n                                  rtIOStreamRecv processes \n                                  any pending data or, if no data is available, \n                                  returns immediately with a receiveSize of 0.\n\n                                  A value of BLOCKING_RECV_TIMEOUT_NEVER (-1)\n                                  means to block indefinitely (full blocking \n                                  mode). rtIOStreamRecv blocks\n                                  until at least some of the requested data is \n                                  available.   receiveSize should always be \n                                  greater than 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_10MS (-3)\n                                  means to block for up to 10 ms to avoid high CPU \n                                  load.\n                             */\n   VerbosityLevel verbosity; /* enum indicating the level of verbosity to be displayed on the output */\n   CommsProtocol protocol; /* TCP or UDP protocol */\n   SOCKET sock; /* socket to send/receive packets */\n   ServerData * serverData; /* Server specific data - NULL for clients */\n   UDPData * udpData; /* UDP specific data - NULL for TCP */\n   int udpSendBufSize;\n   int udpRecvBufSize;\n} ConnectionData;\n\n/**************** LOCAL DATA *************************************************/\n\n/* All local data resides in the per client / \n * server instance ConnectionData structures to make sure each connection is\n * completely independent.\n *\n * Each ConnectionData does not use much memory; any optionally required \n * send / recv buffers are dynamically allocated and freed when the ConnectionData \n * actually becomes in use.\n *\n * The static array will be deallocated when the shared library is unloaded. \n *\n * Using an array rather than a linked list allows us to have fast direct lookup\n * of ConnectionData from connectionID during calls to rtIOStreamSend/Recv */\n#define MAX_NUM_CONNECTIONS (50)\nstatic ConnectionData connectionDataArray[MAX_NUM_CONNECTIONS];\n\n/************** LOCAL FUNCTION PROTOTYPES ************************************/\n\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize); \n\nstatic int getConnectionID(void);\n\nstatic ConnectionData * getConnectionData(int connectionID);\n\nstatic void freeConnectionData(ConnectionData * connection);\n\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize);\n\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer);\n\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer);\n\nstatic int processUDPRecvSeqNum(ConnectionData * connection);\n\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen);\n\nstatic int waitForClientClose(ConnectionData * connection);\n\nstatic int socketDataSet(\n    ConnectionData * connection, \n    const void *src,\n    const size_t size,\n    size_t *sizeSent);\n\nstatic int socketDataGet(\n    ConnectionData * connection, \n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd);\n\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending,\n    int timeoutSecs);\n\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd);\n\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol,int udpSendBufSize, int udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize);\n#endif\n\nstatic void serverAcceptSocket(ConnectionData * connection);\n\nstatic int processArgs(\n    const int          argc,\n    void            *  argv[],\n    char           **  hostName, \n    unsigned int    *  portNum,\n    unsigned int    *  isClient,\n    int             *  isBlocking,\n    int             *  recvTimeout, \n    char           **  serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize,\n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName);\n#endif\n\n/*************** LOCAL FUNCTIONS **********************************************/\n\n/* Function: initConnectionData =================================================\n * Abstract:\n *  Initializes a client / server ConnectionData for the specified protocol.\n *\n *  A return value of RTIOSTREAM_ERROR indicates an error.\n */\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   ConnectionData * connection = &connectionDataArray[connectionID];\n  \n   /* initialize the new ConnectionData */\n   connection->isInUse = 1;\n   connection->isServer = isServer;\n   connection->blockingRecvTimeout = blockingRecvTimeout;\n   connection->protocol = protocol;\n   connection->verbosity = verbosity;\n   connection->udpSendBufSize = udpSendBufSize;\n   connection->udpRecvBufSize = udpRecvBufSize;\n   /* initialize to NULL early so that calls to \n    * freeConnectionData on error will succeed */\n   connection->udpData = NULL;\n   connection->serverData = NULL;\n\n   if (connection->protocol == UDP_PROTOCOL) {      \n      /* initialize the UDP data */\n      connection->udpData = (UDPData *) malloc(sizeof(UDPData));\n      if (connection->udpData == NULL) {\n         printf(\"initConnectionData:UDPData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* initialize to NULL */\n      connection->udpData->recvBuffer = NULL;\n      connection->udpData->sendBuffer = NULL;\n      connection->udpData->isUsingSeqNum = isUsingSeqNum;\n      connection->udpData->maxPacketSize = maxPacketSize;\n      /* send sequence numbers always start from 0 */\n      connection->udpData->sendSeqNum = 0;\n      /* initially, seed the expectedRecvSeqNum from the first \n       * received packet */\n      connection->udpData->resetExpectedRecvSeqNum = 1;      \n      connection->udpData->recvBuffer = createUDPPacketBuffer(maxPacketSize);\n      if (connection->udpData->recvBuffer == NULL) {\n         printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (maxPacketSize > UDP_MAX_PACKET_SIZE) {\n         /* packet size cannot exceed the maximum \n          * UDP packet size */\n         printf(\"initConnectionData: udpmaxpacketsize must be less than %d\\n\", UDP_MAX_PACKET_SIZE);\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (connection->udpData->isUsingSeqNum) {\n         /* packet size must be larger than the size\n          * of the sequence number */\n         if (maxPacketSize <= UDP_SEQ_NUM_SIZE) {\n            printf(\"initConnectionData: udpmaxpacketsize must be larger than %d\\n\", UDP_SEQ_NUM_SIZE);\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n         /* send buffer will be required in order to add the sequence\n          * number to the outgoing data */\n         connection->udpData->sendBuffer = createUDPPacketBuffer(maxPacketSize);\n         if (connection->udpData->sendBuffer == NULL) {\n            printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n      }\n   }\n\n   if (isServer) {\n      /* initialize server data */\n      connection->serverData = (ServerData *) malloc(sizeof(ServerData));\n      if (connection->serverData == NULL) {\n         printf(\"initConnectionData:ServerData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      connection->serverData->port = serverPort;\n      connection->serverData->serverInfoFile = serverInfoFile;\n      /* provided sock is the listening sock */\n      connection->serverData->listenSock = sock;\n      /* later call to serverAcceptSocket will set sock */ \n      connection->sock = INVALID_SOCKET;\n   }\n   else {\n      /* store the provided socket */\n      connection->sock = sock;\n   }\n\n   if (verbosity) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: TCP/IP\\n\", connectionID);\n      }\n      else if (connection->protocol == UDP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: UDP/IP\\n\", connectionID);\n         printf(\"Connection id %d, maxPacketSize: %d\\n\", connectionID, \n                                                         connection->udpData->maxPacketSize);\n         printf(\"Connection id %d, isUsingSeqNum: %d\\n\", connectionID, \n                                                         connection->udpData->isUsingSeqNum);\n      }\n      else {\n         printf(\"initConnectionData:invalid protocol.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      {\n         /* display the size of the socket receive buffer */\n         rtiostream_socklen_t optionLen = sizeof(int);\n         int optionValue;\n         getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpSendBufSize: %d\\n\", connectionID, optionValue);\n         getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpRecvBufSize: %d\\n\", connectionID, optionValue);\n      }\n      printf(\"Connection id %d, blockingRecvTimeout: %d\\n\", connectionID, \n                                                            connection->blockingRecvTimeout);\n      if ((connection->isServer) && (connection->serverData != NULL)) {\n         printf(\"Connection id %d, type: server\\n\", connectionID);       \n         if (connection->serverData->serverInfoFile != NULL) {\n            printf(\"Connection id %d, server info file: %s\\n\", connectionID, \n                                                               connection->serverData->serverInfoFile);\n         }\n      }\n      else {\n         printf(\"Connection id %d, type: client\\n\", connectionID);\n      }\n      printf(\"Connection id %d, socket id %d\\n\", connectionID, (int) sock);\n      /* relevant to both clients and servers */\n      printf(\"Connection id %d, server port: %d\\n\", connectionID, serverPort);\n   }\n   return retVal;\n}\n\n/* Function: getConnectionData =================================================\n * Abstract:\n *  Retrieves a ConnectionData instance given its connectionID \n *  (as returned by initConnectionData) \n *\n * NOTE: An invalid connectionID will lead to a NULL pointer being returned \n */\nstatic ConnectionData * getConnectionData(int connectionID) {\n   /* return NULL for invalid or uninitialized connectionIDs */\n   ConnectionData * connection = NULL;\n   if ((connectionID >= 0) && (connectionID < MAX_NUM_CONNECTIONS)) {\n      if (connectionDataArray[connectionID].isInUse) {\n         connection = &connectionDataArray[connectionID];\n      }\n   }\n   return connection;\n}\n\n/* Function: getConnectionID =================================================\n * Abstract:\n *  Returns a connectionID corresponding to a ConnectionData that is not \n *  already in use.\n *\n *  Returns RTIOSTREAM_ERROR if all available ConnectionData instances are \n *  already in use.\n */\nstatic int getConnectionID(void) {\n   int connectionID;\n   int foundUnusedConnectionData = 0;\n   /* linear search for an unused ConnectionData */\n   for (connectionID = 0; connectionID < MAX_NUM_CONNECTIONS; connectionID++) {      \n      if (!connectionDataArray[connectionID].isInUse) {\n         foundUnusedConnectionData = 1;\n         break;\n      }\n   }\n   if (!foundUnusedConnectionData) {\n      /* all ConnectionData's are in use */\n      printf(\"getConnectionID: All %d available connections are in use.\\n\", MAX_NUM_CONNECTIONS);\n      connectionID = RTIOSTREAM_ERROR;\n   }\n   return connectionID;\n}\n\n/* Function: freeConnectionData =================================================\n * Abstract:\n *  Frees memory associated with the ConnectionData referenced by connectionID.\n *  Marks the ConnectionData instance as no longer in use.\n */\nstatic void freeConnectionData(ConnectionData * connection) {\n   /* mark the ConnectionData as not in use */\n   connection->isInUse = 0;\n   /* free dynamic memory */\n   if (connection->protocol == UDP_PROTOCOL) {\n      freeUDPPacketBuffer(&connection->udpData->recvBuffer);\n      /* freeConnectionData is called if connection->udpData did not allocate */\n      if (connection->udpData != NULL) {\n        if (connection->udpData->isUsingSeqNum) {\n            freeUDPPacketBuffer(&connection->udpData->sendBuffer);\n        }\n      }\n      free(connection->udpData);\n      connection->udpData = NULL;\n   }\n   if (connection->isServer) {\n      free(connection->serverData);\n      connection->serverData = NULL;\n   }\n}\n\n/* Function: createUDPPacketBuffer =================================================\n * Abstract:\n *  Allocates storage for and initializes a UDPPacketBuffer\n */\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize) {\n   /* initialize the UDP packet buffer */\n   UDPPacketBuffer * udpPacketBuffer = (UDPPacketBuffer *) malloc(sizeof(UDPPacketBuffer));      \n   if (udpPacketBuffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer malloc failed.\\n\");\n      return udpPacketBuffer; \n   }\n   /* allocate the buffer */\n   udpPacketBuffer->buffer = (char *) calloc((size_t)maxPacketSize, sizeof(char));\n   if (udpPacketBuffer->buffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer buffer malloc failed.\\n\");\n      /* free everything we allocated */\n      free(udpPacketBuffer);\n      udpPacketBuffer = NULL;\n      return udpPacketBuffer; \n   }\n   resetUDPPacketBuffer(udpPacketBuffer);\n   return udpPacketBuffer;\n}\n\n/* Function: freeUDPPacketBuffer =================================================\n * Abstract:\n *  Frees memory associated with the referenced UDPPacketBuffer \n */\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer) {\n   if (*udpPacketBuffer != NULL) {\n      /* free the buffer */\n      free((*udpPacketBuffer)->buffer);\n      (*udpPacketBuffer)->buffer = NULL;\n      /* free the container */\n      free(*udpPacketBuffer);\n      *udpPacketBuffer = NULL;\n   }\n}\n\n/* Function: resetUDPPacketBuffer =================================================\n * Abstract:\n *  Resets the referenced UDP Packet Buffer so that it is ready to receive fresh data\n */\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer) {\n   udpPacketBuffer->dataPtr = udpPacketBuffer->buffer;\n   udpPacketBuffer->dataAvail = 0;\n}\n\n/* Function: socketDataPending =================================================\n * Abstract:\n *  Returns true, via the 'pending' arg, if data is pending on the comm line.\n *  Returns false otherwise.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR on failure.\n */\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending, \n    int timeoutSecs)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    int pending = SOCK_ERR; /* assume failure until success */\n    \n    #ifdef USE_SELECT\n    /* Variables used with select() on Win32 & VXWorks */\n    struct timeval  tval;\n    struct timeval * tvalPtr;\n    fd_set          ReadFds;\n    #else\n    /* Variables used with poll() on Linux */\n    struct pollfd PollReadFd[1];\n    int tvalPoll;\n    int pollAttempt = 0;\n    #define MAX_POLL_RETRIES 5\n    #endif\n    \n    \n    if (connection->protocol == UDP_PROTOCOL) {\n       /* first check the UDP buffer */\n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       if (udpPacketBuffer->dataAvail) {\n          *outPending = 1;\n          return retVal;\n       }\n    }\n\n    #ifdef USE_SELECT          /* Beginning of block for using select */\n    FD_ZERO(&ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*temporarily disable warning C4127 caused by using FD_SET*/\n      #pragma warning(push)\n      #pragma warning(disable: 4127)\n    #endif\n\n    /* Using fd_set structure ReadFds on Win32/VXWorks */\n    FD_SET(sock, &ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*enable the warning C4127*/\n      #pragma warning(pop)\n    #endif\n\n    /* Select() uses a timeval structure for specifying timeout */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify null pointer for blocking */\n          tvalPtr = NULL;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tval.tv_sec  = 0;\n          tval.tv_usec = 10000;\n          tvalPtr = &tval;\n          break;\n       default:\n          /* set up the time-val */\n          tval.tv_sec  = timeoutSecs;\n          tval.tv_usec = 0;\n          tvalPtr = &tval;\n          break;\n    }\n    #else                       /* Else block for using select */\n    /* Poll() uses an int specifying timeout in milliseconds */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify negative value for blocking */\n          tvalPoll = -1;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tvalPoll = 10;\n          break;\n       default:\n          /* set up the time-val */\n          tvalPoll = timeoutSecs*1000;\n          break;\n    }\n    #endif                      /* End of block for using select */\n\n    \n    #ifdef USE_SELECT\n    /* Use select() on Win32 and VxWorks */\n    /*\n     * Casting the first arg to int removes warnings on windows 64-bit\n     * platform.  It is safe to cast a SOCKET to an int here because on\n     * Linux SOCKET is typedef'd to int and on windows the first argument\n     * to select is ignored (so it doesn't matter what the value is).\n     */\n    pending = select((int)(sock + 1), &ReadFds, NULL, NULL, tvalPtr);\n    #else\n    /* Use poll() on Linux and Mac to avoid issues with sockets >= FD_SETSIZE */\n    PollReadFd[0].fd = sock;\n    PollReadFd[0].events = POLLIN;\n    \n    /* Timer interrupts may cause poll to fail with error EINTR.\n     * In these cases we should retry MAX_POLL_RETRIES times before\n     * concluding an error.\n     */\n    do {\n        pending = poll( PollReadFd, 1, tvalPoll);\n        pollAttempt++;\n    } while (pending == SOCK_ERR && errno == EINTR && pollAttempt < MAX_POLL_RETRIES);\n    #endif\n\n    #ifdef USE_SELECT\n    if (pending == SOCK_ERR) \n    #else\n    /* On Linux an extra check of POLLERR flag is needed to detect and report\n       an error if the other end suddenly crashes. The same flag doesn't seem to be\n       activated on Mac */\n    if ((pending == SOCK_ERR) || \n        (PollReadFd[0].revents & POLLERR))\n    #endif\n    {\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    *outPending = (pending==1) && (retVal == RTIOSTREAM_NO_ERROR);\n    return(retVal);    \n\n} /* end socketDataPending */ \n\n/* Function: initialUDPServerRecvfrom =====================================================\n * Abstract:\n *  Reads data from the client via \"recvfrom\" into the UDP packet buffer.\n *  The client sockaddr is returned via clientSA and clientSALen.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen) {\n   int nRead;\n   int retVal;\n   UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n   /* reset */ \n   resetUDPPacketBuffer(udpPacketBuffer);\n   /* initialize ahead of call to recvfrom */\n   *clientSALen = sizeof(*clientSA);\n   /* read into UDP buffer from the listenSock\n    * and get sockaddr of the client */\n   nRead = recvfrom(connection->serverData->listenSock, \n         udpPacketBuffer->dataPtr, \n                    (size_t)connection->udpData->maxPacketSize, \n         0U, \n         clientSA, \n         clientSALen);\n\n   if (nRead == SOCK_ERR) {\n      retVal = RTIOSTREAM_ERROR;\n   } else {\n      /* set dataAvail */\n      udpPacketBuffer->dataAvail = nRead;\n      /* handle optional sequence number */\n      retVal = processUDPRecvSeqNum(connection);\n   }\n   return retVal;\n}\n\n/* Function: processUDPRecvSeqNum =====================================================\n * Abstract:\n *  Processes sequence numbers in received UDP datagrams.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int processUDPRecvSeqNum(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   if (connection->udpData->isUsingSeqNum) {\n      UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n      /* process sequence number */\n      udpSeqNum_T recvSeqNum;\n      if (udpPacketBuffer->dataAvail < UDP_SEQ_NUM_SIZE) {\n         printf(\"No receive sequence number found.\\n\");\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* read sequence number from the buffer \n       *\n       * sequence number is always transmitted / received in \n       * host Endian */\n      memcpy(&recvSeqNum,\n            udpPacketBuffer->dataPtr,\n            UDP_SEQ_NUM_SIZE);\n      udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n      udpPacketBuffer->dataAvail -= UDP_SEQ_NUM_SIZE;\n      if (connection->verbosity) {\n        printf(\"Received UDP packet with sequence number: %u\\n\", recvSeqNum);\n      }\n      if (connection->udpData->resetExpectedRecvSeqNum) {\n         /* reset the expected sequence number */\n         connection->udpData->expectedRecvSeqNum = recvSeqNum + 1;\n         connection->udpData->resetExpectedRecvSeqNum = 0;\n      }\n      else {\n         /* compare with expected receive seq num */\n         if (recvSeqNum != connection->udpData->expectedRecvSeqNum) {\n            printf(\"UDP packet sequence number mismatch. Expected #: %u, Actual #: %u\\n\", \n                  connection->udpData->expectedRecvSeqNum, recvSeqNum);\n            retVal = RTIOSTREAM_ERROR;\n         } \n         else {\n            /* increment expected receive seq num */\n            connection->udpData->expectedRecvSeqNum++;\n         }\n      }\n   }\n   return retVal;\n}\n\n/* Function: socketDataGet =====================================================\n * Abstract:\n *  Attempts to gets the specified number of bytes from the specified socket.\n *  The number of bytes read is returned via the 'sizeRecvd' parameter.\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is not an error for 'sizeRecvd' to be returned as 0\n *  o this function blocks if no data is available\n */\nstatic int socketDataGet(ConnectionData * connection,\n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd)\n{\n    int nRead = 0;\n    int retVal = RTIOSTREAM_NO_ERROR; \n    /* Ensure size is not out of range for socket API recv function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == TCP_PROTOCOL) {\n        nRead = recv(connection->sock, dst, (size_t)sizeLim, 0U);\n       if (nRead == SOCK_ERR) {\n          retVal = RTIOSTREAM_ERROR;\n       } else {\n          retVal = RTIOSTREAM_NO_ERROR;\n       }\n    }\n    else { \n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       /* receive more data in to the buffer if required */\n       if (udpPacketBuffer->dataAvail == 0) {         \n          /* reset */ \n          resetUDPPacketBuffer(udpPacketBuffer);\n          /* read into buffer */\n          nRead = recv(connection->sock, \n                       udpPacketBuffer->dataPtr, \n                       (size_t)connection->udpData->maxPacketSize, \n                       0U);\n          \n          if (nRead == SOCK_ERR) {\n             retVal = RTIOSTREAM_ERROR;\n          } else {\n             udpPacketBuffer->dataAvail = nRead;\n             /* handle optional sequence number */\n             retVal = processUDPRecvSeqNum(connection);             \n             if (retVal == RTIOSTREAM_ERROR) {\n                return retVal;\n             }\n          }\n       }\n       /* get data from the buffer */\n       /* for the special case where we request a  */\n       /* size of 0 bytes, return the whole buffer */\n       if (udpPacketBuffer->dataAvail) {\n          if (size == 0) {\n            nRead = udpPacketBuffer->dataAvail;\n          } else {\n            nRead = MIN(udpPacketBuffer->dataAvail, sizeLim);\n          }\n          memcpy(dst, (void *) udpPacketBuffer->dataPtr, (size_t)nRead);\n          udpPacketBuffer->dataAvail -= nRead;\n          udpPacketBuffer->dataPtr += nRead;\n       }\n    }\n\n    if (retVal!=RTIOSTREAM_ERROR) {\n        *sizeRecvd = (size_t) nRead;\n    }\n\n    return retVal;\n} /* end socketDataGet */ \n\n\n/* Function: socketDataSet =====================================================\n * Abstract:\n *  Utility function to send data via the specified socket\n */\nstatic int socketDataSet(\n    ConnectionData * connection,\n    const void *src,\n    const size_t size,\n    size_t *sizeSent)\n{\n    int nSent;    \n    int retVal = RTIOSTREAM_NO_ERROR;\n    const void *sendSrc = src;    \n\n    /* Ensure size is not out of range for socket API send function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == UDP_PROTOCOL) {\n       /* limit sends according to max packet size */\n       int maxPacketSize = connection->udpData->maxPacketSize;\n       if (connection->udpData->isUsingSeqNum) {          \n          int transferAmount;\n          UDPPacketBuffer * udpPacketBuffer = connection->udpData->sendBuffer;\n          /* need to apply sequence number and then increment it */\n          resetUDPPacketBuffer(udpPacketBuffer); \n          /* set data src */          \n          sendSrc = udpPacketBuffer->dataPtr;\n          /* add sequence number to the buffer \n           *\n           * sequence number is always transmitted / received in \n           * host Endian */\n          memcpy(udpPacketBuffer->dataPtr, \n                 &connection->udpData->sendSeqNum,\n                 UDP_SEQ_NUM_SIZE);\n          udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n          udpPacketBuffer->dataAvail += UDP_SEQ_NUM_SIZE;                \n          /* copy the data - don't overflow the packet buffer */\n          transferAmount = MIN(sizeLim, maxPacketSize - udpPacketBuffer->dataAvail);\n          memcpy(udpPacketBuffer->dataPtr,\n                 src, \n                 (size_t)transferAmount);\n          udpPacketBuffer->dataAvail += transferAmount;                                   \n          sizeLim = udpPacketBuffer->dataAvail;\n       }\n       else {\n          sizeLim = MIN(maxPacketSize, sizeLim);\n       }\n    }\n\n    nSent = send(connection->sock, (send_buffer_t)sendSrc, (size_t)sizeLim, 0);\n    if (nSent == SOCK_ERR) {\n        retVal = RTIOSTREAM_ERROR;\n    } else { \n        if ((connection->protocol == UDP_PROTOCOL) &&\n            (connection->udpData->isUsingSeqNum) && \n            (nSent > 0)) {\n           if (nSent < (int) UDP_SEQ_NUM_SIZE) {\n              /* expected the sequence number to have transmitted */\n              retVal = RTIOSTREAM_ERROR;\n              return retVal;\n           }\n           else {\n              if (connection->verbosity) {\n                 printf(\"Sent UDP packet with sequence number: %u\\n\", connection->udpData->sendSeqNum);\n              }\n              /* increment sequence number */\n              connection->udpData->sendSeqNum++;\n              nSent -= UDP_SEQ_NUM_SIZE;\n           }          \n        }\n        *sizeSent = (size_t)nSent;\n    }\n\n    return retVal;\n}\n\n/* Function: serverStreamRecv =================================================\n * Abstract:\n *  Send data from the server-side\n */\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    *sizeRecvd = 0;\n\n    if (connection->sock == INVALID_SOCKET) {\n       /* Attempt to open connection */\n       serverAcceptSocket(connection);\n    }\n\n    if (connection->sock != INVALID_SOCKET) {\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n\n        if ( (pending !=0) && (retVal==RTIOSTREAM_NO_ERROR) && (size>0) ) {\n           \n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n            \n            if (*sizeRecvd == 0) {\n                \n                if (errno == RTIOSTREAM_ECONNRESET) {\n                    /* If we are closing the connection and we received this\n                     * error, it means the other side of the connection was\n                     * already closed.  Since we are expecting this, we can\n                     * ignore this particular error.\n                     */\n                    retVal = RTIOSTREAM_NO_ERROR;\n                } else {\n                    /* Connection closed gracefully by client */\n                }\n\n                close(connection->sock);\n                connection->sock = INVALID_SOCKET;\n            }\n        }\n        \n        if ( retVal == RTIOSTREAM_ERROR ) {\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n    }\n\n    return retVal;\n}\n\n/* Function: serverOpenSocket =================================================\n * Abstract:\n *  Opens the listening socket to be used for accepting an incoming connection.\n */\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize)\n{\n\n    struct sockaddr_in serverAddr;\n    int sockStatus;\n    rtiostream_socklen_t sFdAddSize     = (rtiostream_socklen_t) sizeof(struct sockaddr_in);\n    SOCKET lFd;\n    int option;     \n\n    /*\n    * Create a TCP or UDP based socket.\n    */\n    memset((void *) &serverAddr,0,(size_t)sFdAddSize);\n    serverAddr.sin_family      = AF_INET;\n    serverAddr.sin_port        = htons((unsigned short int) port);\n    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    if (protocol == TCP_PROTOCOL) {\n        lFd = socket(AF_INET, SOCK_STREAM, 0);\n    }\n    else {\n        lFd = socket(AF_INET, SOCK_DGRAM, 0);\n    }\n    \n    if (lFd == INVALID_SOCKET) {\n        printf(\"socket() call failed.\\n\");\n    } else {\n        /*\n        * Listening socket should always use the SO_REUSEADDR option\n        * (\"Unix Network Programming - Networking APIs:Sockets and XTI\",\n        *   Volume 1, 2nd edition, by W. Richard Stevens).\n        */\n        option = 1;\n        sockStatus = \n            setsockopt(lFd,SOL_SOCKET,SO_REUSEADDR,(char*)&option,sizeof(option));\n        if (sockStatus == SOCK_ERR) {\n            printf(\"setsocketopt() call failed.\\n\");\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n        if (protocol == TCP_PROTOCOL)\n        {     \n            if (lFd != INVALID_SOCKET)\n            {\n                /* Disable Nagle's Algorithm*/ \n                option = 1;\n                sockStatus = \n                    setsockopt(lFd,IPPROTO_TCP,TCP_NODELAY,(char*)&option,sizeof(option));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() TCP_NODELAY call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }\n            }\n        } \n        if (protocol == UDP_PROTOCOL)\n        {\n            if (lFd != INVALID_SOCKET)\n            {\n\n                /* increase the UDP socket send size to increase the \n                * transfer rate */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }   \n            }\n\n            if (lFd != INVALID_SOCKET)\n            {\n                /* increase the UDP socket receive size to decrease the \n                * possibility of buffer overflow */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                } \n            }\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        sockStatus = bind(lFd, (struct sockaddr *) &serverAddr, sFdAddSize);\n        if (sockStatus == SOCK_ERR) {\n            printf(\"bind() call failed: %s\\n\", strerror(errno));\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        if (port == 0) {\n            /* port 0 specifies dynamic free port allocation\n            * reuse serverAddr to store the actual address / port */\n            sockStatus = getsockname(lFd, (struct sockaddr *) &serverAddr, &sFdAddSize);           \n            if (sockStatus == SOCK_ERR) {\n                fprintf(stderr,\"getsockname() call failed: %s\\n\", strerror(errno));\n                close(lFd);\n                lFd = INVALID_SOCKET;               \n            } else { \n                if(serverInfoFile != NULL) {\n                    FILE* fh;\n                    uint16_T serverPortNo;\n                    int fprintfErr = 0;\n                    int fcloseErr = 0;\n                    \n                    /* Open file in append mode to save info already stored in the file*/\n                    fh = fopen(serverInfoFile,\"a\"); \n#ifdef __LCC64__\n                    /* This is needed due to an issue with LCC64, see the following geck:  g919889 */\n                    fseek ( fh, 0 , SEEK_END );\n#endif\n                    if (fh == NULL) {\n                        fprintf(stderr,\"Unable to open output file to write server port number: %s\\n\", strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n\n                    serverPortNo = ntohs(serverAddr.sin_port);\n                    fprintfErr = fprintf(fh, \"Server Port Number: %d\\n\", serverPortNo);\n                    if (fprintfErr < 0) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to write server port number to output file: %s\\n\",\n                                serverPortNo, strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                    fcloseErr = fclose(fh);\n                    if (fcloseErr == EOF) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to close output file after writing server port number: %s\\n\", \n                                serverPortNo ,strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                } else {\n                    /* write the server port number to stdout */\n                    SERVER_PORT_PRINTF(\"Server Port Number: %d\\n\", ntohs(serverAddr.sin_port));\n                }\n            }                 \n        }\n    }\n    if (protocol == TCP_PROTOCOL) {\n        if (lFd != INVALID_SOCKET) {\n            sockStatus = listen(lFd, 2);\n            if (sockStatus == SOCK_ERR) {\n                printf(\"listen() call failed.\\n\");\n                close(lFd);\n                lFd = INVALID_SOCKET;\n            }\n        }\n    }\n    return lFd;\n}\n/* Function: serverAcceptSocket =================================================\n * Abstract:\n *  Called when the target is not currently connected to the host, this \n *  function attempts to open the connection.  \n *\n *  In the case of sockets, this is a passive operation in that the host\n *  initiates contact, the target simply listens for connection requests.\n *\n * NOTES:\n \n * Blocks according to blockingRecvTimeout. When\n * polling, there may be no open requests pending.  In this case, this\n * function returns without making a connection; this is not an error.\n */\nstatic void serverAcceptSocket(ConnectionData * connection)\n{\n   struct sockaddr_in clientAddr;\n   rtiostream_socklen_t     sFdAddSize     = sizeof(struct sockaddr_in);\n   SOCKET  cFd            = INVALID_SOCKET;\n   int error             = RTIOSTREAM_NO_ERROR;\n   int pending;    \n\n   /* Check that the listening socket is still valid and open a new socket if\n    * not */\n   if (connection->serverData->listenSock == INVALID_SOCKET) {\n      connection->serverData->listenSock = serverOpenSocket(connection->serverData->port,\n            connection->serverData->serverInfoFile, \n            connection->protocol,\n            connection->udpSendBufSize, connection->udpRecvBufSize);\n   }\n\n   /* pass listenSock rather than sock */\n   error = socketDataPending(connection->serverData->listenSock, \n         connection,\n         &pending, \n         connection->blockingRecvTimeout);\n\n   if ( (pending > 0) && (error==RTIOSTREAM_NO_ERROR) ) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         /*\n          * Wait to accept a connection on the comm socket.\n          */\n         cFd = accept(connection->serverData->listenSock, \n                     (struct sockaddr *)&clientAddr,\n                     &sFdAddSize);\n\n         if (cFd == INVALID_SOCKET) {\n            printf(\"accept() for comm socket failed.\\n\");\n            error = RTIOSTREAM_ERROR;\n         } \n\n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n         } \n      }\n      else {\n         /* UDP - data is pending */\n         struct sockaddr clientSA;\n         rtiostream_socklen_t clientSALen;\n         /* new connection, make sure we reset expectedRecvSeqNum, \n          * if sequence numbers are in use */\n         connection->udpData->resetExpectedRecvSeqNum = 1;\n         /* Do the initial UDP server \"recvfrom\" to get the \n          * client sockaddr.   Data read will be placed \n          * ready in the UDP packet buffer. */\n         error = initialUDPServerRecvfrom(connection, &clientSA, &clientSALen); \n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n            printf(\"initialUDPServerRecvfrom() failed.\\n\");\n         }\n         else {\n            /* connect exclusively to the client so we no longer\n             * have to use recvfrom / sendto */\n            if (connect(connection->serverData->listenSock, \n                        &clientSA, \n                        clientSALen) == SOCK_ERR) {\n               close(connection->serverData->listenSock);\n               connection->serverData->listenSock = INVALID_SOCKET;\n               printf(\"Server connect() failed.\\n\");\n            } \n         } \n         /* for UDP, the socket and listening socket are the same */\n         cFd = connection->serverData->listenSock;\n      }\n   }\n   /* set sock */\n   connection->sock = cFd;\n} \n\n\n/* Function: nameLookup =======================\n * Lookup target network name.\n */\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName) {\n\n    struct hostent * hp = NULL;\n    struct in_addr * iaddr = NULL;\n    unsigned long addr = INADDR_NONE;\n\n    /*\n     * Default to localhost if hostname not specified.\n     */\n    if (hostName == NULL) {\n        static char localhost[] = \"localhost\";\n        hostName = localhost;\n    }\n    \n    /*\n     * See if the address is an IPV4 dot separated address:\n     */\n    addr = inet_addr(hostName);\n\n    if (addr == INADDR_NONE) {\n        /* Since the address is not an IPV4 dot separated address, \n         * do a name lookup to get this: \n         */\n        hp = gethostbyname(hostName);\n        if (hp == NULL) {\n          printf(\"gethostbyname() call failed.\\n\");\n  \t  addr = INADDR_NONE;\n        } else {\n          iaddr = (struct in_addr *) hp->h_addr;\n          addr = iaddr->s_addr;\n        }\n    }\n    return(addr);\n}\n#endif\n\n/* Function: processArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when opening the rtIOStream.\n *      \n *  If any unrecognized options are encountered, ignore them.\n *\n * Returns zero if successful or RTIOSTREAM_ERROR if \n * an error occurred.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings should be NULL'd out in\n *    the argv array. \n */\nstatic int processArgs(\n    const int         argc,\n    void            * argv[],\n    char           ** hostName, \n    unsigned int    * portNum,\n    unsigned int    * isClient,\n    int             * isBlocking,\n    int             * recvTimeout, \n    char           ** serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize, \n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize)\n{\n    int        retVal    = RTIOSTREAM_NO_ERROR;\n    int        count           = 0;\n\n    while(count < argc) {\n        const char *option = (char *)argv[count];\n        count++;\n\n        if (option != NULL) {\n\n            if ((strcmp(option, \"-hostname\") == 0) && (count != argc)) {\n\n                *hostName = (char *)argv[count];\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-port\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *portStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(portStr,\"%d%1s\", (int *) portNum, tmpstr);\n                if ( (itemsConverted != 1) || \n                     ( ((*portNum != 0) && (*portNum < 255)) || (*portNum > 65535)) \n                    ) {\n                    \n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n                \n            } else if ((strcmp(option, \"-client\") == 0) && (count != argc)) {\n                \n                *isClient = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-blocking\") == 0) && (count != argc)) {\n                \n                *isBlocking = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-verbose\") == 0) && (count != argc)) {\n                int verbosityVal;\n                int itemsConverted;\n                const char *verbosityStr = (char *)argv[count];\n                count++;\n                itemsConverted = sscanf(verbosityStr,\"%d\", &verbosityVal);\n\n                if ((itemsConverted != 1) || (verbosityVal < 0)) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n                    *verbosity = (VerbosityLevel) verbosityVal;\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n               }\n\n            } else if ((strcmp(option, \"-recv_timeout_secs\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *timeoutSecsStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(timeoutSecsStr,\"%d%1s\", (int *) recvTimeout, tmpstr);\n                if ( itemsConverted != 1 ) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n\n            } else if((strcmp(option, \"-server_info_file\") == 0) && (count != argc)) {\n                *serverInfoFile= (char *) argv[count];\n                \n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            } else if ((strcmp(option, \"-protocol\") == 0) && (count != argc)) {\n              char * protocolStr = (char *) argv[count];\n              count++;\n              argv[count-2] = NULL;\n              argv[count-1] = NULL;\n              /* initialize dependent properties */\n              *isUsingSeqNum = 0;\n              /* process protocolStr */\n              if (strcmp(protocolStr, TCP_PROTOCOL_STRING) == 0) {\n                 *protocol = TCP_PROTOCOL;                \n              }\n              else if (strcmp(protocolStr, UDP_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n              }\n              else if (strcmp(protocolStr, UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n                 /* enable sequence number protocol */\n                 *isUsingSeqNum = 1;\n              }\n              else {\n                 /* unrecognized protocol */\n                 retVal = RTIOSTREAM_ERROR;\n              }            \n            } else if ((strcmp(option, \"-udpmaxpacketsize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *maxUPDSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(maxUPDSizeStr,\"%d%1s\", maxPacketSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n             }else if ((strcmp(option, \"-udpsendbuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpSendBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpSendBufSizeStr,\"%d%1s\", udpSendBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n           }else if ((strcmp(option, \"-udpreceivebuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpRecvBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpRecvBufSizeStr,\"%d%1s\", udpRecvBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n            } else {\n                /* issue a warning for the unexpected argument: exception \n                 * is first argument which might be the executable name (\n                 * SIL/PIL and extmode use-cases). */\n                if ((count!=1) || (strncmp(option, \"-\", 1)==0)) {\n                    printf(\"The argument '%s' passed to rtiostream_tcpip is \"\n                            \"not valid and will be ignored.\\n\", option);\n                }\n            }\n        }\n    }\n    return retVal;\n}\n\n/* Function: clientOpenSocket =================================================\n * Abstract:\n *  Open a connection as Client\n */\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize) {\n    \n    struct sockaddr_in sa;\n    unsigned long addr = INADDR_NONE;\n    int errStatus = RTIOSTREAM_NO_ERROR;\n    SOCKET cSock = INVALID_SOCKET;\n\n    addr = nameLookup(hostName);\n\n    if (addr!=INADDR_NONE) {\n        \n         sa.sin_addr.s_addr = addr;\n         sa.sin_family = AF_INET; /*hp->h_addrtype;*/\n         sa.sin_port   = htons((unsigned short) portNum);\n\n        /*\n         * Create the sockets & make connections.\n         */\n        if (protocol == TCP_PROTOCOL) {\n           cSock = socket(PF_INET,SOCK_STREAM,0);\n        } \n        else {\n           cSock = socket(PF_INET,SOCK_DGRAM,0);\n        }\n        \n        if (cSock == INVALID_SOCKET) {\n            errStatus = RTIOSTREAM_ERROR;\n            printf(\"socket() call failed for comm socket.\\n\");\n        }\n    } else {\n      errStatus = RTIOSTREAM_ERROR;\n    }\n \n    if (protocol == UDP_PROTOCOL)\n    {\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket send size to increase the \n            * transfer rate */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           }    \n        }\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket receive size to decrease the \n            * possibility of buffer overflow */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           } \n       }\n    }\n\n    if (errStatus!=RTIOSTREAM_ERROR) {\n        if (connect(cSock, (struct sockaddr *)&sa, sizeof(sa)) == SOCK_ERR) {\n            char tmp[1024];\n\n            sprintf(tmp,\n                    \"Attempting to establish connection with hostname '%s' \"\n                    \"through port %d.\\n\", \n                    hostName,\n                    ntohs(sa.sin_port));\n            cSock = INVALID_SOCKET;\n            printf(\"%s\",tmp);\n        } \n    }\n\n    return cSock;\n}\n#endif\n\n/* Function: waitForClientClose =============================================\n * Abstract:\n *\n * Allow the client to close its end of the socket connection before the server\n * closes its own socket.\n *\n * The server will receive any outstanding data on the socket.   When the server\n * receives 0 bytes, it indicates that it has acknowledged that the client \n * is closing its socket (this is essential for the client to complete\n * closing its socket without error) or that it timed out waiting for the client to \n * close its socket.\n *\n */\nstatic int waitForClientClose(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n#define TMP_BUF_SIZE (40)\n   char * tmpBuf[TMP_BUF_SIZE];\n   size_t numRecvd;          \n   /* cache the original blockingRecvTimeout */\n   int savedBlockingRecvTimeout = connection->blockingRecvTimeout;      \n   /* wait time for client to close its socket */\n   connection->blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN;\n   do {         \n      retVal = serverStreamRecv(connection, (void *) tmpBuf, TMP_BUF_SIZE, &numRecvd);\n   } while ((numRecvd > 0) && (retVal == RTIOSTREAM_NO_ERROR));\n   /* restore blockingRecvTimeout */\n   connection->blockingRecvTimeout = savedBlockingRecvTimeout;\n#undef TMP_BUF_SIZE\n   return retVal;\n}\n\n/***************** VISIBLE FUNCTIONS ******************************************/\n\n/* Function: rtIOStreamOpen =================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    char               *xHostName = NULL; /* default */\n    char               *serverInfoFile = NULL; /* default */\n    unsigned int        xPortNum     = (SERVER_PORT_NUM); /* default */\n    unsigned int        isClient = 0; /* default */\n    CommsProtocol       protocol = DEFAULT_PROTOCOL;\n    int                 isBlockingRecv = EXT_BLOCKING; /* default */\n    int                 blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT; /* rogue value */\n    int                 maxPacketSize = DEFAULT_MAX_UDP_PACKET_SIZE;\n    VerbosityLevel      verbosity = DEFAULT_VERBOSITY;\n    int                 isUsingSeqNum = DEFAULT_IS_USING_SEQ_NUM;\n    int                 udpSendBufSize = DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST;\n    int                 udpRecvBufSize = DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST;\n    int result = RTIOSTREAM_NO_ERROR;\n    int streamID;\n    SOCKET sock = INVALID_SOCKET;\n\n    /* determine the streamID for this new connection */\n    streamID = getConnectionID();\n    if (streamID == RTIOSTREAM_ERROR) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n\n    result = processArgs(argc, argv, \n                         &xHostName, \n                         &xPortNum, \n                         &isClient, \n                         &isBlockingRecv,\n                         &blockingRecvTimeout, \n                         &serverInfoFile, \n                         &protocol, \n                         &maxPacketSize, \n                         &verbosity, \n                         &isUsingSeqNum,\n                         &udpSendBufSize,\n                         &udpRecvBufSize);\n\n    if (result == RTIOSTREAM_ERROR) {\n       return result;\n    }\n\n    if (verbosity) {\n       printf(\"rtIOStreamOpen\\n\");\n    }\n\n    if (isBlockingRecv) {\n       /* blocking: if blockingRecvTimeout has not been set, initialize to the client or\n        * server specific default */\n       if ((blockingRecvTimeout == DEFAULT_BLOCKING_RECV_TIMEOUT) ||\n           (blockingRecvTimeout < BLOCKING_RECV_TIMEOUT_10MS)) {\n          if (isClient) {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT;\n          }\n          else {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER;\n          }\n       }\n    }\n    else {\n       /* not blocking: set the timeout to return immediately */\n       blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_NOWAIT;\n    }\n\n#ifdef VXWORKS /* UDP is not supported on VxWorks */\n    if (protocol == UDP_PROTOCOL) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n#endif\n\n#ifdef _WIN32\n    {\n        WSADATA data;\n        if (WSAStartup((MAKEWORD(1,1)), &data)) {\n            result = RTIOSTREAM_ERROR;\n            printf(\"WSAStartup() call failed.\\n\");\n        }\n    }\n#endif\n\n    if (result != RTIOSTREAM_ERROR) { /* polyspace DEFECT:USELESS_IF [Not a defect:Unset] \"Needed for Windows\" */\n        if (isClient == 1) {\n#if (!defined(VXWORKS)) /* Client side connection not supported on VxWorks */\n            sock = clientOpenSocket(xHostName, xPortNum, protocol,udpSendBufSize,udpRecvBufSize);\n            if (sock == INVALID_SOCKET) {\n            result = RTIOSTREAM_ERROR;\n            }\n#endif\n        } else {           \n            sock = serverOpenSocket((int)xPortNum, serverInfoFile, protocol,udpSendBufSize,udpRecvBufSize);            \n            if (sock == INVALID_SOCKET) {\n                result = RTIOSTREAM_ERROR;\n            }\n        }\n    }\n\n    if (result != RTIOSTREAM_ERROR) {\n       int isServer;\n       if (isClient == 1) {\n          isServer = 0;   \n       }\n       else {\n          isServer = 1;\n       }\n       result = initConnectionData(streamID, \n             isServer, \n             protocol, \n             sock, \n             blockingRecvTimeout,\n             maxPacketSize, \n             (int)xPortNum, \n             serverInfoFile, \n             verbosity, \n             isUsingSeqNum,\n             udpSendBufSize,\n             udpRecvBufSize);\n    }\n    \n    if (result != RTIOSTREAM_ERROR) {\n       result = streamID;\n    }\n    else {\n       if (sock != INVALID_SOCKET) {\n          /* cleanup */\n          close(sock);\n       }\n    }\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n * Abstract:\n *  Sends the specified number of bytes on the comm line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred. As long\n *  as an error does not occur, this function is guaranteed to set the requested\n *  number of bytes; the function blocks if tcpip's send buffer doesn't have\n *  room for all of the data to be sent\n */\nint rtIOStreamSend(\n    int streamID,\n    const void *src,\n    size_t size,\n    size_t *sizeSent)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    *sizeSent = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        if (connection->sock == INVALID_SOCKET) {\n            serverAcceptSocket(connection);\n        }\n\n        if (connection->sock != INVALID_SOCKET) {\n#ifndef VXWORKS\n           retVal = socketDataSet(connection, src, size, sizeSent);\n#else           \n           /*\n            * VXWORKS send prototype does not have src as const.  This suppresses\n            * the compiler warning.\n            */\n\n           retVal = socketDataSet(connection, (char *)src, size, sizeSent);\n#endif\n        }\n    } else { /* Client stream */\n        retVal = socketDataSet(connection, src, size, sizeSent);\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeSent > 0) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamSend (connection id %d): size = %lu, sizeSent = %lu: \", \n                   streamID, \n                   (unsigned long) size, \n                   (unsigned long) *sizeSent);\n        \n            for (currElement = 0; currElement < *sizeSent; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) src)[currElement]);\n            }\n            printf(\"\\n\");\n        }       \n    }\n\n    return retVal;\n}\n\n\n/* Function: rtIOStreamRecv ================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd) \n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n\n    *sizeRecvd = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        retVal = serverStreamRecv(connection, dst, size, sizeRecvd); \n    } else { /* Client stream */\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n        if (pending && (size>0))  {\n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n        }\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeRecvd > 0 ) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamRecv (connection id %d): size = %lu, sizeRecvd = %lu: \", \n                   streamID,\n                   (unsigned long) size,\n                   (unsigned long) *sizeRecvd);\n\n            for (currElement = 0; currElement < *sizeRecvd; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) dst)[currElement]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return retVal;\n}\n\n/* Function: rtIOStreamClose ================================================\n * Abstract: close the connection.\n *\n */\nint rtIOStreamClose(int streamID)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->verbosity) {\n       printf(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n    }\n\n    if (connection->isServer) {\n        /* Only if the client actually made a connection */\n        if (connection->sock != INVALID_SOCKET) {\n            if (connection->protocol == TCP_PROTOCOL) {\n                /* graceful shutdown */\n                retVal = waitForClientClose(connection);\n            }\n            \n            /* close the socket */\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n       if (connection->protocol == TCP_PROTOCOL) {\n          /* TCP: additionally close the listening socket\n           *\n           * for UDP, sock and listenSock are the same\n           * socket - avoid closing it twice */\n          close(connection->serverData->listenSock);\n       }\n       /* set to INVALID_SOCKET for all protocol types */\n       connection->serverData->listenSock = INVALID_SOCKET;       \n    } else {\n       SOCKET cSock = connection->sock;\n       close(cSock);\n\n    }\n    freeConnectionData(connection);\n    return retVal;\n}\n\n"},{"name":"rtiostream_utils.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"rtiostream_utils.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\coder\\rtiostream\\src\\utils","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2012 The MathWorks, Inc. */\n\n#ifndef _RTIOSTREAM_UTILS_H_\n#define _RTIOSTREAM_UTILS_H_\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* Target-side rtIOStream utility APIs */\n\n#include \"rtwtypes.h\" /* include definition of uint32_T */\n#include <stddef.h>   /* include definition of size_t */\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n          \n/* Blocks until all requested outgoing data is sent. */\nextern int rtIOStreamBlockingSend(const int streamID,\n                                  const void * const src,\n                                  uint32_T size);\n\n/* Blocks until all requested incoming data is received. */\nextern int rtIOStreamBlockingRecv(const int streamID,\n                                  void * const dst,\n                                  uint32_T size);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _RTIOSTREAM_UTILS_H_ */\n"},{"name":"rx_tx_buffer_sizes.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2016 The MathWorks, Inc. */\n\n/* \n * File: rx_tx_buffer_sizes.h\n *\n * Defines the buffer sizes for the various XIL services.\n * Make sure we are backwards compatible with PIL implementations that \n * define RTIOSTREAM_TX_BUFFER_BYTE_SIZE and RTIOSTREAM_RX_BUFFER_BYTE_SIZE\n * in their connectivity config. We will use these preprocessor defines to\n * derive both the RX and TX buffer sizes for the various XIL services and\n * make sure we don't incur more memory requirements.\n */\t\t\n\n#ifndef __RX_TX_BUFFER_SIZES_H__\n#define __RX_TX_BUFFER_SIZES_H__\n\n#include \"rtwtypes.h\"\n\n/* transmit buffer size in mem units - no need to worry about fractions \n * as division in C always floors the result. \n */\n#define RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES)\n\n/* Receive buffer size */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n#define RTIOSTREAM_RX_BUFFER_SIZE (RTIOSTREAM_RX_BUFFER_BYTE_SIZE)\n#else\n#define RTIOSTREAM_RX_BUFFER_SIZE (RTIOSTREAM_RX_BUFFER_BYTE_SIZE / MEM_UNIT_BYTES)\n#endif\n\n/* # app services sharing the TX buffer allocation */\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define NUM_APPS_SHARING_TX 2\n#else\n   /* XIL */\n   #define NUM_APPS_SHARING_TX 1\n#endif\n\n/* send buffer sizes for applications */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so use BYTE_SIZE to make sure we have the same effective \n    * buffer size during PWS */\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_BYTE_SIZE / NUM_APPS_SHARING_TX)\n#else\n   #define XIL_TX_BUFFER_MEMUNIT_SIZE (RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE / NUM_APPS_SHARING_TX)\n#endif\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n   #define CODE_INSTR_TX_BUFFER_MEMUNIT_SIZE XIL_TX_BUFFER_MEMUNIT_SIZE\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n/* buffer includes space for BUFFER_HEADER_SIZE */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* buffer is actually defined in terms of \"byte\" IOUnits \n    * so multiply up to make sure we have the same effective \n    * buffer size during PWS */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE (32 * MEM_UNIT_BYTES)\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_BYTE_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#else\n   /* simply reserve a 32 memunit buffer */\n   #define CA_TX_BUFFER_MEMUNIT_SIZE 32\n   #if CA_TX_BUFFER_MEMUNIT_SIZE > RTIOSTREAM_TX_BUFFER_MEMUNIT_SIZE\n     #error \"Coder assumptions transmit buffer size must be less than or equal to the overall rtiostream transmit buffer size.   Increase RTIOSTREAM_TX_BUFFER_BYTE_SIZE accordingly.\"\n   #endif\n#endif\n\n#endif\n\n#define APPLICATION_ID_SIZE (sizeof(MemUnit_T))\n#define WRITE_DATA_AVAIL_SIZE (sizeof(uint32_T))\n#define BUFFER_HEADER_SIZE  (APPLICATION_ID_SIZE + WRITE_DATA_AVAIL_SIZE)\n#define APPLICATION_ID_IDX 0\n#define PAYLOAD_SIZE_IDX (APPLICATION_ID_IDX + APPLICATION_ID_SIZE)\n#define PAYLOAD_IDX (PAYLOAD_SIZE_IDX + WRITE_DATA_AVAIL_SIZE)\n\n#endif /*__RX_TX_BUFFER_SIZES_H__ */\n\n"},{"name":"sil_main.c","type":"source","group":"SILPIL","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw\\sil","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2020 The MathWorks, Inc.\r\n * MathWorks generated main function using the Target Framework */\r\n\r\n#include <stdio.h>\r\n\r\n#include \"xil_interface_lib.h\"\r\n\r\n\r\nint main(const int argc, char * argv[]) {\r\n\r\n    /* Initialization code */\r\n    /* Copyright 2019-2020 The MathWorks, Inc. */\r\n    volatile int loop = 1; /* avoid warnings about infinite loops */\r\n    int errorOccurred = 0;\r\n    XIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\r\n    int terminateOnError = 1;\r\n    \r\n\r\n\r\n    /* Main application body */\r\n    /* XIL initialization */    \r\n    errorCode = xilInit(argc, (void **) argv);\r\n    errorOccurred = (errorCode != XIL_INTERFACE_LIB_SUCCESS);\r\n    \r\n    /* main XIL loop */\r\n    while(loop && !errorOccurred) {\r\n    \r\n        errorCode = xilRun();\r\n        errorOccurred = (errorCode != XIL_INTERFACE_LIB_SUCCESS);\r\n    \r\n        if (errorCode == XIL_INTERFACE_LIB_TERMINATE) {\r\n    \r\n            /* orderly shutdown of rtiostream */\r\n            errorCode = xilTerminateComms();   \r\n            errorOccurred = (errorCode != XIL_INTERFACE_LIB_SUCCESS);\r\n            break;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    /* Termination code */\r\n\r\n    /* trap error with infinite loop */\r\n    while (!terminateOnError && errorOccurred) {\r\n    }   \r\n    \r\n    return errorCode;\r\n}"},{"name":"target_io.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2011-2020 The MathWorks, Inc. */\n#include <stdio.h> /* sprintf */\n#include <stdarg.h> /* variable argument lists */\n#include <string.h> /* strlen, memcpy */\n#include \"xil_interface_common.h\"\n#include \"xil_data_stream.h\"\n#include \"xil_common.h\"\n#include \"target_io.h\"\n#include \"rtwtypes.h\"\n\n#ifndef TARGET_IO_BUFFER_SIZE\n/* default buffer size is large enough for most use cases */\n#define TARGET_IO_BUFFER_SIZE 64 \n#endif\n#define TARGET_IO_BUFFER_RES_SIZE (TARGET_IO_BUFFER_SIZE - 1)\n\n\n#define TARGET_STDOUT 65535U\n\n#ifndef TARGET_IO_MAX_FILE_ID\n/* -1 avoids warning about the comparison that is done\n * in targetFopen \n *\n * note that MAX_uint16_T will be limited to uint16 max\n * even when portable word sizes maps uint16 to a larger \n * type such as uint32 on the SHARC */\n#define TARGET_IO_MAX_FILE_ID (uint16_T)(TARGET_STDOUT - 1)\n#else\n#if TARGET_IO_MAX_FILE_ID == TARGET_STDOUT\n#error Wrong value for TARGET_IO_MAX_FILE_ID. It must be different from TARGET_STDOUT\n#endif\n\n#endif\n\ntypedef enum {TARGET_IO_SUCCESS=0,\n              TARGET_IO_BUFFER_TRUNC } TARGET_IO_ERROR_ID;\n\nstatic char targetStdioBuffer[TARGET_IO_BUFFER_SIZE];\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\nstatic MemUnit_T hostWordStdioBuffer[TARGET_IO_BUFFER_SIZE];\n#endif\n\n/* fid is the file id on target and is limited to TARGET_IO_MAX_FILE_ID */\nstatic uint16_T fid = 0;\n\n/* call xilWriteData and check for errors */\nstatic void targetWriteDataWithErrorCheck(const MemUnit_T *, uint32_T);\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\nstatic void targetWriteDataWithCharToMemUnitWidening(const char *, MemUnit_T *, uint32_T);\n#endif /* HOST_WORD_ADDRESSABLE_TESTING */\n\nvoid targetWriteDataWithErrorCheck(const MemUnit_T * data, uint32_T size) {\n   if (xilWriteData(data, size) != XIL_DATA_STREAM_SUCCESS) {\n      for (;;) {\n         /* fatal comms error */\n      }\n   }\n}\n\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\nstatic void targetWriteDataWithCharToMemUnitWidening(const char *pCharBuff, MemUnit_T *pMemUnitBuff, uint32_T buffSize) {\n   uint32_T i;\n   for(i=0;i<buffSize;i++) {\n      pMemUnitBuff[i] = (MemUnit_T) pCharBuff[i];\n   }\n   targetWriteDataWithErrorCheck(pMemUnitBuff, buffSize * sizeof(MemUnit_T));\n}\n#endif\n\n/**\n * Function to send \"frame\" toward host for all print functions : printf, vprintf...\n **/\nstatic void targetWritePrintf(unsigned short targetFid,\n                              MemUnit_T responseId,\n                              MemUnit_T errorId,\n                              char* pCharBuff,\n                              uint32_T size) {\n\n\n    /* really strange behavior if here, but we have to put this...*/\n    uint16_T size16;\n    size = (uint16_T)((size > 0xFFFF) ? 0xFFFF : size);\n    size16 = (uint16_T)size;\n\n    /* send response id */\n    targetWriteDataWithErrorCheck(&responseId, sizeof(responseId));\n    /* send error id */\n    targetWriteDataWithErrorCheck(&errorId, sizeof(errorId));\n\n    /* else we don't send the file id */\n    if (targetFid != TARGET_STDOUT) {\n        const uint16_T targetFid16 = (uint16_T)targetFid; /* We only use the\n                                                           * lowermost 16 bits of\n                                                           * targetFid. unsigned\n                                                           * int is guaranteed to\n                                                           * be at least 16 bits\n                                                           * wide. See header file\n                                                           * for more information\n                                                           * on why this cast is\n                                                           * required. */\n\n        /* send file id*/\n        targetWriteDataWithErrorCheck((const MemUnit_T*)&targetFid16, sizeof(targetFid16));\n    }\n\n    /* send fprintSize */\n    targetWriteDataWithErrorCheck((MemUnit_T*)&size16, sizeof(size16));\n    if (size > 0) {\n/* send data */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n      targetWriteDataWithCharToMemUnitWidening(&pCharBuff[0], &hostWordStdioBuffer[0], size);\n#else\n      targetWriteDataWithErrorCheck((MemUnit_T *)&pCharBuff[0], size);\n#endif\n    }\n}\n\n\n/* Forward a printf back to the host machine\n *\n * the sending will be cut in parts where each are bellow TARGET_IO_BUFFER_SIZE\n * It's an improved version of targetPrintf\n * some things are not handled from printf :\n * - the * in the width\n * - %n\n * - j z t in length moditifier\n * - %lc for character and %ls for wchar_t for string (cf\n * http://www.cplusplus.com/reference/cstdio/printf/)\n * - %llu %lld (will be consider as %lu %ld)\n */\nconst char target_typefiled[] = {'d', 's', 'f', 'u', 'x', '%', 'i', 'F',\n                                 'e', 'E', 'g', 'G', 'X', 'o', 'c', 'p'};\n\n/* 60 should be enough for a %xxx  */\n#define TARGET_PRINTF_TMP_BUFF_SIZE 60u\nstatic char targetStdioTmpBuff[TARGET_PRINTF_TMP_BUFF_SIZE];\nstatic char subFmt[15];\n\nstatic void targetPrintfKernel(MemUnit_T responseId,\n                               unsigned short targetFid,\n                               const char* fmt,\n                               va_list argptr) {\n    MemUnit_T errorId = TARGET_IO_SUCCESS;\n    char* targetFramePtr;\n    int targetStdioTmpBuffIdx;\n\n    int idx = 0;\n\n    uint16_T expectedSize = (uint16_T)0;\n    uint16_T printSize = (uint16_T)0;\n\n    uint8_T bFinished = 0;\n    uint8_T bSendNow = 0;\n    targetStdioTmpBuffIdx = 0;\n    targetFramePtr = (char*)0;\n\n    /* 01 : measure the size of the output to be sent */\n    do {\n        if (!bSendNow) {\n            if (fmt[idx] == '%') {\n\n                int subFmtIdx = 1;\n                uint8_T found = 0;\n                subFmt[0] = fmt[idx];\n                do {\n                    size_t cpt = 0;\n\n                    idx++;\n                    subFmt[subFmtIdx] = fmt[idx];\n\n                    found = 0;\n                    for (cpt = 0; cpt < sizeof(target_typefiled); cpt++) {\n                        if (subFmt[subFmtIdx] == target_typefiled[cpt]) {\n                            found = 1;\n                            subFmt[subFmtIdx + 1] = '\\0';\n                            break;\n                        }\n                    }\n                    if (found) {\n                        int numCarCurr = 0;\n                        int lengthModifier = 0;\n                        /* get the length modifier if any */\n                        if (subFmtIdx > 1) {\n\n                            switch (subFmt[subFmtIdx - 1]) {\n                            case 'l':\n                                if ((subFmtIdx > 2) && (subFmt[subFmtIdx - 2] == 'l')) {\n                                    /* long long */\n                                    /* \n                                      the long long is really special and is not well handled by every compiler the same way\n                                      all windows version doesn't no it, where's some compiler doesn't know the int64_T which \n                                      would be required to make things easier. we will not handle it so far => lengthModifier = 1\n                                    */\n                                    lengthModifier = 1;\n                                } else {\n                                    /* long */\n                                    lengthModifier = 1;\n                                }\n                                break;\n                            case 'L':\n                                lengthModifier = 1;\n                                break;\n                            case 'h': /* integral promotion : dont care*/\n                            default:\n                                lengthModifier = 0;\n                                break;\n                            }\n                        }\n\n                        if (subFmt[subFmtIdx] != 's') {\n                            /**\n                             * Here we have to do this (sprintf) instead of calling vsprintf.\n                             * Indeed, depending on the implementation of va_list, the va_arg was\n                             * modified or not by the vsprintf function. va_copy is C99 and not\n                             * usable. Anyway as it's not good to do any assumptions on the\n                             * va_list.. implementation, it's better not using it. Sadly, it creates\n                             * drawback. for instance, now,the %*.2d would not be working\n                             */\n                            switch (subFmt[subFmtIdx]) {\n                            case 'd':\n                            case 'i': {\n                                if (lengthModifier == 0) {\n                                    int val = va_arg(argptr, int);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                } else {\n                                    long int val = va_arg(argptr, long int);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                }\n                            } break;\n\n                            case 'u':\n                            case 'x':\n                            case 'X':\n                            case 'o': {\n                                if (lengthModifier == 0) {\n                                    unsigned int val = va_arg(argptr, unsigned int);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                } else {\n                                    unsigned long int val = va_arg(argptr, unsigned long int);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                }\n                            } break;\n\n                            case 'f':\n                            case 'F':\n                            case 'E':\n                            case 'e':\n                            case 'g':\n                            case 'G': {\n                                if (lengthModifier == 0) {\n                                    double val = va_arg(argptr, double);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                } else { /* if(lengthModifier == 1) */\n                                    long double val = va_arg(argptr, long double);\n                                    numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                                }\n                                /* always promoted to double first        */\n                            } break;\n                            case 'c': {\n                                /*promotion to int for variadic, cf\n                                 * https://en.cppreference.com/w/cpp/language/variadic_arguments*/\n                                int val = va_arg(argptr, int);\n                                numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, val);\n                            } break;\n                            case 'p': {\n                                void* ptr = va_arg(argptr, void*);\n                                numCarCurr = sprintf(&targetStdioTmpBuff[0], subFmt, ptr);\n                            } break;\n                            case '%': {\n                                char val = '%';\n                                targetStdioTmpBuff[0] = val;\n                                numCarCurr = 1;\n                            } break;\n                            default:\n                                numCarCurr = 0;\n                                break;\n                            }\n                        } else {\n                            targetFramePtr = va_arg(argptr, char*);\n                            numCarCurr = (int)strlen(targetFramePtr);\n                        }\n\n                        if (numCarCurr < 0) {\n                            /* set error id if error or buffer overruns */\n                            errorId = TARGET_IO_BUFFER_TRUNC;\n                            bFinished = 1;\n                            expectedSize = 0;\n                            break;\n                        } else {\n                            /* we send the buffer like this */\n                            if ((expectedSize + numCarCurr) >= TARGET_IO_BUFFER_RES_SIZE) {\n                                /*keep this for after*/\n                                targetStdioTmpBuffIdx = numCarCurr;\n                                if (subFmt[subFmtIdx] != 's') {\n                                    targetFramePtr = &targetStdioTmpBuff[0];\n                                }\n                                bSendNow = 1;\n                            } else {\n                                if (subFmt[subFmtIdx] != 's') {\n                                    strncpy(&targetStdioBuffer[expectedSize],\n                                            &targetStdioTmpBuff[0], (size_t)numCarCurr);\n                                } else {\n                                    strncpy(&targetStdioBuffer[expectedSize], targetFramePtr,\n                                            (size_t)numCarCurr);\n                                    targetFramePtr = (char*)0;\n                                }\n                                expectedSize += (uint16_T)numCarCurr;\n                            }\n                        }\n                    } else {\n                        subFmtIdx++;\n                    }\n                    /* if we have not found but we have '\\0', then we have a wrong input frame*/\n                } while ((!found) && (fmt[idx] != '\\0'));\n\n                /* here we didn't found a correct format but this is the end of the fmt, we don't\n                   display this last part. this is not defined by the standard. This is an error\n                   case\n                  */\n                if ((fmt[idx] == '\\0') && (!found)) {\n                    bFinished = 1;\n                    bSendNow = 1;\n                }\n                idx++;\n            } else if (fmt[idx] == '\\0') {\n                bFinished = 1;\n                bSendNow = 1;\n            } else {\n                targetStdioBuffer[expectedSize] = fmt[idx];\n                expectedSize++;\n                if (expectedSize >= TARGET_IO_BUFFER_RES_SIZE) {\n                    bSendNow = 1;\n                }\n                idx++;\n            }\n        }\n\n        if (bSendNow && ((expectedSize > 0) || (errorId != TARGET_IO_SUCCESS))) {\n            if (expectedSize > 0) {\n                printSize = expectedSize + 1;\n                targetStdioBuffer[expectedSize] = '\\0';\n                expectedSize = 0;\n            }\n\n            targetWritePrintf(targetFid, responseId, errorId, &targetStdioBuffer[0], printSize);\n\n            bSendNow = 0;\n        }\n\n        if ((targetStdioTmpBuffIdx > 0) && (!bFinished)) {\n            if (targetStdioTmpBuffIdx < TARGET_IO_BUFFER_RES_SIZE) {\n                strncpy(&targetStdioBuffer[0], targetFramePtr, (size_t)targetStdioTmpBuffIdx);\n                expectedSize = (uint16_T)targetStdioTmpBuffIdx;\n                targetStdioTmpBuffIdx = 0;\n                targetFramePtr = 0;\n\n            } else {\n                strncpy(&targetStdioBuffer[0], targetFramePtr, (size_t)TARGET_IO_BUFFER_RES_SIZE);\n                targetFramePtr += TARGET_IO_BUFFER_RES_SIZE;\n                targetStdioTmpBuffIdx -= TARGET_IO_BUFFER_RES_SIZE;\n                expectedSize = (uint16_T)TARGET_IO_BUFFER_RES_SIZE;\n\n                bSendNow = 1;\n            }\n        }\n\n    } while (!bFinished);\n}\n\n/**\n *  Forward a vprintf back to the host machine\n *\n */\nvoid targetvPrintf(const char* fmt, va_list argptr) {\n\n    targetPrintfKernel(XIL_RESPONSE_PRINTF, TARGET_STDOUT, fmt, argptr);\n}\n\n/* Forward a printf back to the host machine\n *\n */\nvoid targetPrintf(const char* fmt, ...) {\n    va_list argptr;\n    va_start(argptr, fmt);\n\n    targetPrintfKernel(XIL_RESPONSE_PRINTF, TARGET_STDOUT, fmt, argptr);\n\n    va_end(argptr);\n}\n\n/* Forward a fopen back to the host.\n *\n * fid is used on target to act as a valid \n * \"file descriptor\".\n */\nunsigned short targetFopen(const char * fileName) {\n   uint16_T fileNameSize;\n   MemUnit_T responseId = XIL_RESPONSE_FOPEN;\n\n   /* size of file name string */\n   fileNameSize = (uint16_T) strlen(fileName);\n\n   /* add one for the terminating null character */\n   fileNameSize++;\n \n   /* check bounds and reset to 0 if necessary which will trigger an error \n    * on the host */\n   if(fid >= TARGET_IO_MAX_FILE_ID) {\n      fid = 0;\n   }\n   /* send response id */\n   targetWriteDataWithErrorCheck(&responseId, sizeof(responseId));\n   /* send file id */\n   targetWriteDataWithErrorCheck((MemUnit_T *)&fid, sizeof(fid));\n   /* send size of file name string */\n   targetWriteDataWithErrorCheck((MemUnit_T *)&fileNameSize, sizeof(fileNameSize));\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n   /* in case the total size is bigger than the hostWordStdioBuffer, send in \n    * multiple chunks */\n   {      \n      while (fileNameSize > 0) {\n         uint16_T transferSize = MIN(fileNameSize, TARGET_IO_BUFFER_SIZE);\n         /* send file name string */\n         targetWriteDataWithCharToMemUnitWidening(fileName, &hostWordStdioBuffer[0], (uint32_T)transferSize);   \n         fileNameSize -= transferSize;\n         fileName += transferSize;\n      }\n   }\n#else\n   /* send file name string */\n   targetWriteDataWithErrorCheck((const MemUnit_T *)fileName, fileNameSize);\n#endif\n\n   /* return fid, THEN increment it */\n   return (unsigned short) (fid++); /* unsigned short is at least 16-bits\n                                     * wide. See header file for more\n                                     * information on why this cast is\n                                     * required. */\n}\n\n/**\n * Standard write to a file already opened by targetFopen\n *\n **/\nvoid targetFprintf(unsigned short targetFid, const char * fmt, ...) {\n   va_list argptr;\n\n   va_start(argptr, fmt);\n\n   targetPrintfKernel(XIL_RESPONSE_FPRINTF, targetFid, fmt, argptr);\n\n   va_end(argptr);\n\n   return;\n}\n"},{"name":"target_io.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2011-2020 The MathWorks, Inc. */\n#ifndef __TARGET_STDIO_H__\n#define __TARGET_STDIO_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdarg.h>\n/*\n * The default buffer size is 64 bytes with\n * 1 bytes reserved for null terminator at the end.\n *\n * For LDRA I/O forward support, by default configuration, a minimal\n * of 25 bytes buffer is enough.  LDRA users can change the column\n * width of output data format, which may exceed this 25 bytes\n * boundary value. However, the 64 bytes buffer will provide a safer\n * limit.\n *\n */\n\n/*\n * For compatibility with third party code coverage tools, this header must not\n * include rtwtypes.h. In particular, we must not use uint16_T in this header\n * file. Note that unsigned short is guaranteed to be at least 16 bits wide on\n * any platform; see implementation of targetFopen, targetFprintf for casts that\n * rely on this guarantee.\n */\nextern void targetPrintf(const char* fmt, ...);\nextern void targetvPrintf(const char* fmt, va_list argptr);\nextern unsigned short targetFopen(const char* fileName);\nextern void targetFprintf(unsigned short targetFid, const char* fmt, ...);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __TARGET_STDIO_H__ */\n"},{"name":"xil_common.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2011-2013 The MathWorks, Inc. */\n\n/*\n * File: xil_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_COMMON_H__\n#define __XIL_COMMON_H__\n\n#include \"rtwtypes.h\"\n#include <string.h> /* include definition of size_t */\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n# if defined(__LCC__)\n#   define UNUSED_PARAMETER(x)                                   /* do nothing */\n# else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#   define UNUSED_PARAMETER(x)         (void) (x)\n# endif\n#endif\n\n/* MIN is typically used in data stream implementations */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#endif\n"},{"name":"xil_data_stream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2020 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_ERROR\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"comms_interface.h\"\n#ifndef USING_CS_API    \n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#endif\n#include \"xil_data_stream.h\"\n#include \"xil_interface_lib.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef USING_CS_API\n    #define XIL_TX_BUFFER_MEMUNIT_SIZE xilTgtAppSvcGetMaxPayloadCapacity()\n    #define BUFFER_HEADER_SIZE 0\n#else\n    #include \"rx_tx_buffer_sizes.h\"\n#endif\n\n#define COMMAND_COMPLETE_SIZE (sizeof(MemUnit_T))\n#define COMMAND_COMPLETE_IDX 0\n#define WRITE_DATA_BUFFER_IDX (COMMAND_COMPLETE_IDX + COMMAND_COMPLETE_SIZE)\n#define USED_WRITE_BUFFER_SIZE (COMMAND_COMPLETE_SIZE + xilWriteDataAvail)\n#define WRITE_BUFFER_SIZE (XIL_TX_BUFFER_MEMUNIT_SIZE - COMMAND_COMPLETE_SIZE - BUFFER_HEADER_SIZE)\n\n\nstatic void* pBuffer;\nstatic IOUnit_T* xilWriteBuffer;\nstatic IOUnit_T* xilWriteDataPtr;\nstatic uint16_T xilWriteDataAvail;\nstatic MemUnit_T* commandResponseType;\n\n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void) {\n    \n    /* Ask the CS to allocate a buffer that the XIL app service will use for\n     * transmission\n     */\n    if (!xilTgtAppSvcAllocBuffer(&pBuffer, XIL_TX_BUFFER_MEMUNIT_SIZE)) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    xilWriteBuffer = xilTgtAppSvcGetBufferDataPtr(pBuffer);\n    \n    /* set commandResponseType and xilWriteDataPtr pointer */\n    commandResponseType = (MemUnit_T *) &xilWriteBuffer[COMMAND_COMPLETE_IDX];\n    xilWriteDataPtr = &xilWriteBuffer[WRITE_DATA_BUFFER_IDX];\n    \n    /* ready for next command */\n    xilWriteDataAvail = 0;\n    *commandResponseType = XIL_COMMAND_NOT_COMPLETE;\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void) {\n    \n    /* Create XIL service */\n    if (xilTgtAppSvcCreate() != XILTGTAPPSVC_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    /* Reset write buffer */\n    return resetXILWriteBuffer();\n}\n\n/* send pending writes */\nstatic XIL_DATA_STREAM_ERROR_CODE sendWriteBuffer(void) {\n       \n    if (xilTgtAppSvcSend(pBuffer, USED_WRITE_BUFFER_SIZE) == XILTGTAPPSVC_ERROR) {\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n   /* reset */\n   if (resetXILWriteBuffer()!= XIL_INTERFACE_LIB_SUCCESS) {\n\t   return XIL_DATA_FLUSH_ERROR;\n   }\n   \n   return XIL_DATA_STREAM_SUCCESS;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T * src, uint32_T size) {\n   XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n   const IOUnit_T * srcPtr = (const IOUnit_T *) src;   \n   size_t transferAmount;\n   uint16_T bufferAvail;\n  \n   /* block until all data is processed */\n   while (size > 0) {      \n      /* send if we have a full message worth of data */   \n      if (xilWriteDataAvail == WRITE_BUFFER_SIZE) {\n         errorCode = sendWriteBuffer();\n         if (errorCode != XIL_DATA_STREAM_SUCCESS) {\n            return errorCode;\n         }\n      }\n      bufferAvail = WRITE_BUFFER_SIZE - xilWriteDataAvail;\n      transferAmount = (uint16_T) MIN(bufferAvail, size);\n      /* copy data into write buffer */\n      memcpy((void *) xilWriteDataPtr, srcPtr, transferAmount);\n      size -= (uint32_T) transferAmount;\n      xilWriteDataAvail += (uint16_T) transferAmount;\n      srcPtr += transferAmount;\n      xilWriteDataPtr += transferAmount;\n   }\n   return errorCode;\n}\n\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T * dst, uint32_T size) {\n\n    XIL_DATA_STREAM_ERROR_CODE errorCode = XIL_DATA_STREAM_SUCCESS;\n     \n    static IOUnit_T* currentBufferPosition = NULL;\n    static uint16_T currentBufSize = 0;\n    uint16_T readAmount;\n    int32_T index = 0;\n    int rtIOStreamErrorStatus;\n    IOUnit_T * dstPtr = (IOUnit_T *) dst;\n\n    while (size > 0)\n    {\n        if (currentBufSize > 0) {\n\n            readAmount = (uint16_T) MIN(currentBufSize, size);\n            memcpy(dstPtr+index, currentBufferPosition, (size_t)readAmount);\n\n            currentBufSize -= readAmount;\n            currentBufferPosition +=readAmount;\n            size -= (uint32_T)readAmount;\n\n            if (size == 0) {\n                /* If we've satisfied the data request we're done, return */\n                return errorCode;\n            }\n\n            /*Buffer empty and more data needed get new data*/\n            index += (int32_T)readAmount;\n        }\n\n        /* Get NEW DATA */\n#ifdef USING_CS_API\n        {\n            uint16_T tmpSize = 0;\n            static uint8_T * tmpData;\n            static boolean_T firstTime = true;\n\n            /*If we've previously read a message free it before getting the next*/\n            if (!firstTime)\n            {\n                xilTgtAppSvcFreeLastReceivedData();\n            }\n            \n            /*Block until a message has been received*/\n            while (tmpSize == 0)\n            {\n                tmpData = xilTgtAppSvcGetReceivedData(&tmpSize);\n            }\n\n            /*Update first time flag*/\n            firstTime = false;\n\n            /*Setup buffer position and size from message data*/\n            currentBufSize = tmpSize;\n            currentBufferPosition = (IOUnit_T *)tmpData;\n        }\n#else\n        rtIOStreamErrorStatus = rtiostreamReadMessage(&currentBufferPosition, &currentBufSize);\n\n        if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    \treturn XIL_READ_DATA_ERROR;\n\n    \n#endif\n    }\n\n    return errorCode;\n}\n\n\n\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep) {\n    \n    /* final part of command */\n    if (isEndOfXILStep) {\n        *commandResponseType = XIL_STEP_COMPLETE;\n    } else {\n        *commandResponseType = XIL_COMMAND_COMPLETE;\n    }\n\n    /* send the write buffer */\n    if (sendWriteBuffer() == XIL_DATA_FLUSH_ERROR){\n        return XIL_DATA_FLUSH_ERROR;\n    }\n    \n    return XIL_DATA_STREAM_SUCCESS;\n\n}\n\nvoid silpilTerminate(void) {\n    xilTgtAppSvcDestroy();\n}\n\n\n"},{"name":"xil_data_stream.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2007-2016 The MathWorks, Inc. */\n\n/* \n * File: xil_data_stream.h\n */\n\n#ifndef XIL_DATA_STREAM_H\n#define XIL_DATA_STREAM_H\n\n#include \"xil_common.h\"\n#include \"xil_error_codes.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n/* reset the write buffer */\nXIL_INTERFACE_LIB_ERROR_CODE resetXILWriteBuffer(void);\n/* copy specified amount of data from the address specified to the output stream */\nXIL_DATA_STREAM_ERROR_CODE xilWriteData(const MemUnit_T *, uint32_T);\n/* copy specified amount of data from the input stream to address specified */\nXIL_DATA_STREAM_ERROR_CODE xilReadData(MemUnit_T *, uint32_T );\n/* flush any buffered writes */\nXIL_DATA_STREAM_ERROR_CODE xilDataFlush(MemUnit_T isEndOfXILStep);\n/* initialize SIL/PIL service */ \nXIL_INTERFACE_LIB_ERROR_CODE silpilInit(void);\n/* terminate SIL/PIL service */\nvoid silpilTerminate(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface.c","type":"source","group":"SILPIL","path":"C:\\Users\\Mohand\\Desktop\\MBSE\\DC_Motor_Position_Control\\DCMotor_Control_ert_rtw\\sil","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/*\r\n * File: xil_interface.c\r\n *\r\n * SIL generated interface for code: \"DCMotor_Control\"\r\n *\r\n */\r\n\r\n#include \"DCMotor_Control.h\"\r\n#include \"xil_interface.h\"\r\n\r\n/* Functions with a C call interface */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#include \"xil_data_stream.h\"\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n/* In-the-Loop Interface functions - see xil_interface.h */\r\nXIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T xilFcnId)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void)\r\n{\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  {\r\n  }\r\n\r\n  /* initialize output storage owned by In-the-Loop */\r\n\r\n  /* Initialize Opaque Region Based Data */\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    DCMotor_Control_initialize();\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilPause(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  if (xilFcnId == 0) {\r\n    /* Nothing to do */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n    /* No Function to Call */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T xilFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId == 0) {\r\n    /* No Function to Call */\r\n  } else {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n  UNUSED_PARAMETER(xilCommandType);\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }                                    /* if */\r\n\r\n  errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n  UNUSED_PARAMETER(xilCommandType);\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  UNUSED_PARAMETER(responseId);\r\n  UNUSED_PARAMETER(serverFcnId);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilOutput(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  switch (xilTID) {\r\n   case 1:\r\n    DCMotor_Control_step();\r\n    break;\r\n\r\n   default:\r\n    return XIL_INTERFACE_UNKNOWN_TID;\r\n  }\r\n\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  /* No Update Function */\r\n  UNUSED_PARAMETER(xilTID);\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T xilFcnId,\r\n  XIL_COMMAND_TYPE_ENUM xilCommandType, uint32_T xilCommandIdx, XILIOData\r\n  ** xilIOData, MemUnit_T responseId, uint32_T serverFcnId)\r\n{\r\n  XIL_INTERFACE_ERROR_CODE errorCode = XIL_INTERFACE_SUCCESS;\r\n\r\n  /* Single In-the-Loop Component */\r\n  *xilIOData = 0;\r\n  if (xilFcnId != 0) {\r\n    errorCode = XIL_INTERFACE_UNKNOWN_FCNID;\r\n    return errorCode;\r\n  }\r\n\r\n  errorCode = XIL_INTERFACE_UNKNOWN_TID;\r\n  UNUSED_PARAMETER(xilCommandType);\r\n  UNUSED_PARAMETER(xilCommandIdx);\r\n  UNUSED_PARAMETER(responseId);\r\n  UNUSED_PARAMETER(serverFcnId);\r\n  return errorCode;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T xilFcnId)\r\n{\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }                                    /* if */\r\n\r\n  /* Invoke any terminate Function */\r\n  /* No Function to Call */\r\n\r\n  /* Free Opaque Region Based Data */\r\n  return XIL_INTERFACE_SUCCESS;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilEnable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Enable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n\r\nXIL_INTERFACE_ERROR_CODE xilDisable(uint32_T xilFcnId, uint32_T xilTID)\r\n{\r\n  /* Single In-the-Loop Component */\r\n  if (xilFcnId != 0) {\r\n    return XIL_INTERFACE_UNKNOWN_FCNID;\r\n  }\r\n\r\n  UNUSED_PARAMETER(xilTID);\r\n\r\n  /* No Disable Function - this function should never be called */\r\n  return XIL_INTERFACE_UNKNOWN_TID;\r\n}\r\n"},{"name":"xil_interface.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface.h\n *\n * SIL/PIL interface functions\n */\n\n#ifndef __XIL_INTERFACE_H__\n#define __XIL_INTERFACE_H__\n\n/* include rtwtypes.h & XILIOData */\n#include \"xil_interface_common.h\"\n\n/* Generated xil_interface.c may use xilCommandDispatchAndResponse for client/server */\n#include \"xil_interface_lib.h\"\n\n/* xil_interface.c|cpp always presents a C \n * function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {  /* sbcheck:ok:extern_c needed to ensure correct linking*/\n#endif\n\n/* Get data type information - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilGetDataTypeInfo(void);\n\n/* Process Parameters - called from mdlProcessParameters / mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilProcessParams(uint32_T);\n\n/* Initialize - called from mdlStart */\nextern XIL_INTERFACE_ERROR_CODE xilInitialize(uint32_T);\n\n/* System Initialize - called from mdlSystemInitialize (or mdlInitializeConditions) */\nextern XIL_INTERFACE_ERROR_CODE xilSystemInitialize(uint32_T);\n\n/* System Reset - called from mdlSystemReset */\nextern XIL_INTERFACE_ERROR_CODE xilSystemReset(uint32_T);\n\n/* Initialize input XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetHostToTargetData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **);\n\n/* Output - called from mdlOutputs */\nextern XIL_INTERFACE_ERROR_CODE xilOutput(uint32_T, uint32_T);\n\n/* Update - called from mdlOutputs (not mdlUpdate) */\nextern XIL_INTERFACE_ERROR_CODE xilUpdate(uint32_T, uint32_T);\n\n/* Initialize output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Initialize state output XILIOData pointer */\nextern XIL_INTERFACE_ERROR_CODE xilGetTargetToHostPreData(uint32_T, XIL_COMMAND_TYPE_ENUM, uint32_T, XILIOData **, MemUnit_T responseId, uint32_T serverFcnId);\n\n/* Terminate - called from mdlTerminate */\nextern XIL_INTERFACE_ERROR_CODE xilTerminate(uint32_T);\n\n/* Enable - called from mdlEnable */\nextern XIL_INTERFACE_ERROR_CODE xilEnable(uint32_T, uint32_T);\n\n/* Disable - called from mdlDisable */\nextern XIL_INTERFACE_ERROR_CODE xilDisable(uint32_T, uint32_T);\n\n/* Pause - called from mdlSimStatusChange */\nextern XIL_INTERFACE_ERROR_CODE xilPause(uint32_T);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_common.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/*\n * File: xil_interface_common.h\n *\n * SIL/PIL common definitions\n */\n\n#ifndef __XIL_INTERFACE_COMMON_H__\n#define __XIL_INTERFACE_COMMON_H__\n\n#include \"xil_common.h\"\n\n/* define some error codes */\ntypedef enum {XIL_INTERFACE_SUCCESS=0, \n              XIL_INTERFACE_UNKNOWN_TID,\n              XIL_INTERFACE_UNKNOWN_FCNID,\n              XIL_INTERFACE_COMMS_FAILURE,\n              XIL_INTERFACE_MEMORY_ALLOCATION_ERROR,\n              XIL_INTERFACE_OFFLOADED_PROCESSING} XIL_INTERFACE_ERROR_CODE;\n\ntypedef enum {XIL_INIT_COMMAND = 0, \n              XIL_INITIALIZE_COMMAND,\n              XIL_SYSTEM_INITIALIZE_COMMAND,\n              XIL_OUTPUT_COMMAND, \n              XIL_TERMINATE_COMMAND, \n              XIL_ENABLE_COMMAND,\n              XIL_DISABLE_COMMAND, \n              XIL_CONST_OUTPUT_COMMAND, \n              XIL_PROCESS_PARAMS_COMMAND,\n              XIL_CLIENT_SERVER_COMMAND,\n              XIL_SHUTDOWN_COMMAND,\n              XIL_UPDATE_COMMAND,\n              XIL_SYSTEM_RESET_COMMAND,\n              XIL_PAUSE_COMMAND} XIL_COMMAND_TYPE_ENUM;\n\n/* define response ids */\ntypedef enum {XIL_RESPONSE_ERROR=0, \n              XIL_RESPONSE_OUTPUT_PRE_DATA,\n              XIL_RESPONSE_OUTPUT_DATA,              \n              XIL_RESPONSE_PRINTF,\n              XIL_RESPONSE_FOPEN,\n              XIL_RESPONSE_FPRINTF,\n              XIL_RESPONSE_SIGNAL_RAISED,\n              XIL_RESPONSE_TYPE_SIZE,\n              XIL_RESPONSE_CS_REQUEST_SERVICE              \n              } XIL_RESPONSE_ID;\n\n/* define receive states */\ntypedef enum {XIL_INVALID_STATE=-1,\n              XIL_READ_COMMAND_CODE,\n              XIL_READ_FCNID,\n              XIL_READ_XILTID,\n              XIL_PROCESS_TARGET_TO_HOST_PRE_DATA,\n              XIL_PROCESS_HOST_TO_TARGET_DATA,\n              XIL_CALL_XILINTERFACE,\n              XIL_PROCESS_TARGET_TO_HOST_DATA,\n              XIL_COMPLETE} XIL_HANDLE_RECV_STATE;\n\n/* Defines what states we need to save to make xilProcessMsg re-entrant. \n * This is used by client/server commands which could happen in the middle \n * of a step */\ntypedef struct xilProcessMsgContextSwitch {\n\tXIL_HANDLE_RECV_STATE state;\n\tXIL_COMMAND_TYPE_ENUM command;\n\tuint32_T commandIdx;\n\tuint32_T fcnId;\n} XIL_PROCESS_MSG_CONTEXT_SWITCH;\n\n/* XILIOData is defined as a start address\n * and length in MemUnits */\ntypedef struct xilIOData {\n   uint32_T memUnitLength;\n   MemUnit_T * address;\n} XILIOData;\n\n#endif\n"},{"name":"xil_interface_lib.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2019 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.c\n *\n * SIL/PIL support library\n *\n */\n\n#include \"xil_interface_lib.h\"\n#include \"xil_interface_lib_private.h\"\n#include \"xil_data_stream.h\"\n#include \"codeinstr_data_stream.h\"\n#include \"xil_interface.h\"\n#include \"coder_assumptions_app.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n#ifdef LDRA_ENABLED\n#include \"code_coverage_utils.h\"\n#endif /* LDRA_ENABLED */\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    void swapBytes(MemUnit_T * const buffer, uint32_T size);\n    static XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* Internal state variable holding information about the\n * XILIOData currently being processed. \n *\n * Note: this variable is shared by UDATA processing code\n * and YDATA processing code and used for all IO.\n *\n */\nstatic XILIOData * xilIODataPtr;\nstatic int isShutdownCommand = 0;\nstatic int processMsgSuccess = 1;\n\n/* xilProcessMsg current context (cc)*/\nstatic XIL_PROCESS_MSG_CONTEXT_SWITCH cc = {XIL_READ_COMMAND_CODE, XIL_INIT_COMMAND, 0, 0};\n\n/* static functions */\nstatic void restoreProcessMsgContext(XIL_PROCESS_MSG_CONTEXT_SWITCH cachedCtx) {\n    cc.state      = cachedCtx.state;\n    cc.command    = cachedCtx.command;\n    cc.commandIdx = cachedCtx.commandIdx;\n    cc.fcnId      = cachedCtx.fcnId;\n}\n\nstatic void getNextXILIOData(void) {\n   /* increment xilIOData ptr if we have not reached the end */\n   if (xilIODataPtr->memUnitLength!=0) {\n      xilIODataPtr++;\n   }\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processHostToTargetData(uint32_T fcnId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n    \n    /* this function receives some arbitrary data size that needs to be \n     * into the appropriate memory addresses. Since it is not guaranteed \n     * that we will copy all the required data in one go, we need to keep \n     * track of which address (and size) in xilIODataPtr we last copied \n     * to so we can continue copying the remaining data the next time we \n     * receive them.\n     */\n    static MemUnit_T * uDataAddress = NULL;\n    static uint32_T uDataLength = 0;\n    int processingComplete = 0;\n        \n\t/* initialize uDataAddress and uDataLength if necessary*/\n    if (uDataAddress == NULL) {\n\t\t/* initialise xilIODataPtr before beginning to process data */\n\t\tif (xilGetHostToTargetData(fcnId, command, commandIdx, &xilIODataPtr)) {\n\t\t\t/* no udata processing to be done - we're complete */\n\t\t\tprocessingComplete = 1;\t\t\t\n\t\t\treturn XIL_PROCESSDATA_SUCCESS;\n\t\t}\n\n        uDataAddress = xilIODataPtr->address;\n        uDataLength = xilIODataPtr->memUnitLength;\n    }\n    \n    while(!(processingComplete)) {\n        xilReadData(uDataAddress, uDataLength);\n        getNextXILIOData();\n            \n        if (xilIODataPtr->memUnitLength == 0) {\n            /* done processing all xilIOData */                \n            processingComplete = 1;\n            uDataAddress = NULL;\n        } else {\n            /* reset our pointer to next xilIOData */\n            uDataAddress = xilIODataPtr->address;\n            uDataLength = xilIODataPtr->memUnitLength;\n        }\n    }\n\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx,\n        uint32_T serverFcnId)  {\n        \n    int moreXILData = 1;\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n\n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_PROCESSDATA_ERROR_CODE processTargetToHostPreData(uint32_T fcnId,\n        MemUnit_T responseId,\n        XIL_COMMAND_TYPE_ENUM command,\n        uint32_T commandIdx)  {\n        \n    int moreXILData = 1;\n    uint32_T serverFcnId = 0; /*Default server function ID*/\n    \n    /* initialise before beginning to process data */    \n    if (xilGetTargetToHostPreData(fcnId, command, commandIdx, &xilIODataPtr, responseId, serverFcnId)) {\n        /* no ydata processing to be done - we're complete */        \n        return XIL_PROCESSDATA_SUCCESS;\n    }\n    \n    while(moreXILData) {\n        if (xilWriteData(xilIODataPtr->address, xilIODataPtr->memUnitLength) != XIL_DATA_STREAM_SUCCESS) {            \n            return XIL_PROCESSDATA_DATA_STREAM_ERROR;\n        }\n        /* get next xilIOData */\n        getNextXILIOData();\n        if (xilIODataPtr->memUnitLength == 0) {\n            moreXILData = 0;\n        }\n    }\n    return XIL_PROCESSDATA_SUCCESS;\n}\n\nstatic XIL_INTERFACE_LIB_ERROR_CODE finalizeCommandResponse(XIL_RESPONSE_ERROR_ID errorId, MemUnit_T isEndOfXILStep)  {\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n    /* flush the output stream\n     * before beginning next command */\n    if (codeInstrDataFlush() != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n   /* only send the error id if necessary */\n   if (errorId != XIL_RESPONSE_ERROR_SUCCESS) {\n      /* send response id code */\n      MemUnit_T memUnitData = XIL_RESPONSE_ERROR;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;      \n      }\n      /* send error id */\n\t  memUnitData = (MemUnit_T) errorId;\n      if (xilWriteData(&memUnitData, sizeof(memUnitData)) != XIL_DATA_STREAM_SUCCESS) {\n         return XIL_INTERFACE_LIB_ERROR;      \n      }\t  \n   }\n   /* flush the output stream \n    * before beginning next command */\n   if (xilDataFlush(isEndOfXILStep) != XIL_DATA_STREAM_SUCCESS) {\n      return XIL_INTERFACE_LIB_ERROR;      \n   }   \n   return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Given current state and command, compute the next state for handleReceive */\nstatic XIL_HANDLE_RECV_STATE computeNextState(XIL_HANDLE_RECV_STATE state, XIL_COMMAND_TYPE_ENUM command) {\n    \n    XIL_HANDLE_RECV_STATE nextState;\n    \n    switch(state) {\n        case XIL_READ_COMMAND_CODE:\n            switch(command) {\n                case XIL_INIT_COMMAND:                    \n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                case XIL_SHUTDOWN_COMMAND:\n                    nextState = XIL_READ_FCNID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_READ_FCNID:\n            switch(command) {\n                case XIL_INIT_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_CONST_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:  \n                case XIL_UPDATE_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_READ_XILTID;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;            \n        case XIL_READ_XILTID:\n            switch(command) {\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_CLIENT_SERVER_COMMAND:\n                case XIL_OUTPUT_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                    nextState = XIL_PROCESS_HOST_TO_TARGET_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_HOST_TO_TARGET_DATA:\n            switch(command) {\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:                \n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:\n                case XIL_TERMINATE_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                case XIL_UPDATE_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_PROCESS_TARGET_TO_HOST_PRE_DATA;\n                    break;\n                case XIL_CLIENT_SERVER_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_PRE_DATA:\n            switch(command) {\n                case XIL_OUTPUT_COMMAND:\n                    nextState = XIL_CALL_XILINTERFACE;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_CALL_XILINTERFACE:\n            switch(command) {\n                case XIL_UPDATE_COMMAND:\n                case XIL_INIT_COMMAND:\n                case XIL_PROCESS_PARAMS_COMMAND:\n                    nextState = XIL_COMPLETE;\n                    break;\n                case XIL_INITIALIZE_COMMAND:\n                case XIL_SYSTEM_INITIALIZE_COMMAND:\n                case XIL_CONST_OUTPUT_COMMAND:\n                case XIL_ENABLE_COMMAND:\n                case XIL_DISABLE_COMMAND:                \n                case XIL_OUTPUT_COMMAND:\n                case XIL_SYSTEM_RESET_COMMAND:\n                case XIL_PAUSE_COMMAND:\n                case XIL_TERMINATE_COMMAND:   \n                    nextState = XIL_PROCESS_TARGET_TO_HOST_DATA;\n                    break;\n                default:\n                    nextState = XIL_INVALID_STATE;\n                    break;\n            }\n            break;\n        case XIL_PROCESS_TARGET_TO_HOST_DATA:\n            /* done */\n            nextState = XIL_COMPLETE;\n            break;\n        default:\n            nextState = XIL_INVALID_STATE;\n            break;\n    }\n    return nextState;\n}\n\n#define XIL_COMMAND_TYPE_SIZE sizeof(MemUnit_T)\n#define XIL_COMMAND_CODE_IDX 0\n#define XIL_COMMAND_FCNID_IDX (XIL_COMMAND_CODE_IDX + XIL_COMMAND_TYPE_SIZE)\n#define XIL_COMMAND_FCNID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_XILTID_IDX (XIL_COMMAND_FCNID_IDX + XIL_COMMAND_FCNID_SIZE)\n#define XIL_COMMAND_XILTID_SIZE sizeof(uint32_T)\n#define XIL_COMMAND_ERROR_STATUS_SIZE sizeof(MemUnit_T)\n\n#define XIL_RUN_EXIT_ERROR processMsgSuccess = 0;      \\\n                           return\n#define XIL_RUN_EXIT return\n\n#define XIL_EXIT_ERROR_IF_INVALID_STATE if (cc.state == XIL_INVALID_STATE) {      \\\n                                         XIL_RUN_EXIT_ERROR;                   \\\n                                      }                                                                                           \n\nstatic void xilReadCommandCode(void) {\n    MemUnit_T commandCode;    \n    if (cc.state==XIL_READ_COMMAND_CODE) {\n        /* read commandCode */\n\n        xilReadData(&(commandCode), XIL_COMMAND_TYPE_SIZE);\n\n        /* cast from the MemUnit commandCode to the enumeration commandCode */\n        cc.command = (XIL_COMMAND_TYPE_ENUM) commandCode;\n            \n        if (cc.command == XIL_SHUTDOWN_COMMAND) {\n\t\t\t/* Terminate this process when XIL simulation is complete */\n            isShutdownCommand = 1;             \n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        } else {\n            /* compute next state */\n            cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n        }\n    }\n}\n                           \nvoid xilProcessMsg(void) { \n    /* read commandCode */\n    xilReadCommandCode();\n    \n    if (cc.state==XIL_READ_FCNID) {\n        /* read fcnId */\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.fcnId)), XIL_COMMAND_FCNID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n        \n\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n        \n    if (cc.state==XIL_READ_XILTID) {\n        /* read commandIdx */\n        \n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n        xilReadDataAndSwapBytes(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#else\n        xilReadData(((MemUnit_T*)&(cc.commandIdx)), XIL_COMMAND_XILTID_SIZE);\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n        \n    if (cc.state == XIL_PROCESS_HOST_TO_TARGET_DATA) {\n        /* process inputs if required by command */\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from host */\n        processDataError = processHostToTargetData(cc.fcnId, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_UDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n            \n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE\n    }\n        \n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_PRE_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        /* process data from target */\n        processDataError = processTargetToHostPreData(cc.fcnId, XIL_RESPONSE_OUTPUT_PRE_DATA, cc.command, cc.commandIdx);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n            XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n\n    if (cc.state == XIL_CALL_XILINTERFACE) {\n        /* call xilInterface function */\n        switch(cc.command) {\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_INIT_COMMAND:\n            {\n#if CODER_ASSUMPTIONS_ENABLED == 1\n                /* run validation of coder assumptions */\n                if (coderAssumptionsRun() != XIL_INTERFACE_LIB_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                } \n#endif\n                if (xilGetDataTypeInfo() != XIL_INTERFACE_SUCCESS) {\n                    XIL_RUN_EXIT_ERROR;\n                }\n                break;\n            }\n            case XIL_CONST_OUTPUT_COMMAND:\n                /* no function */\n                break;\n            case XIL_PROCESS_PARAMS_COMMAND:\n                if (xilProcessParams(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_PARAMS, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_INITIALIZE_COMMAND:\n                if (xilInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_PAUSE_COMMAND:\n                if (xilPause(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_SYSTEM_INITIALIZE_COMMAND:\n                if (xilSystemInitialize(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_TERMINATE_COMMAND:\n                if (xilTerminate(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_TERMINATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_ENABLE_COMMAND:\n                if (xilEnable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_ENABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_DISABLE_COMMAND:\n                if (xilDisable(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_DISABLE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n            case XIL_UPDATE_COMMAND:\n                if (xilUpdate(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_UPDATE, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    } else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#endif\n            case XIL_OUTPUT_COMMAND:\n                if (xilOutput(cc.fcnId, cc.commandIdx) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_OUTPUT, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }\n                break;\n#ifndef OUT_OF_PROCESS_EXEC\n            case XIL_SYSTEM_RESET_COMMAND:\n                if (xilSystemReset(cc.fcnId) != XIL_INTERFACE_SUCCESS) {\n                    if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SYSTEM_RESET, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                        XIL_RUN_EXIT_ERROR;\n                    }\n                    else {\n                        XIL_RUN_EXIT;\n                    }\n                }                     \n                break;\n#endif\n            default:\n                XIL_RUN_EXIT_ERROR;\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n    }\n    if (cc.state == XIL_PROCESS_TARGET_TO_HOST_DATA) {\n        XIL_PROCESSDATA_ERROR_CODE processDataError;\n        uint32_T serverFcnId = 0; /* Default server function ID */\n        /* process data from target */\n        processDataError = processTargetToHostData(cc.fcnId, XIL_RESPONSE_OUTPUT_DATA, cc.command, cc.commandIdx, serverFcnId);\n        if (processDataError == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n            XIL_RUN_EXIT_ERROR;\n        } else if (processDataError != XIL_PROCESSDATA_SUCCESS) {\n            if (finalizeCommandResponse(XIL_RESPONSE_ERROR_PROCESS_YDATA, 1) != XIL_INTERFACE_LIB_SUCCESS) {\n                XIL_RUN_EXIT_ERROR;\n            }\n            else {\n                XIL_RUN_EXIT;\n            }\n        }\n        /* compute next state */\n        cc.state = computeNextState(cc.state, cc.command);\n        XIL_EXIT_ERROR_IF_INVALID_STATE;\n        /*break;*/\n    }\n        \n\n#ifdef LDRA_ENABLED\n    /* upload code coverage execution history from target*/\n    if (cc.command == XIL_TERMINATE_COMMAND) {\n        callTargetUploadFcns();\n    }\n#endif /* LDRA_ENABLED */\n                \n    /* client/server commands could be executed in the middle of a step */\n    if ((cc.state == XIL_COMPLETE) && (cc.command != XIL_CLIENT_SERVER_COMMAND)) { \n        /* finalize the response */\n        MemUnit_T isEndOfXILStep = 1;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) != XIL_INTERFACE_LIB_SUCCESS) {\n            XIL_RUN_EXIT_ERROR;\n        }\n        \n        /* reset state */\n        cc.state = XIL_READ_COMMAND_CODE;\n    }\n\n    XIL_RUN_EXIT;\n    \n}\n\nXIL_INTERFACE_LIB_ERROR_CODE xilRun(void) {\n    XIL_INTERFACE_LIB_ERROR_CODE errorCode = XIL_INTERFACE_LIB_SUCCESS;\n\n    /* read one msg and pass to owning application */\n    xilProcessMsg();\n    \n    if (processMsgSuccess) {        \n        if (isShutdownCommand) {\n            errorCode = XIL_INTERFACE_LIB_TERMINATE;\n        } else {\n            errorCode = XIL_INTERFACE_LIB_SUCCESS;\n        }\n        \n    } else {\n        errorCode = XIL_INTERFACE_LIB_ERROR;\n    }\n    return errorCode;\n}\n\n/* Dispatch and receive client/server commands within a step */\nvoid xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                   uint32_T xilCommandIdx, uint32_T xilFcnId, \n                                   uint32_T svrFcnId, MemUnit_T xilResponseId,\n                                   XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx) {\n\n    /* define a binary flag, each CS command needs to process a response */\n    int needToProcessCSResponse = 1;\n    \n    /* send input data to the host */\n    if (processTargetToHostData(xilFcnId, xilResponseId, xilCommandType, \n            xilCommandIdx, svrFcnId) == XIL_PROCESSDATA_DATA_STREAM_ERROR) {\n        restoreProcessMsgContext(callerCtx);\n        XIL_RUN_EXIT_ERROR;\n    }\n    \n    /* finalize the response */\n    {\n        MemUnit_T isEndOfXILStep = 0;\n        if (finalizeCommandResponse(XIL_RESPONSE_ERROR_SUCCESS, isEndOfXILStep) !=\n                XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    /* reset state for new context, recursive calls are safe because all\n     * the caller contexts (callerCtx) are cached in the stack */\n    cc.state = XIL_READ_COMMAND_CODE;\n    \n    while(needToProcessCSResponse) {\n        /* read next command requested by the host */\n        xilReadCommandCode();\n        if (cc.command == XIL_CLIENT_SERVER_COMMAND) {\n            /* if the host sent a response to the server call, process it\n             * and then exit the loop. Otherwise, process the current \n             * command and read the next one */\n            needToProcessCSResponse = 0;\n        }\n        /* process response data sent by host */\n        if (xilRun() != XIL_INTERFACE_LIB_SUCCESS) {\n            restoreProcessMsgContext(callerCtx);\n            XIL_RUN_EXIT_ERROR;\n        }\n    }\n    \n    restoreProcessMsgContext(callerCtx);\n    \n}\n\nXIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void) {\n    /* return the current context (cc) */\n    return cc;\n}\n\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n\nvoid swapBytes(MemUnit_T * const buffer, uint32_T size) {\n    MemUnit_T tmp;\n    MemUnit_T *headPtr;\n    MemUnit_T *tailPtr;\n    uint32_T idx;\n\n    for(idx = 0; idx < size/2; idx ++) {\n        headPtr = buffer + idx; \n        tailPtr = buffer + size -1 - idx;\n        tmp = *headPtr;\n        *headPtr = *tailPtr;\n        *tailPtr = tmp;\n    }\n}\n\nstatic XIL_DATA_STREAM_ERROR_CODE xilReadDataAndSwapBytes(MemUnit_T * dst, uint32_T size) {\n    XIL_DATA_STREAM_ERROR_CODE readDataVal = xilReadData(dst, size);\n\n    if (readDataVal == XIL_DATA_STREAM_SUCCESS) {\n        swapBytes(dst, size);\n    }\n    return readDataVal;\n}\n\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n"},{"name":"xil_interface_lib.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2018 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_H__\n#define __XIL_INTERFACE_LIB_H__\n\n#include \"xil_error_codes.h\"\n#include \"xil_common.h\"\n#include \"xil_interface_common.h\" \n\n/* always present a C function-call interface for xil_interface_lib.c */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* xil interface functions to be called from main */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, \n                                            void *argv[]);\nextern XIL_INTERFACE_LIB_ERROR_CODE xilRun(void);\n\n/* terminate XIL communications */\nextern XIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void);\n\n/* Dispatch and receive client/server commands within a step */\nextern void xilCommandDispatchAndResponse(XIL_COMMAND_TYPE_ENUM xilCommandType, \n                                          uint32_T xilCommandIdx, uint32_T xilFcnId,\n                                          uint32_T serverFcnId, MemUnit_T xilResponseId,\n                                          XIL_PROCESS_MSG_CONTEXT_SWITCH callerCtx);\n\n/* return the current context (cc) */\nextern XIL_PROCESS_MSG_CONTEXT_SWITCH xilGetCurrentProcessMsgContext(void);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"},{"name":"xil_interface_lib_private.h","type":"header","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2006-2017 The MathWorks, Inc. */\n\n/* \n * File: xil_interface_lib_private.h\n *\n * SIL/PIL support library\n */\n\n#ifndef __XIL_INTERFACE_LIB_PRIVATE_H__\n#define __XIL_INTERFACE_LIB_PRIVATE_H__\n\n#include \"xil_interface_common.h\"\n\n/* Enumeration to denote UDATA or YDATA processing */\ntypedef enum {XIL_UDATA_IO = 0, XIL_YDATA_IO} XIL_IO_TYPE;\n\n/* define some error codes */\ntypedef enum {XIL_PROCESSDATA_SUCCESS=0, \n              XIL_PROCESSDATA_DATA_STREAM_ERROR, \n              XIL_PROCESSDATA_IO_TYPE_ERROR} XIL_PROCESSDATA_ERROR_CODE;\n\n/* define error response error ids */\ntypedef enum {XIL_RESPONSE_ERROR_SUCCESS=0,\n              XIL_RESPONSE_ERROR_PROCESS_UDATA,\n              XIL_RESPONSE_ERROR_PROCESS_YDATA, \n              XIL_RESPONSE_ERROR_PROCESS_PARAMS, \n              XIL_RESPONSE_ERROR_INITIALIZE,\n              XIL_RESPONSE_ERROR_SYSTEM_INITIALIZE, \n              XIL_RESPONSE_ERROR_OUTPUT, \n              XIL_RESPONSE_ERROR_UPDATE,\n              XIL_RESPONSE_ERROR_TERMINATE,\n              XIL_RESPONSE_ERROR_ENABLE, \n              XIL_RESPONSE_ERROR_DISABLE, \n              XIL_RESPONSE_ERROR_SYSTEM_RESET} XIL_RESPONSE_ERROR_ID;\n\n/* static functions */\nstatic void getNextXILIOData(void);\n  \nstatic XIL_HANDLE_RECV_STATE computeNextState(\n        XIL_HANDLE_RECV_STATE currentState,\n        XIL_COMMAND_TYPE_ENUM command);\n\n\n#endif\n"},{"name":"xil_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_XILTGTAPPSVC_SUCCESS\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc_CInterface.h\"\n\n/* XIL buffer is statically allocated for rtiostream-based implementation */\nstatic IOUnit_T xilWriteBuffer[XIL_TX_BUFFER_MEMUNIT_SIZE];\n\nextern uint8_T xilTgtAppSvcCreate(void) {\n    return XILTGTAPPSVC_SUCCESS;\n}\n\nextern void xilTgtAppSvcDestroy(void) {\n}\n\n/* Allocation method simply returns the statically allocated buffer */\nextern uint8_T xilTgtAppSvcAllocBuffer(\n        void** ppBuf,\n        const uint16_T dataSize) {\n    \n    /* buffer is already statically allocated */\n    *ppBuf = &xilWriteBuffer[APPLICATION_ID_IDX];\n    \n    UNUSED_PARAMETER(dataSize);\n    \n    /* nothing to do as buffer is already statically allocated */\n    return XILTGTAPPSVC_SUCCESS;\n}\n\n/* return pointer to XIL buffer data */\nextern IOUnit_T * xilTgtAppSvcGetBufferDataPtr(\n        void* const pBuf) {\n    \n    /* buffer is already statically allocated */\n    UNUSED_PARAMETER(pBuf);\n       \n    return &xilWriteBuffer[PAYLOAD_IDX];\n}\n\n/* send data over rtiostream */\nextern uint8_T xilTgtAppSvcSend(\n        void* const pBuf,        \n        const uint16_T dataSize) {\n    \n    return (uint8_T)commsEnqueueBuffer(pBuf, XIL_RTIOSTREAM_BASED_SERVICE_ID, dataSize);\n}\n\n"},{"name":"xil_services.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#ifdef XIL_SIGNAL_HANDLER\n#include <signal.h>\n#include <stdio.h>\n#if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n        #include <execinfo.h>\n        #define MAX_STACKTRACE 12\n    #endif\n#endif\n\n#ifdef SIL_DISABLE_SUBNORMAL_SUPPORT\n    #if SIL_DISABLE_SUBNORMAL_SUPPORT >= 1 \n#include <immintrin.h>\n    #endif\n#endif\n\n#define USE_COMMS_SUCCESS\n#include \"xil_error_codes.h\"\n#include \"xil_interface_lib.h\"\n#include \"xil_data_stream.h\"\n#include \"comms_interface.h\"\n\n#ifdef CODE_INSTRUMENTATION_ENABLED\n#include \"codeinstr_data_stream.h\"\n#endif\n\n#ifndef CODER_ASSUMPTIONS_ENABLED\n   #error \"CODER_ASSUMPTIONS_ENABLED should always be defined!\"\n#endif\n\n#if CODER_ASSUMPTIONS_ENABLED == 1\n#include \"coder_assumptions_data_stream.h\"\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n/* define signal handler codes */\ntypedef enum {XIL_SIGNAL_SIGFPE=0, \n              XIL_SIGNAL_SIGILL, \n              XIL_SIGNAL_ABRT,\n              XIL_SIGNAL_SEGV,\n              XIL_SIGNAL_UNKNOWN} XIL_SIGNAL_RAISED;\n\nstatic void XILSigHandler(int32_T sigNo)\n{\n  MemUnit_T memUnitData = XIL_RESPONSE_SIGNAL_RAISED;\n\n  fflush(stderr);\n  \n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  switch (sigNo)\n  {\n    case SIGFPE:\n    {\n        /* Erroneous arithmetic operation, such as division by zero */\n        memUnitData = XIL_SIGNAL_SIGFPE;\n        break;\n    }\n    case SIGILL:\n    {\n        /* Illegal, malformed, unknown or privileged instruction */\n        memUnitData = XIL_SIGNAL_SIGILL;\n        break;\n    }\n    case SIGABRT:\n    {\n        /* Signal abort */\n        memUnitData = XIL_SIGNAL_ABRT;\n        break;\n    }\n    case SIGSEGV:\n    {\n        /* Segmentation violation */\n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            void *array[MAX_STACKTRACE];\n            int bt_size = 0;\n        #endif\n            \n        memUnitData = XIL_SIGNAL_SEGV;\n            \n        #if defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))\n            bt_size = backtrace(array, MAX_STACKTRACE);\n            backtrace_symbols_fd(array, bt_size, 2);\n        #endif\n        break;\n    }\n    default:\n    {\n        memUnitData = XIL_SIGNAL_UNKNOWN;\n        break;\n    }\n  }\n  xilWriteData(&memUnitData, sizeof(memUnitData));\n  \n  xilDataFlush((MemUnit_T)1);\n  xilTerminateComms();\n}\n#endif\n\n/* Entry point (called from sil_main.c & pil_main.c) to initialize services */\nXIL_INTERFACE_LIB_ERROR_CODE xilInit(const int argc, void *argv[]) {\n    \n    if (commsInit(argc, argv) != COMMS_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n    if (silpilInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    if (codeInstrInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    if (coderAssumptionsInit()!=XIL_INTERFACE_LIB_SUCCESS) {\n        return XIL_INTERFACE_LIB_ERROR;\n    }\n#endif\n\n#ifdef XIL_SIGNAL_HANDLER\n    /* register signals to catch */\n    signal(SIGFPE, XILSigHandler);  /* Erroneous arithmetic operation */\n    signal(SIGILL, XILSigHandler);  /* Illegal operation */\n    signal(SIGABRT, XILSigHandler); /* Abort signal */\n    signal(SIGSEGV, XILSigHandler); /* Segmentation violation */\n#endif\n\n#ifdef SIL_DISABLE_SUBNORMAL_SUPPORT\n    #if SIL_DISABLE_SUBNORMAL_SUPPORT == 1\n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n    #elif SIL_DISABLE_SUBNORMAL_SUPPORT == 2\n    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n    #endif\n#endif\n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n/* Entry point (called from sil_main.c & pil_main.c) to terminate services */\nXIL_INTERFACE_LIB_ERROR_CODE xilTerminateComms(void) {\n    \n    silpilTerminate();\n    \n#ifdef CODE_INSTRUMENTATION_ENABLED\n    codeInstrTerminate();\n#endif\n    \n#if CODER_ASSUMPTIONS_ENABLED == 1\n    coderAssumptionsTerminate();\n#endif\n    \n    commsTerminate();\n    \n    return XIL_INTERFACE_LIB_SUCCESS;\n}\n\n"},{"name":"xilcomms_rtiostream.c","type":"source","group":"SILPIL","path":"C:\\Program Files\\MATLAB\\R2021b\\toolbox\\rtw\\targets\\pil\\c","tag":"In-the-Loop:SIL","groupDisplay":"SIL/PIL files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n#define USE_COMMS_ERROR\n#define USE_COMMS_SUCCESS\n#include \"xilcomms_rtiostream.h\"\n#include \"comms_interface.h\"\n#include \"rtiostream.h\"\n#include \"rtiostream_utils.h\"\n#include \"rx_tx_buffer_sizes.h\"\n#include \"xil_common.h\"\n#include \"XILTgtAppSvc.h\"\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include \"xil_data_stream.h\"\n#endif\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    extern void swapBytes(MemUnit_T * const buffer, uint32_T size);\n#endif /* HOST_BIG_ENDIAN_PROTOCOL_TESTING */\n\n/* call xilProcessMsg */\nextern void xilProcessMsg(void);\n\n/* store stream handle */\nstatic int streamID;\n\n/* allocate the buffers */\nstatic IOUnit_T xilCommsBuffer[RTIOSTREAM_RX_BUFFER_SIZE];\n\n\n/* open rtiostream */\nint commsInit(const int argc, void * argv[]){\n    \n    streamID = rtIOStreamOpen(argc, argv);\n    if (streamID == RTIOSTREAM_ERROR) {\n        return COMMS_ERROR;\n    }\n    return COMMS_SUCCESS;\n}\n\n/* close rtiostream */\nint commsTerminate(void) {    \n    if (rtIOStreamClose(streamID) == RTIOSTREAM_NO_ERROR) {\n        return COMMS_SUCCESS;\n    } else {\n        return COMMS_ERROR;\n    }\n}\n\n/* call rtIOStreamBlockingSend to send data*/\nint commsEnqueueBuffer(        \n        void* const pBuf,\n        const uint8_T appId,\n        const uint16_T dataSize) {\n    \n    int rtIOStreamErrorStatus;\n    IOUnit_T* appBuffer;\n    MemUnit_T appIdMemUnit = (MemUnit_T)appId;\n    uint32_T writeDataAvail = (uint32_T)dataSize;   \n    uint32_T transferSize = writeDataAvail + BUFFER_HEADER_SIZE;           \n\n    /* write size and application id before sending the buffer */\n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n    /* writeDataAvail is in terms of IOUnit_T (uint8_T) - convert to MemUnit_T's\n     * abort if writeDataAvail does not divide exactly */\n    uint32_T writeDataAvailMemUnits = writeDataAvail / MEM_UNIT_BYTES;\n    uint32_T memUnitsRemainder = writeDataAvail % MEM_UNIT_BYTES;\n    if (memUnitsRemainder != 0) {\n        fprintf(stderr,\"Target application aborted: the number of available Bytes in the \" \\\n            \"TargetToHost TX Buffer (%d B) does not divide exactly by the number of \" \\\n            \"Bytes per MemUnit (%d B).\\n\", writeDataAvail, MEM_UNIT_BYTES);\n        /* this condition can happen only when the buffer is full with the first\n         * chunk of outgoing data, at this point the host will not be midway through\n         * receiving a response. Therefore, it is ok to drop the pending data. */\n        resetXILWriteBuffer();\n        /* send the abort message */\n        abort();\n    }\n    \n#else\n    uint32_T writeDataAvailMemUnits = writeDataAvail;\n#endif\n    \n    /* get the pointer for the application buffer of the given app id */\n    appBuffer = (IOUnit_T*) pBuf;\n\tif (appBuffer == NULL) {\n\t\t/* early return */\n\t\treturn COMMS_ERROR;\n\t}\n        \n    UNUSED_PARAMETER(pBuf);\n    \n    memcpy((void *) &appBuffer[APPLICATION_ID_IDX], &appIdMemUnit, sizeof(appIdMemUnit));        \n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the playload size that will be sent to the host */\n    swapBytes((MemUnit_T*)(&writeDataAvailMemUnits), sizeof(writeDataAvailMemUnits));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    memcpy((void *) &appBuffer[PAYLOAD_SIZE_IDX], &writeDataAvailMemUnits, sizeof(writeDataAvailMemUnits));    \n    \n   /* Blocks until all requested outgoing data is sent */\n   rtIOStreamErrorStatus = rtIOStreamBlockingSend(streamID,\n                                                 (const void *) appBuffer,\n                                                 transferSize);\n                                                      \n   if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n         return COMMS_ERROR;\n   \n   return COMMS_SUCCESS;\n}\n\nint rtiostreamReadMessage(IOUnit_T ** currentBufferPosition, uint16_T *currentBufSize) {\n    \n    int rtIOStreamErrorStatus;\n    uint32_T dataSize = 0;\n    MemUnit_T appId;\n\n\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &appId,\n        sizeof(appId));\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t    return COMMS_ERROR;\n\n    \n    /* receive size of data contained in the buffer */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &dataSize,\n        sizeof(dataSize));\n\n#ifdef HOST_BIG_ENDIAN_PROTOCOL_TESTING\n    /* swap the bytes of the dataSize sent from the host */\n    swapBytes((MemUnit_T*)(&dataSize), sizeof(dataSize));\n#endif /*HOST_BIG_ENDIAN_PROTOCOL_TESTING*/\n\n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR)\n\t\treturn COMMS_ERROR;\n\n    \n#ifdef HOST_WORD_ADDRESSABLE_TESTING\n\t/* dataSize is in terms of MemUnit_T - convert to IOUnit_T (uint8_T). Note\n     * that dataSize will not overflow since the host already divided dataSize \n\t * by memUnit_T before transmission, so this multiplication should be safe\n     * and won't overflow.\n\t */\n    dataSize *= MEM_UNIT_BYTES;\n#endif\n\n    /* receive the data */\n    rtIOStreamErrorStatus = rtIOStreamBlockingRecv(streamID,\n        (void *) &(xilCommsBuffer[0]),\n        dataSize);\n\n    *currentBufferPosition = &(xilCommsBuffer[0]);\n    *currentBufSize = (uint16_T)dataSize;\n\n    return COMMS_SUCCESS;\n}\n\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};